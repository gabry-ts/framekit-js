function je(){const e=typeof navigator<"u"&&navigator.hardwareConcurrency?navigator.hardwareConcurrency:2;return Array.from({length:e},()=>({model:"browser"}))}function Be(){return"browser"}function Pe(){return"unknown"}function qe(){return"/tmp"}const We=`
`;var ze={cpus:je,platform:Be,arch:Pe,tmpdir:qe,EOL:We},Ke=(e=>(e.Float64="f64",e.Int32="i32",e.Int64="i64",e.Utf8="utf8",e.Boolean="bool",e.Date="date",e.DateTime="datetime",e.Null="null",e.BigInt="bigint",e.Object="object",e))(Ke||{}),He=(e=>(e.COLUMN_NOT_FOUND="COLUMN_NOT_FOUND",e.TYPE_MISMATCH="TYPE_MISMATCH",e.SHAPE_MISMATCH="SHAPE_MISMATCH",e.PARSE_ERROR="PARSE_ERROR",e.IO_ERROR="IO_ERROR",e.OUT_OF_MEMORY="OUT_OF_MEMORY",e.INVALID_OPERATION="INVALID_OPERATION",e))(He||{}),V=class extends Error{code;constructor(e,t){super(t),this.name="FrameKitError",this.code=e}},P=class extends V{constructor(e,t){super("COLUMN_NOT_FOUND",`Column '${e}' not found. Available columns: [${t.join(", ")}]`),this.name="ColumnNotFoundError"}},St=class extends V{constructor(e){super("TYPE_MISMATCH",e),this.name="TypeMismatchError"}},pt=class extends V{constructor(e){super("SHAPE_MISMATCH",e),this.name="ShapeMismatchError"}},ut=class extends V{constructor(e){super("PARSE_ERROR",e),this.name="ParseError"}},E=class extends V{constructor(e){super("IO_ERROR",e),this.name="IOError"}},j=class Vt{_buffer;_length;constructor(t,n=!1){if(t<0)throw new V("INVALID_OPERATION",`BitArray length must be non-negative, got ${t}`);this._length=t;const r=Math.ceil(t/8);this._buffer=new Uint8Array(r),n&&this._buffer.fill(255)}get length(){return this._length}get byteLength(){return this._buffer.byteLength}get(t){return this._boundsCheck(t),this.getUnsafe(t)}getUnsafe(t){const n=t>>3,r=t&7;return(this._buffer[n]&1<<r)!==0}set(t,n){this._boundsCheck(t),this.setUnsafe(t,n)}setUnsafe(t,n){const r=t>>3,s=t&7;n?this._buffer[r]=this._buffer[r]|1<<s:this._buffer[r]=this._buffer[r]&~(1<<s)}countOnes(){let t=0;for(let n=0;n<this._length;n++)this.get(n)&&t++;return t}countZeros(){return this._length-this.countOnes()}and(t){this._lengthCheck(t);const n=new Vt(this._length);for(let r=0;r<this._buffer.length;r++)n._buffer[r]=this._buffer[r]&t._buffer[r];return n}or(t){this._lengthCheck(t);const n=new Vt(this._length);for(let r=0;r<this._buffer.length;r++)n._buffer[r]=this._buffer[r]|t._buffer[r];return n}clone(){const t=new Vt(this._length);return t._buffer.set(this._buffer),t}not(){const t=new Vt(this._length);for(let n=0;n<this._buffer.length;n++)t._buffer[n]=~this._buffer[n]&255;return t}_boundsCheck(t){if(t<0||t>=this._length)throw new V("INVALID_OPERATION",`BitArray index ${t} out of bounds for length ${this._length}`)}_lengthCheck(t){if(this._length!==t._length)throw new V("SHAPE_MISMATCH",`BitArray length mismatch: ${this._length} vs ${t._length}`)}},Ct=class{_nullMask;_length;_refCount=1;constructor(e,t){this._length=e,this._nullMask=t??new j(e,!0)}get length(){return this._length}get nullCount(){return this._nullMask.countZeros()}addRef(){this._refCount++}release(){this._refCount>0&&this._refCount--}get refCount(){return this._refCount}get isShared(){return this._refCount>1}},N=class ht extends Ct{dtype="f64";_data;_allValid;constructor(t,n){super(t.length,n),this._data=t,this._allValid=n===void 0}get(t){return this._boundsCheck(t),this._allValid?this._data[t]:this._nullMask.getUnsafe(t)?this._data[t]:null}slice(t,n){const r=this._data.subarray(t,n);if(this._allValid)return new ht(r);const s=new j(r.length);for(let o=0;o<r.length;o++)s.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new ht(r,s)}clone(){return this._allValid?new ht(new Float64Array(this._data)):new ht(new Float64Array(this._data),this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new V("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let r=0;r<t.length;r++)t.get(r)===!0&&n.push(r);return this._takeByIndices(n)}take(t){const n=new Float64Array(t.length),r=this._allValid?void 0:new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r&&r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new ht(n,r)}sum(){let t=0;for(let n=0;n<this._length;n++)this._nullMask.getUnsafe(n)&&(t+=this._data[n]);return t}mean(){const t=this._length-this.nullCount;return t===0?null:this.sum()/t}min(){let t=null;for(let n=0;n<this._length;n++)if(this._nullMask.getUnsafe(n)){const r=this._data[n];(t===null||r<t)&&(t=r)}return t}max(){let t=null;for(let n=0;n<this._length;n++)if(this._nullMask.getUnsafe(n)){const r=this._data[n];(t===null||r>t)&&(t=r)}return t}estimatedMemoryBytes(){return this._length*8+this._nullMask.byteLength}static from(t){const n=new Float64Array(t.length),r=new j(t.length);let s=!1;for(let o=0;o<t.length;o++){const i=t[o];i!=null?(n[o]=i,r.setUnsafe(o,!0)):s=!0}return s?new ht(n,r):new ht(n)}_boundsCheck(t){if(t<0||t>=this._length)throw new V("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Float64Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new ht(n,r)}},at=class gt extends Ct{dtype="i32";_data;_allValid;constructor(t,n){super(t.length,n),this._data=t,this._allValid=n===void 0}get(t){return this._boundsCheck(t),this._allValid?this._data[t]:this._nullMask.getUnsafe(t)?this._data[t]:null}slice(t,n){const r=this._data.subarray(t,n);if(this._allValid)return new gt(r);const s=new j(r.length);for(let o=0;o<r.length;o++)s.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new gt(r,s)}clone(){return this._allValid?new gt(new Int32Array(this._data)):new gt(new Int32Array(this._data),this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new V("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let r=0;r<t.length;r++)t.get(r)===!0&&n.push(r);return this._takeByIndices(n)}take(t){const n=new Int32Array(t.length),r=this._allValid?void 0:new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r&&r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new gt(n,r)}sum(){let t=0;for(let n=0;n<this._length;n++)this._nullMask.getUnsafe(n)&&(t+=this._data[n]);return t}mean(){const t=this._length-this.nullCount;return t===0?null:this.sum()/t}min(){let t=null;for(let n=0;n<this._length;n++)if(this._nullMask.getUnsafe(n)){const r=this._data[n];(t===null||r<t)&&(t=r)}return t}max(){let t=null;for(let n=0;n<this._length;n++)if(this._nullMask.getUnsafe(n)){const r=this._data[n];(t===null||r>t)&&(t=r)}return t}estimatedMemoryBytes(){return this._length*4+this._nullMask.byteLength}static from(t){const n=new Int32Array(t.length),r=new j(t.length);let s=!1;for(let o=0;o<t.length;o++){const i=t[o];i!=null?(n[o]=i,r.setUnsafe(o,!0)):s=!0}return s?new gt(n,r):new gt(n)}_boundsCheck(t){if(t<0||t>=this._length)throw new V("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Int32Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new gt(n,r)}},q=class J extends Ct{dtype="utf8";_data;_interned;_allValid;constructor(t,n,r){super(t.length,n),r?(this._data=null,this._interned=r):(this._data=t,this._interned=null),this._allValid=n===void 0}get isInterned(){return this._interned!==null}get internedStorage(){return this._interned}get allValid(){return this._allValid}get nullMask(){return this._nullMask}get rawData(){return this._data}get(t){return this._boundsCheck(t),this._allValid?this._interned?this._interned.dictionary[this._interned.indices[t]]:this._data[t]:this._nullMask.getUnsafe(t)?this._interned?this._interned.dictionary[this._interned.indices[t]]:this._data[t]:null}slice(t,n){const r=n-t;if(this._allValid){if(this._interned){const i=this._interned.indices.slice(t,n);return new J(new Array(r),void 0,{dictionary:this._interned.dictionary,indices:i})}return new J(this._data.slice(t,n))}const s=new j(r);for(let i=0;i<r;i++)s.setUnsafe(i,this._nullMask.getUnsafe(t+i));if(this._interned){const i=this._interned.indices.slice(t,n);return new J(new Array(r),s,{dictionary:this._interned.dictionary,indices:i})}const o=this._data.slice(t,n);return new J(o,s)}clone(){return this._allValid?this._interned?new J(new Array(this._length),void 0,{dictionary:[...this._interned.dictionary],indices:new Uint32Array(this._interned.indices)}):new J([...this._data]):this._interned?new J(new Array(this._length),this._nullMask.clone(),{dictionary:[...this._interned.dictionary],indices:new Uint32Array(this._interned.indices)}):new J([...this._data],this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new V("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let r=0;r<t.length;r++)t.get(r)===!0&&n.push(r);return this._takeByIndices(n)}take(t){const n=t.length,r=this._allValid?void 0:new j(n);if(this._interned){const o=new Uint32Array(n);for(let i=0;i<n;i++){const l=t[i];o[i]=this._interned.indices[l],r&&r.setUnsafe(i,this._nullMask.getUnsafe(l))}return new J(new Array(n),r,{dictionary:this._interned.dictionary,indices:o})}const s=new Array(n);for(let o=0;o<n;o++){const i=t[o];s[o]=this._data[i],r&&r.setUnsafe(o,this._nullMask.getUnsafe(i))}return new J(s,r)}estimatedMemoryBytes(){let t=this._nullMask.byteLength;if(this._interned){for(const n of this._interned.dictionary)t+=n.length*2;t+=this._interned.indices.byteLength}else for(let n=0;n<this._length;n++)this._nullMask.get(n)&&(t+=this._data[n].length*2);return t}static from(t){const n=t.length;if(n===0)return new J([]);const r=new Map,s=[],o=new Uint32Array(n),i=new j(n);let l=!1,c=0;for(let a=0;a<n;a++){const f=t[a];if(f!=null){i.set(a,!0);let g=r.get(f);g===void 0&&(g=c++,r.set(f,g),s.push(f)),o[a]=g}else l=!0}if(c>0&&c<n*.5)return l?new J(new Array(n),i,{dictionary:s,indices:o}):new J(new Array(n),void 0,{dictionary:s,indices:o});const u=new Array(n);for(let a=0;a<n;a++)u[a]=t[a]??"";return l?new J(u,i):new J(u)}static fromPreInterned(t,n,r){const s=n.length;return new J(new Array(s),r,{dictionary:t,indices:n})}_boundsCheck(t){if(t<0||t>=this._length)throw new V("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=t.length,r=new j(n);if(this._interned){const o=new Uint32Array(n);for(let i=0;i<n;i++){const l=t[i];o[i]=this._interned.indices[l],r.setUnsafe(i,this._nullMask.getUnsafe(l))}return new J(new Array(n),r,{dictionary:this._interned.dictionary,indices:o})}const s=new Array(n);for(let o=0;o<n;o++){const i=t[o];s[o]=this._data[i],r.setUnsafe(o,this._nullMask.getUnsafe(i))}return new J(s,r)}},U=class At extends Ct{dtype="bool";_data;constructor(t,n){super(t.length,n),this._data=t}get(t){return this._boundsCheck(t),this._nullMask.getUnsafe(t)?this._data[t]!==0:null}slice(t,n){const r=this._data.subarray(t,n),s=new j(r.length);for(let o=0;o<r.length;o++)s.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new At(r,s)}clone(){return new At(new Uint8Array(this._data),this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new V("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let r=0;r<t.length;r++)t.get(r)===!0&&n.push(r);return this._takeByIndices(n)}take(t){const n=new Uint8Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new At(n,r)}estimatedMemoryBytes(){return this._length+this._nullMask.byteLength}static from(t){const n=new Uint8Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];o!=null&&(n[s]=o?1:0,r.setUnsafe(s,!0))}return new At(n,r)}_boundsCheck(t){if(t<0||t>=this._length)throw new V("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Uint8Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new At(n,r)}},G=class $t extends Ct{dtype="date";_data;constructor(t,n){super(t.length,n),this._data=t}get(t){return this._boundsCheck(t),this._nullMask.getUnsafe(t)?new Date(this._data[t]):null}slice(t,n){const r=this._data.subarray(t,n),s=new j(r.length);for(let o=0;o<r.length;o++)s.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new $t(r,s)}clone(){return new $t(new Float64Array(this._data),this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new V("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let r=0;r<t.length;r++)t.get(r)===!0&&n.push(r);return this._takeByIndices(n)}take(t){const n=new Float64Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new $t(n,r)}estimatedMemoryBytes(){return this._length*8+this._nullMask.byteLength}static from(t){const n=new Float64Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];o!=null&&(n[s]=o.getTime(),r.setUnsafe(s,!0))}return new $t(n,r)}_boundsCheck(t){if(t<0||t>=this._length)throw new V("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Float64Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new $t(n,r)}},dt=class Mt extends Ct{dtype="object";_data;constructor(t,n){super(t.length,n),this._data=t}get(t){return this._boundsCheck(t),this._nullMask.getUnsafe(t)?this._data[t]:null}slice(t,n){const r=this._data.slice(t,n),s=new j(r.length);for(let o=0;o<r.length;o++)s.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new Mt(r,s)}clone(){return new Mt([...this._data],this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new V("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let r=0;r<t.length;r++)t.get(r)===!0&&n.push(r);return this._takeByIndices(n)}take(t){const n=new Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new Mt(n,r)}estimatedMemoryBytes(){return this._length*8+this._nullMask.byteLength}static from(t){const n=new Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];o!=null?(n[s]=o,r.setUnsafe(s,!0)):n[s]=null}return new Mt(n,r)}_boundsCheck(t){if(t<0||t>=this._length)throw new V("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Array(t.length),r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n[s]=this._data[o],r.setUnsafe(s,this._nullMask.getUnsafe(o))}return new Mt(n,r)}},Je=class{_series;constructor(e){if(e.dtype!=="utf8")throw new St(`StringAccessor requires Series with dtype Utf8, got '${e.dtype}'`);this._series=e}toLowerCase(){return this._mapString(e=>e.toLowerCase())}toUpperCase(){return this._mapString(e=>e.toUpperCase())}trim(){return this._mapString(e=>e.trim())}startsWith(e){return this._mapBoolean(t=>t.startsWith(e))}endsWith(e){return this._mapBoolean(t=>t.endsWith(e))}contains(e){return this._mapBoolean(t=>t.includes(e))}replace(e,t){return this._mapString(n=>n.replaceAll(e,t))}split(e){const t=[],n=new j(this._series.length);for(let s=0;s<this._series.length;s++){const o=this._series.get(s);o===null?t.push([]):(t.push(o.split(e)),n.set(s,!0))}const r=new Ye(t,n);return new A(this._series.name,r)}slice(e,t){return this._mapString(n=>n.slice(e,t))}length(){const e=[];for(let t=0;t<this._series.length;t++){const n=this._series.get(t);n===null?e.push(null):e.push(n.length)}return new A(this._series.name,N.from(e))}padStart(e,t){return this._mapString(n=>n.padStart(e,t))}padEnd(e,t){return this._mapString(n=>n.padEnd(e,t))}extract(e){const t=e.source;if(!t.includes("(")||t.replace(/\\\(/g,"").indexOf("(")===-1)throw new St("extract() pattern must contain at least one capture group");const n=[];for(let r=0;r<this._series.length;r++){const s=this._series.get(r);if(s===null)n.push(null);else{const o=s.match(e);o&&o[1]!==void 0?n.push(o[1]):n.push(null)}}return new A(this._series.name,q.from(n))}_mapString(e){const t=[];for(let n=0;n<this._series.length;n++){const r=this._series.get(n);r===null?t.push(null):t.push(e(r))}return new A(this._series.name,q.from(t))}_mapBoolean(e){const t=[];for(let n=0;n<this._series.length;n++){const r=this._series.get(n);r===null?t.push(null):t.push(e(r))}return new A(this._series.name,U.from(t))}},Ye=class Pt extends Ct{dtype="utf8";_data;constructor(t,n){super(t.length,n),this._data=t}get(t){if(t<0||t>=this._length)throw new Error(`Index ${t} out of bounds for column of length ${this._length}`);return this._nullMask.get(t)?this._data[t]:null}slice(t,n){const r=this._data.slice(t,n),s=new j(r.length);for(let o=0;o<r.length;o++)s.set(o,this._nullMask.get(t+o));return new Pt(r,s)}clone(){return new Pt(this._data.map(t=>[...t]),this._nullMask.clone())}filter(t){const n=[];for(let r=0;r<t.length;r++)t.get(r)===!0&&n.push(r);return this._takeByIndices(n)}take(t){const n=[];for(let r=0;r<t.length;r++)n.push(t[r]);return this._takeByIndices(n)}estimatedMemoryBytes(){let t=this._nullMask.byteLength;for(let n=0;n<this._length;n++)if(this._nullMask.get(n))for(const r of this._data[n])t+=r.length*2;return t}_takeByIndices(t){const n=[],r=new j(t.length);for(let s=0;s<t.length;s++){const o=t[s];n.push(this._data[o]),r.set(s,this._nullMask.get(o))}return new Pt(n,r)}},Ge=class{_series;constructor(e){if(e.dtype!=="date")throw new St(`DateAccessor requires Series with dtype Date, got '${e.dtype}'`);this._series=e}year(){return this._mapNumber(e=>e.getFullYear())}month(){return this._mapNumber(e=>e.getMonth()+1)}day(){return this._mapNumber(e=>e.getDate())}hour(){return this._mapNumber(e=>e.getHours())}minute(){return this._mapNumber(e=>e.getMinutes())}second(){return this._mapNumber(e=>e.getSeconds())}dayOfWeek(){return this._mapNumber(e=>e.getDay())}dayOfYear(){return this._mapNumber(e=>{const t=new Date(e.getFullYear(),0,0),n=e.getTime()-t.getTime(),r=1e3*60*60*24;return Math.floor(n/r)})}weekNumber(){return this._mapNumber(e=>{const t=new Date(e.getTime());t.setHours(0,0,0,0),t.setDate(t.getDate()+3-(t.getDay()+6)%7);const n=new Date(t.getFullYear(),0,4),r=(t.getTime()-n.getTime())/(1e3*60*60*24);return 1+Math.round((r-3+(n.getDay()+6)%7)/7)})}quarter(){return this._mapNumber(e=>Math.floor(e.getMonth()/3)+1)}timestamp(){return this._mapNumber(e=>e.getTime())}format(e){const t=[];for(let n=0;n<this._series.length;n++){const r=this._series.get(n);r===null?t.push(null):t.push(Qe(r,e))}return new A(this._series.name,q.from(t))}diff(e,t){if(e.dtype!=="date")throw new St(`diff() requires a Date Series, got '${e.dtype}'`);if(e.length!==this._series.length)throw new St(`diff() requires Series of equal length, got ${this._series.length} and ${e.length}`);const n=[];for(let r=0;r<this._series.length;r++){const s=this._series.get(r),o=e.get(r);s===null||o===null?n.push(null):n.push(Ze(s,o,t))}return new A(this._series.name,N.from(n))}truncate(e){const t=[];for(let n=0;n<this._series.length;n++){const r=this._series.get(n);r===null?t.push(null):t.push(Xe(r,e))}return new A(this._series.name,G.from(t))}_mapNumber(e){const t=[];for(let n=0;n<this._series.length;n++){const r=this._series.get(n);r===null?t.push(null):t.push(e(r))}return new A(this._series.name,N.from(t))}};function Qe(e,t){const n=s=>String(s).padStart(2,"0"),r=s=>String(s).padStart(4,"0");return t.replace("YYYY",r(e.getFullYear())).replace("MM",n(e.getMonth()+1)).replace("DD",n(e.getDate())).replace("HH",n(e.getHours())).replace("mm",n(e.getMinutes())).replace("ss",n(e.getSeconds()))}function Ze(e,t,n){const r=e.getTime(),o=t.getTime()-r;switch(n){case"second":return o/1e3;case"minute":return o/(1e3*60);case"hour":return o/(1e3*60*60);case"day":return o/(1e3*60*60*24);case"month":{const i=t.getFullYear()-e.getFullYear(),l=t.getMonth()-e.getMonth(),c=(t.getDate()-e.getDate())/30;return i*12+l+c}case"year":{const i=t.getFullYear()-e.getFullYear(),l=(t.getMonth()-e.getMonth())/12,c=(t.getDate()-e.getDate())/365;return i+l+c}}}function Xe(e,t){switch(t){case"year":return new Date(e.getFullYear(),0,1);case"month":return new Date(e.getFullYear(),e.getMonth(),1);case"day":return new Date(e.getFullYear(),e.getMonth(),e.getDate());case"hour":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours());case"minute":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours(),e.getMinutes());case"second":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours(),e.getMinutes(),e.getSeconds())}}var Qt;function tn(e){Qt=e}var A=class X{_name;_column;constructor(t,n){this._name=t,this._column=n}get name(){return this._name}get dtype(){return this._column.dtype}get length(){return this._column.length}get nullCount(){return this._column.nullCount}get column(){return this._column}get str(){return new Je(this)}get dt(){return new Ge(this)}get(t){return this._column.get(t)}toArray(){const t=[];for(let n=0;n<this._column.length;n++)t.push(this._column.get(n));return t}sum(){return this._asNumericColumn().sum()}mean(){return this._asNumericColumn().mean()}min(){return this._asNumericColumn().min()}max(){return this._asNumericColumn().max()}std(){const t=this._asNumericColumn(),n=t.mean();if(n===null)return null;const r=t.length-t.nullCount;if(r<2)return null;let s=0;for(let o=0;o<t.length;o++){const i=t.get(o);if(i!==null){const l=i-n;s+=l*l}}return Math.sqrt(s/(r-1))}median(){const t=this._asNumericColumn(),n=[];for(let s=0;s<t.length;s++){const o=t.get(s);o!==null&&n.push(o)}if(n.length===0)return null;n.sort((s,o)=>s-o);const r=Math.floor(n.length/2);return n.length%2===0?(n[r-1]+n[r])/2:n[r]}between(t,n){const r=this._asNumericColumn(),s=[];for(let o=0;o<r.length;o++){const i=r.get(o);i===null?s.push(null):s.push(i>=t&&i<=n)}return new X(this._name,U.from(s))}cumSum(){const t=this._asNumericColumn(),n=[];let r=0;for(let s=0;s<t.length;s++){const o=t.get(s);o===null?n.push(null):(r+=o,n.push(r))}return new X(this._name,N.from(n))}abs(){const t=this._asNumericColumn(),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);s===null?n.push(null):n.push(Math.abs(s))}return new X(this._name,N.from(n))}round(t=0){const n=this._asNumericColumn(),r=Math.pow(10,t),s=[];for(let o=0;o<n.length;o++){const i=n.get(o);i===null?s.push(null):s.push(Math.round(i*r)/r)}return new X(this._name,N.from(s))}eq(t){return this._compareScalar(t,(n,r)=>n===r)}neq(t){return this._compareScalar(t,(n,r)=>n!==r)}gt(t){return this._compareScalar(t,(n,r)=>n>r)}gte(t){return this._compareScalar(t,(n,r)=>n>=r)}lt(t){return this._compareScalar(t,(n,r)=>n<r)}lte(t){return this._compareScalar(t,(n,r)=>n<=r)}isIn(t){const n=new Set(t.map(s=>this._toComparable(s))),r=[];for(let s=0;s<this._column.length;s++){const o=this._column.get(s);o===null?r.push(null):r.push(n.has(this._toComparable(o)))}return new X(this._name,U.from(r))}isNull(){const t=[];for(let n=0;n<this._column.length;n++)t.push(this._column.get(n)===null);return new X(this._name,U.from(t))}isNotNull(){const t=[];for(let n=0;n<this._column.length;n++)t.push(this._column.get(n)!==null);return new X(this._name,U.from(t))}fillNull(t){const r=this.toArray().map(s=>s===null?t:s);return new X(this._name,this._buildColumn(r))}unique(){const t=new Set,n=[];for(let r=0;r<this._column.length;r++){const s=this._column.get(r),o=s===null?"__null__":String(this._toComparable(s));t.has(o)||(t.add(o),n.push(s))}return new X(this._name,this._buildColumn(n))}nUnique(){const t=new Set;for(let n=0;n<this._column.length;n++){const r=this._column.get(n),s=r===null?"__null__":String(this._toComparable(r));t.add(s)}return t.size}valueCounts(){if(!Qt)throw new V("INVALID_OPERATION","DataFrame factory not registered");const t=new Map,n=[];for(let c=0;c<this._column.length;c++){const u=this._column.get(c),a=u===null?"__null__":String(this._toComparable(u)),f=t.get(a);f?f.count++:(t.set(a,{value:u,count:1}),n.push(a))}n.sort((c,u)=>t.get(u).count-t.get(c).count);const r=[],s=[];for(const c of n){const u=t.get(c);r.push(u.value),s.push(u.count)}const o=this._buildColumn(r),i=N.from(s),l=new Map;return l.set("value",o),l.set("count",i),Qt(l,["value","count"])}cast(t){const r=this.toArray().map(o=>o===null?null:this._castValue(o,t)),s=oe(t,r);return new X(this._name,s)}apply(t){const n=[];for(let o=0;o<this._column.length;o++)n.push(t(this._column.get(o)));let r="f64";for(const o of n)if(o!==null){typeof o=="string"?r="utf8":typeof o=="boolean"?r="bool":o instanceof Date?r="date":r="f64";break}const s=oe(r,n);return new X(this._name,s)}_asNumericColumn(){if(this._column instanceof N)return this._column;if(this._column instanceof at)return this._column;throw new St(`Cannot perform numeric operation on Series with dtype '${this.dtype}'`)}_compareScalar(t,n){const r=[];for(let s=0;s<this._column.length;s++){const o=this._column.get(s);o===null?r.push(null):r.push(n(o,t))}return new X(this._name,U.from(r))}_toComparable(t){return t instanceof Date?t.getTime():t}_buildColumn(t){switch(this._column.dtype){case"f64":return N.from(t);case"i32":return at.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);case"object":return dt.from(t);default:throw new V("INVALID_OPERATION",`Unsupported dtype: ${this._column.dtype}`)}}_castValue(t,n){switch(n){case"f64":case"i32":return typeof t=="number"?t:typeof t=="string"?Number(t):typeof t=="boolean"?t?1:0:t instanceof Date?t.getTime():Number(t);case"utf8":return t instanceof Date?t.toISOString():String(t);case"bool":return!!t;case"date":return t instanceof Date?t:typeof t=="number"?new Date(t):typeof t=="string"?new Date(t):new Date(String(t));default:throw new St(`Cannot cast to dtype '${n}'`)}}};function oe(e,t){switch(e){case"f64":return N.from(t);case"i32":return at.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);case"object":return dt.from(t);default:throw new V("INVALID_OPERATION",`Unsupported dtype for column construction: ${e}`)}}var k=class Zt{as(t){return new en(this,t)}add(t){return new xt(this,vt(t),"add")}sub(t){return new xt(this,vt(t),"sub")}mul(t){return new xt(this,vt(t),"mul")}div(t){return new xt(this,vt(t),"div")}mod(t){return new xt(this,vt(t),"mod")}pow(t){return new xt(this,vt(t),"pow")}eq(t){return new kt(this,bt(t),"eq")}neq(t){return new kt(this,bt(t),"neq")}gt(t){return new kt(this,bt(t),"gt")}gte(t){return new kt(this,bt(t),"gte")}lt(t){return new kt(this,bt(t),"lt")}lte(t){return new kt(this,bt(t),"lte")}and(t){return new le(this,ie(t),"and")}or(t){return new le(this,ie(t),"or")}not(){return new ln(this)}_aggColumnName(){const t=this.dependencies;if(t.length===0)throw new Error("Aggregation requires a column reference");return t[0]}sum(){return new ve(this._aggColumnName())}mean(){return new cn(this._aggColumnName())}count(){return new un(this._aggColumnName())}countDistinct(){return new an(this._aggColumnName())}min(){return new fn(this._aggColumnName())}max(){return new hn(this._aggColumnName())}std(){return new gn(this._aggColumnName())}first(){return new mn(this._aggColumnName())}last(){return new pn(this._aggColumnName())}list(){return new dn(this._aggColumnName())}mode(){return new wn(this._aggColumnName())}coalesce(...t){const n=t.map(r=>r instanceof Zt?r:new tt(r));return new _n([this,...n])}fillNull(t){const n=t instanceof Zt?t:new tt(t);return new yn(this,n)}isNull(){return new Sn(this)}isNotNull(){return new Cn(this)}},en=class{expr;name;constructor(e,t){this.expr=e,this.name=t}get dependencies(){return this.expr.dependencies}toString(){return`${this.expr.toString()} AS ${this.name}`}};function bt(e){return e instanceof k?e:new tt(e)}function vt(e){return e instanceof k?e:new tt(e)}function ie(e){return e instanceof k?e:new tt(e)}function ne(e,t){switch(e){case"f64":return N.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);default:return N.from(t)}}function nn(e){return typeof e=="number"?"f64":typeof e=="string"?"utf8":typeof e=="boolean"?"bool":e instanceof Date?"date":"f64"}var tt=class extends k{_value;constructor(e){super(),this._value=e}get dependencies(){return[]}toString(){return typeof this._value=="string"?`"${this._value}"`:this._value instanceof Date?this._value.toISOString():String(this._value)}evaluate(e){const t=e.length,n=new Array(t).fill(this._value),r=nn(this._value),s=ne(r,n);return new A("literal",s)}},Wt=class extends k{_name;constructor(e){super(),this._name=e}get dependencies(){return[this._name]}toString(){return this._name}evaluate(e){return e.col(this._name)}},rn={add:"+",sub:"-",mul:"*",div:"/",mod:"%",pow:"**"},xt=class extends k{_left;_right;_op;constructor(e,t,n){super(),this._left=e,this._right=t,this._op=n}get dependencies(){return[...new Set([...this._left.dependencies,...this._right.dependencies])]}toString(){return`(${this._left.toString()} ${rn[this._op]} ${this._right.toString()})`}evaluate(e){const t=this._left.evaluate(e),n=this._right.evaluate(e),r=t.length,s=[];for(let o=0;o<r;o++){const i=t.get(o),l=n.get(o);i===null||l===null?s.push(null):s.push(sn(i,l,this._op))}return new A("",N.from(s))}};function sn(e,t,n){switch(n){case"add":return e+t;case"sub":return e-t;case"mul":return e*t;case"div":return e/t;case"mod":return e%t;case"pow":return Math.pow(e,t)}}var on={eq:"==",neq:"!=",gt:">",gte:">=",lt:"<",lte:"<="},kt=class extends k{_left;_right;_op;constructor(e,t,n){super(),this._left=e,this._right=t,this._op=n}get dependencies(){return[...new Set([...this._left.dependencies,...this._right.dependencies])]}toString(){return`(${this._left.toString()} ${on[this._op]} ${this._right.toString()})`}evaluate(e){if(this._left instanceof Wt&&this._right instanceof tt){const o=this._left.dependencies[0],i=this._right._value,l=e.col(o).column,c=l.length,u=new Array(c);for(let a=0;a<c;a++){const f=l.get(a);f===null||i===null?u[a]=null:u[a]=Kt(f,i,this._op)}return new A("",U.from(u))}if(this._left instanceof tt&&this._right instanceof Wt){const o=this._left._value,i=this._right.dependencies[0],l=e.col(i).column,c=l.length,u=new Array(c);for(let a=0;a<c;a++){const f=l.get(a);o===null||f===null?u[a]=null:u[a]=Kt(o,f,this._op)}return new A("",U.from(u))}const t=this._left.evaluate(e),n=this._right.evaluate(e),r=t.length,s=new Array(r);for(let o=0;o<r;o++){const i=t.get(o),l=n.get(o);i===null||l===null?s[o]=null:s[o]=Kt(i,l,this._op)}return new A("",U.from(s))}};function Kt(e,t,n){switch(n){case"eq":return e===t;case"neq":return e!==t;case"gt":return e>t;case"gte":return e>=t;case"lt":return e<t;case"lte":return e<=t}}var le=class extends k{_left;_right;_op;constructor(e,t,n){super(),this._left=e,this._right=t,this._op=n}get dependencies(){return[...new Set([...this._left.dependencies,...this._right.dependencies])]}toString(){return`(${this._left.toString()} ${this._op.toUpperCase()} ${this._right.toString()})`}evaluate(e){const t=this._left.evaluate(e),n=this._right.evaluate(e),r=t.length,s=[];for(let o=0;o<r;o++){const i=t.get(o),l=n.get(o);i===null||l===null?s.push(null):this._op==="and"?s.push(i&&l):s.push(i||l)}return new A("",U.from(s))}},ln=class extends k{_inner;constructor(e){super(),this._inner=e}get dependencies(){return this._inner.dependencies}toString(){return`NOT ${this._inner.toString()}`}evaluate(e){const t=this._inner.evaluate(e),n=t.length,r=[];for(let s=0;s<n;s++){const o=t.get(s);r.push(o===null?null:!o)}return new A("",U.from(r))}};function ot(e){return new Wt(e)}function Y(e){return new tt(e)}function be(e){return e instanceof Date?`\0date${e.getTime()}`:typeof e=="string"?`\0str${e}`:typeof e=="number"?`\0num${e}`:typeof e=="boolean"?`\0bool${e}`:`\0other${String(e)}`}var it=class extends k{_columnName;constructor(e){super(),this._columnName=e}get dependencies(){return[this._columnName]}toString(){return`${this._aggName}(${this._columnName})`}evaluate(e){const n=[this.evaluateFrame(e)],r=N.from(n);return new A("",r)}evaluateFrame(e){const t=e.col(this._columnName);return this.evaluateColumn(t.column)}},ve=class extends it{_aggName="sum";evaluateColumn(e){let t=0;for(let n=0;n<e.length;n++){const r=e.get(n);r!==null&&typeof r=="number"&&(t+=r)}return t}},cn=class extends it{_aggName="mean";evaluateColumn(e){let t=0,n=0;for(let r=0;r<e.length;r++){const s=e.get(r);s!==null&&typeof s=="number"&&(t+=s,n++)}return n===0?null:t/n}},un=class extends it{_aggName="count";evaluateColumn(e){let t=0;for(let n=0;n<e.length;n++)e.get(n)!==null&&t++;return t}},an=class extends it{_aggName="count_distinct";evaluateColumn(e){const t=new Set;for(let n=0;n<e.length;n++){const r=e.get(n);r!==null&&t.add(be(r))}return t.size}},fn=class extends it{_aggName="min";evaluateColumn(e){let t=null;for(let n=0;n<e.length;n++){const r=e.get(n);r!==null&&typeof r=="number"&&(t===null||r<t)&&(t=r)}return t}},hn=class extends it{_aggName="max";evaluateColumn(e){let t=null;for(let n=0;n<e.length;n++){const r=e.get(n);r!==null&&typeof r=="number"&&(t===null||r>t)&&(t=r)}return t}},gn=class extends it{_aggName="std";evaluateColumn(e){const t=[];for(let s=0;s<e.length;s++){const o=e.get(s);o!==null&&typeof o=="number"&&t.push(o)}if(t.length<2)return null;const n=t.reduce((s,o)=>s+o,0)/t.length,r=t.reduce((s,o)=>s+(o-n)**2,0);return Math.sqrt(r/(t.length-1))}},mn=class extends it{_aggName="first";evaluateColumn(e){for(let t=0;t<e.length;t++){const n=e.get(t);if(n!==null)return n}return null}},pn=class extends it{_aggName="last";evaluateColumn(e){for(let t=e.length-1;t>=0;t--){const n=e.get(t);if(n!==null)return n}return null}},dn=class extends it{_aggName="list";evaluateColumn(e){const t=[];for(let n=0;n<e.length;n++){const r=e.get(n);r!==null&&t.push(r)}return t}},wn=class extends it{_aggName="mode";evaluateColumn(e){const t=new Map;for(let s=0;s<e.length;s++){const o=e.get(s);if(o!==null){const i=be(o),l=t.get(i);l?l.count++:t.set(i,{value:o,count:1})}}let n=null,r=0;for(const s of t.values())s.count>r&&(n=s.value,r=s.count);return n}},_n=class extends k{_exprs;constructor(e){super(),this._exprs=e}get dependencies(){const e=new Set;for(const t of this._exprs)for(const n of t.dependencies)e.add(n);return[...e]}toString(){return`coalesce(${this._exprs.map(e=>e.toString()).join(", ")})`}evaluate(e){const t=this._exprs.map(l=>l.evaluate(e)),n=t[0].length,r=[];for(let l=0;l<n;l++){let c=null;for(const u of t){const a=u.get(l);if(a!==null){c=a;break}}r.push(c)}const o=t[0].column.dtype,i=ne(o,r);return new A("",i)}},yn=class extends k{_inner;_fill;constructor(e,t){super(),this._inner=e,this._fill=t}get dependencies(){return[...new Set([...this._inner.dependencies,...this._fill.dependencies])]}toString(){return`fillNull(${this._inner.toString()}, ${this._fill.toString()})`}evaluate(e){const t=this._inner.evaluate(e),n=this._fill.evaluate(e),r=t.length,s=[];for(let l=0;l<r;l++){const c=t.get(l);s.push(c!==null?c:n.get(l))}const o=t.column.dtype,i=ne(o,s);return new A("",i)}},Sn=class extends k{_inner;constructor(e){super(),this._inner=e}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()} IS NULL`}evaluate(e){const t=this._inner.evaluate(e),n=t.length,r=[];for(let s=0;s<n;s++)r.push(t.get(s)===null);return new A("",U.from(r))}},Cn=class extends k{_inner;constructor(e){super(),this._inner=e}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()} IS NOT NULL`}evaluate(e){const t=this._inner.evaluate(e),n=t.length,r=[];for(let s=0;s<n;s++)r.push(t.get(s)!==null);return new A("",U.from(r))}},bn=["","null","NULL","NA","N/A","NaN","nan","None","none"],Z=34,z=10,K=13,vn=44,xn=59,Xt=9,kn=124;function Nn(e,t={}){if(e.length===0)return{header:[],columns:{},inferredTypes:{}};const n=t.comment,r=t.hasHeader!==!1,s=new Set(t.nullValues??bn),o=t.skipRows??0,i=t.delimiter??In(e),l=i.charCodeAt(0),c=i.length,u=c>1;let a=0,f=0;for(;f<o&&a<e.length;)a=Ft(e,a),f++;if(n)for(;a<e.length;){let b=a;for(;b<e.length;){const x=e.charCodeAt(b);if(x!==32&&x!==Xt)break;b++}if(b<e.length&&e.startsWith(n,b))a=Ft(e,a);else break}let g;if(t.header)g=t.header,r&&(a=Ft(e,a));else if(r){const b=ce(e,a,l,c,u,i);g=b.fields.map(x=>x.trim()),a=b.nextPos}else g=ce(e,a,l,c,u,i).fields.map((x,$)=>`column_${$}`);if(g.length===0)return{header:[],columns:{},inferredTypes:{}};const h=t.columns?new Set(t.columns):null,p=[],m=[];for(let b=0;b<g.length;b++){const x=g[b];h&&!h.has(x)||(p.push(x),m.push(b))}const d=Math.max(1,Math.floor(e.length/40)),w={};for(const b of p){const x=[];d>1e3&&(x.length=d,x.length=0),w[b]=x}const _=t.nRows??1/0;let C=0;const S=p.length,y=S===g.length;for(;a<e.length&&C<_;){if(n){let b=a;for(;b<e.length;){const x=e.charCodeAt(b);if(x!==32&&x!==Xt)break;b++}if(b<e.length&&e.startsWith(n,b)){a=Ft(e,a);continue}}if(e.charCodeAt(a)===z||e.charCodeAt(a)===K){a=Ft(e,a);continue}y?a=An(e,a,l,c,u,i,w,p,S,s):a=$n(e,a,l,c,u,i,w,p,m,S,s),C++}const v=En(w,p,t);return{header:p,columns:w,inferredTypes:v}}function Ft(e,t){let n=!1;for(;t<e.length;){const r=e.charCodeAt(t);if(r===Z)n=!n;else if(!n){if(r===K)return t++,t<e.length&&e.charCodeAt(t)===z&&t++,t;if(r===z)return t+1}t++}return t}function ce(e,t,n,r,s,o){const i=[],l=e.length;for(;t<=l;){if(t>=l){i.push("");break}const c=e.charCodeAt(t);if(c===K||c===z)return i.push(""),c===K&&t+1<l&&e.charCodeAt(t+1)===z?t+=2:t+=1,{fields:i,nextPos:t};if(c===Z){t++;const u=t;let a=!1;for(;t<l;)if(e.charCodeAt(t)===Z)if(t+1<l&&e.charCodeAt(t+1)===Z)a=!0,t+=2;else break;else t++;let f;if(a?f=e.substring(u,t).replace(/""/g,'"'):f=e.substring(u,t),i.push(f),t<l&&t++,t<l){const g=e.charCodeAt(t);if(g===K||g===z)return g===K&&t+1<l&&e.charCodeAt(t+1)===z?t+=2:t+=1,{fields:i,nextPos:t};(s?e.startsWith(o,t):g===n)&&(t+=r)}}else{const u=t;for(;t<l;){const f=e.charCodeAt(t);if(f===K||f===z||(s?e.startsWith(o,t):f===n))break;t++}if(i.push(e.substring(u,t)),t>=l)return{fields:i,nextPos:t};const a=e.charCodeAt(t);if(a===K||a===z)return a===K&&t+1<l&&e.charCodeAt(t+1)===z?t+=2:t+=1,{fields:i,nextPos:t};t+=r}}return{fields:i,nextPos:t}}function An(e,t,n,r,s,o,i,l,c,u){const a=e.length;let f=0;for(;t<a&&f<=c;){const g=e.charCodeAt(t);if(g===K||g===z){for(;f<c;)i[l[f]].push(null),f++;return g===K&&t+1<a&&e.charCodeAt(t+1)===z?t+2:t+1}if(f>=c)return Mn(e,t);if(g===Z){t++;const h=t;let p=!1;for(;t<a;)if(e.charCodeAt(t)===Z)if(t+1<a&&e.charCodeAt(t+1)===Z)p=!0,t+=2;else break;else t++;let m;if(p?m=e.substring(h,t).replace(/""/g,'"'):m=e.substring(h,t),t<a&&t++,i[l[f]].push(u.has(m)?null:m),f++,t<a){const w=e.charCodeAt(t);if(w===K||w===z)continue;(s?e.startsWith(o,t):w===n)&&(t+=r)}}else{const h=t;for(;t<a;){const w=e.charCodeAt(t);if(w===K||w===z||(s?e.startsWith(o,t):w===n))break;t++}const p=e.substring(h,t);if(i[l[f]].push(u.has(p)?null:p),f++,t>=a)break;const d=e.charCodeAt(t);if(d===K||d===z)continue;t+=r}}for(;f<c;)i[l[f]].push(null),f++;return t}function $n(e,t,n,r,s,o,i,l,c,u,a){const f=e.length;let g=0,h=0,m=c[0]??-1;for(;t<f;){const d=e.charCodeAt(t);if(d===K||d===z){for(;h<u;)i[l[h]].push(null),h++;return d===K&&t+1<f&&e.charCodeAt(t+1)===z?t+2:t+1}const w=g===m;if(d===Z)if(t++,w){const C=t;let S=!1;for(;t<f;)if(e.charCodeAt(t)===Z)if(t+1<f&&e.charCodeAt(t+1)===Z)S=!0,t+=2;else break;else t++;let y;S?y=e.substring(C,t).replace(/""/g,'"'):y=e.substring(C,t),t<f&&t++,i[l[h]].push(a.has(y)?null:y),h++,m=h<u?c[h]:-1}else for(;t<f;)if(e.charCodeAt(t)===Z)if(t+1<f&&e.charCodeAt(t+1)===Z)t+=2;else{t++;break}else t++;else{const C=t;for(;t<f;){const S=e.charCodeAt(t);if(S===K||S===z||(s?e.startsWith(o,t):S===n))break;t++}if(w){const S=e.substring(C,t);i[l[h]].push(a.has(S)?null:S),h++,m=h<u?c[h]:-1}}if(g++,t>=f)break;const _=e.charCodeAt(t);_===K||_===z||(s?e.startsWith(o,t):_===n)&&(t+=r)}for(;h<u;)i[l[h]].push(null),h++;return t}function Mn(e,t){let n=!1;const r=e.length;for(;t<r;){const s=e.charCodeAt(t);if(s===Z)n=!n;else if(!n){if(s===K)return t++,t<r&&e.charCodeAt(t)===z&&t++,t;if(s===z)return t+1}t++}return t}function In(e){const t=[vn,xn,Xt,kn],n=[",",";","	","|"],r=10;let s=",",o=-1;for(let i=0;i<t.length;i++){const l=t[i],c=[];let u=0,a=0;for(;u<e.length&&a<r;){let p=0,m=!1;for(;u<e.length;){const d=e.charCodeAt(u);if(d===Z)m=!m;else if(!m&&(d===l&&p++,d===K||d===z)){d===K&&u+1<e.length&&e.charCodeAt(u+1)===z&&u++,u++;break}u++}c.push(p),a++}if(c.length===0)continue;const f=c.reduce((p,m)=>p+m,0)/c.length;if(f===0)continue;const h=c.every(p=>p===c[0])?f*2:f;h>o&&(o=h,s=n[i])}return s}function En(e,t,n){const r={},s=n.parseNumbers!==!1,o=n.parseDates!==!1;for(const i of t){if(n.dtypes&&i in n.dtypes){r[i]=n.dtypes[i];continue}const c=e[i].slice(0,100).filter(u=>u!==null);if(c.length===0){r[i]="utf8";continue}if(s&&c.every(xe)){r[i]=c.every(Dn)?"i32":"f64";continue}if(c.every(On)){r[i]="bool";continue}if(o&&c.every(Tn)){r[i]="date";continue}r[i]="utf8"}return r}function xe(e){if(e.length===0)return!1;const t=Number(e);return!Number.isNaN(t)&&e.trim().length>0}function Dn(e){if(!xe(e))return!1;const t=Number(e);return Number.isInteger(t)&&!e.includes(".")&&!e.includes("e")&&!e.includes("E")}function On(e){const t=e.toLowerCase();return t==="true"||t==="false"}var Rn=/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}(:\d{2})?(\.\d+)?(Z|[+-]\d{2}:?\d{2})?)?$/;function Tn(e){if(!Rn.test(e))return!1;const t=new Date(e);return!Number.isNaN(t.getTime())}function Fn(e,t,n={}){const r=n.delimiter??",",s=n.quoteStyle??"necessary",o=n.nullValue??"",i=n.header!==!1,l=n.bom===!0,c=[];l&&c.push("\uFEFF"),i&&c.push(e.map(u=>Lt(u,r,s)).join(r));for(const u of t){const a=u.map(f=>f==null?Lt(o,r,s):f instanceof Date?Lt(f.toISOString(),r,s):Lt(typeof f=="number"||typeof f=="string"||typeof f=="boolean"?String(f):JSON.stringify(f),r,s));c.push(a.join(r))}return c.join(`
`)+`
`}function Lt(e,t,n){return n==="never"?e:n==="always"?'"'+e.replace(/"/g,'""')+'"':e.includes(t)||e.includes('"')||e.includes(`
`)||e.includes("\r")?'"'+e.replace(/"/g,'""')+'"':e}var Ln=["","null","NULL","NA","N/A","NaN","nan","None","none"];async function*Vn(e,t={}){const n=t.chunkSize??1e4,r=await import("./__vite-browser-external-9wXp6ZBx.js"),{createReadStream:s}=r;let o;try{o=s(e,{encoding:t.encoding??"utf-8"})}catch(R){const T=R instanceof Error?R.message:String(R);throw new E(`Failed to open CSV file '${e}': ${T}`)}const i=t.hasHeader!==!1,l=new Set(t.nullValues??Ln),c=t.comment,u=t.skipRows??0;let a=null,f="",g=!1,h=[],p=0,m=!1,d={},w=0,_=0;const C=t.nRows;function S(R,T){const O=[];let F="",W=!1,L=0;for(;L<R.length;){const B=R[L];W?B==='"'?L+1<R.length&&R[L+1]==='"'?(F+='"',L+=2):(W=!1,L++):(F+=B,L++):B==='"'&&F.length===0?(W=!0,L++):R.startsWith(T,L)?(O.push(F),F="",L+=T.length):(F+=B,L++)}if(W)throw new ut("Unterminated quoted field in CSV");return O.push(F),O}function y(R){const T=[",",";","	","|"];let O=",",F=-1;for(const W of T){const L=R.map(et=>{let wt=0,Tt=!1;for(let Bt=0;Bt<et.length;Bt++)et[Bt]==='"'?Tt=!Tt:!Tt&&et.startsWith(W,Bt)&&wt++;return wt});if(L.length===0)continue;const B=L.reduce((et,wt)=>et+wt,0)/L.length;if(B===0)continue;const Q=L.every(et=>et===L[0])?B*2:B;Q>F&&(F=Q,O=W)}return O}function v(R,T,O){const F={},W=O.parseNumbers!==!1,L=O.parseDates!==!1;for(const B of T){if(O.dtypes&&B in O.dtypes){F[B]=O.dtypes[B];continue}const Q=R[B].slice(0,100).filter(et=>et!==null);if(Q.length===0){F[B]="utf8";continue}if(W&&Q.every(ke)){F[B]=Q.every(Un)?"i32":"f64";continue}if(Q.every(jn)){F[B]="bool";continue}if(L&&Q.every(Pn)){F[B]="date";continue}F[B]="utf8"}return F}function b(R){const T={};for(const O of R)T[O]=[];return T}function x(R,T){for(let O=0;O<T.header.length;O++){const F=T.header[O],W=O<R.length?R[O]:"",L=T.nullValues.has(W)?null:W;d[F].push(L)}w++}let $=null,M=null;function D(R){if(c&&R.trimStart().startsWith(c))return null;if(p<u)return p++,null;if(!m)return M=t.delimiter??y([R]),t.header?($=t.header,h.push(R)):i?$=S(R,M).map(O=>O.trim()):($=S(R,M).map((F,W)=>`column_${W}`),h.push(R)),m=!0,null;if(!a){h.push(R);const O=M,F=$,W=b(F);for(const B of h){const ft=S(B,O);for(let Q=0;Q<F.length;Q++){const et=F[Q],wt=Q<ft.length?ft[Q]:"",Tt=l.has(wt)?null:wt;W[et].push(Tt)}}const L=v(W,F,t);a={header:F,delimiter:O,nullValues:l,inferredTypes:L},d=b(F);for(const B of h){const ft=S(B,O);x(ft,a)}if(h=[],w>=n){const B={header:a.header,rawColumns:d,inferredTypes:a.inferredTypes};return d=b(a.header),_+=w,w=0,B}return null}const T=S(R,a.delimiter);if(x(T,a),w>=n){const O={header:a.header,rawColumns:d,inferredTypes:a.inferredTypes};return d=b(a.header),_+=w,w=0,O}return null}for await(const R of o){f+=R;let T=0;for(let O=0;O<f.length;O++){const F=f[O];if(F==='"')g=!g;else if(!g&&(F===`
`||F==="\r")){const W=f.slice(T,O);if(F==="\r"&&O+1<f.length&&f[O+1]===`
`&&O++,T=O+1,W.length>0){if(C!==void 0&&_+w>=C)break;const L=D(W);if(L&&(yield L,C!==void 0&&_>=C)){o.destroy();return}}}}if(f=f.slice(T),C!==void 0&&_>=C){o.destroy();return}}f.length>0&&!(C!==void 0&&_>=C)&&(!c||!f.trimStart().startsWith(c))&&D(f);const H=a;if(w>0&&H!==null){if(C!==void 0){const R=C-_;if(R<=0)return;if(R<w)for(const T of H.header)d[T]=d[T].slice(0,R)}yield{header:H.header,rawColumns:d,inferredTypes:H.inferredTypes}}}function ke(e){if(e.length===0)return!1;const t=Number(e);return!Number.isNaN(t)&&e.trim().length>0}function Un(e){if(!ke(e))return!1;const t=Number(e);return Number.isInteger(t)&&!e.includes(".")&&!e.includes("e")&&!e.includes("E")}function jn(e){const t=e.toLowerCase();return t==="true"||t==="false"}var Bn=/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}(:\d{2})?(\.\d+)?(Z|[+-]\d{2}:?\d{2})?)?$/;function Pn(e){if(!Bn.test(e))return!1;const t=new Date(e);return!Number.isNaN(t.getTime())}async function*qn(e,t={}){const n=t.chunkSize??1e4,r=t.nRows,s=await import("./__vite-browser-external-9wXp6ZBx.js"),{createReadStream:o}=s;let i;try{i=o(e,{encoding:t.encoding??"utf-8"})}catch(a){const f=a instanceof Error?a.message:String(a);throw new E(`Failed to open NDJSON file '${e}': ${f}`)}let l="",c=[],u=0;for await(const a of i){l+=a;let f=0;for(let g=0;g<l.length;g++){const h=l[g];if(h===`
`||h==="\r"){const p=l.slice(f,g);if(h==="\r"&&g+1<l.length&&l[g+1]===`
`&&g++,f=g+1,p.trim().length>0&&(c.push(JSON.parse(p)),c.length>=n&&(yield c,u+=c.length,c=[],r!==void 0&&u>=r))){i.destroy();return}}}l=l.slice(f)}if(l.trim().length>0&&c.push(JSON.parse(l)),c.length>0){if(r!==void 0){const a=r-u;if(a<=0)return;a<c.length&&(c=c.slice(0,a))}yield c}}function Wn(e,t,n={}){const r=[];for(const s of t){const o={};for(let i=0;i<e.length;i++){const l=s[i];l instanceof Date?o[e[i]]=l.toISOString():o[e[i]]=l??null}r.push(o)}return n.pretty?JSON.stringify(r,null,2):JSON.stringify(r)}function zn(e,t){const n=[];for(const r of t){const s={};for(let o=0;o<e.length;o++){const i=r[o];i instanceof Date?s[e[o]]=i.toISOString():s[e[o]]=i??null}n.push(JSON.stringify(s))}return n.join(`
`)+`
`}function Kn(e){return e==null||typeof e=="number"?"f64":typeof e=="boolean"?"bool":e instanceof Date?"date":typeof e=="string"?"utf8":typeof e=="object"?"object":"utf8"}function ue(e){const t=/^([A-Z]+)(\d+)$/.exec(e.toUpperCase());if(!t)throw new E(`Invalid cell reference: '${e}'`);const n=t[1],r=parseInt(t[2],10);let s=0;for(let o=0;o<n.length;o++)s=s*26+(n.charCodeAt(o)-64);return{col:s,row:r}}function Hn(e){const t=e.split(":");if(t.length!==2)throw new E(`Invalid range format: '${e}'. Expected format like 'A1:G100'`);const n=ue(t[0]),r=ue(t[1]);return{startCol:n.col,startRow:n.row,endCol:r.col,endRow:r.row}}function Jn(e,t){if(t===void 0||t===0){const r=e.worksheets[0];if(!r)throw new E("Workbook contains no worksheets");return r}if(typeof t=="number"){const r=e.worksheets[t];if(!r)throw new E(`Worksheet at index ${String(t)} not found`);return r}const n=e.getWorksheet(t);if(!n)throw new E(`Worksheet '${t}' not found`);return n}function Yn(e){if(e==null)return null;if(typeof e=="object"&&e!==null&&!Array.isArray(e)&&!(e instanceof Date)){if("richText"in e)return e.richText.map(t=>String(t.text)).join("");if("result"in e)return e.result}return e}function Gn(e,t={}){const n=t.hasHeader!==!1,r=t.range;let s,o,i,l;if(r){const h=Hn(r);s=h.startRow,o=h.endRow,i=h.startCol,l=h.endCol}else s=1,o=e.rowCount,i=1,l=e.columnCount;if(o<s||l<i)return{header:[],columns:{},inferredTypes:{}};const c=[];for(let h=s;h<=o;h++){const p=e.getRow(h),m=[];for(let d=i;d<=l;d++){const w=p.getCell(d);m.push(Yn(w.value))}c.push(m)}let u,a;if(n&&c.length>0)u=c[0].map((h,p)=>h==null?`column_${String(p)}`:typeof h=="string"?h:typeof h=="number"||typeof h=="boolean"||typeof h=="bigint"?String(h):h instanceof Date?h.toISOString():`column_${String(p)}`),a=1;else{const h=l-i+1;u=Array.from({length:h},(p,m)=>`column_${String(m)}`),a=0}const f={};for(const h of u)f[h]=[];for(let h=a;h<c.length;h++){const p=c[h];for(let m=0;m<u.length;m++){const d=u[m];f[d].push(m<p.length?p[m]??null:null)}}const g={};for(const h of u)if(t.dtypes?.[h]!==void 0)g[h]=t.dtypes[h];else{const p=f[h];let m="f64";for(const d of p)if(d!=null){m=Kn(d);break}g[h]=m}return{header:u,columns:f,inferredTypes:g}}async function Qn(e,t={}){let n;try{n=await import("./exceljs.min-CskDqBR3.js").then(function(r){return r.e})}catch{throw new E("exceljs is required to read Excel files but is not installed. Run: npm install exceljs")}try{const r=new n.Workbook;await r.xlsx.readFile(e);const s=Jn(r,t.sheet);return Gn(s,t)}catch(r){if(r instanceof E)throw r;const s=r instanceof Error?r.message:String(r);throw new E(`Failed to read Excel file '${e}': ${s}`)}}function Zn(e){const n=(e.type?.toString?.()??String(e.type)).toLowerCase();return n.includes("int32")||n.includes("int16")||n.includes("int8")?"i32":n.includes("int64")||n.includes("int")||n.includes("uint")||n.includes("float")||n.includes("double")||n.includes("decimal")?"f64":n.includes("utf8")||n.includes("string")||n.includes("largestring")||n.includes("largeutf8")?"utf8":n==="bool"||n.includes("boolean")?"bool":n.includes("date")||n.includes("timestamp")?"date":"utf8"}function Xn(e,t,n){const r=[];for(let s=0;s<n;s++){if(e.isValid(s)===!1){r.push(null);continue}let o=e.get(s);typeof o=="bigint"&&(o=Number(o)),t==="date"&&typeof o=="number"&&(o=new Date(o)),r.push(o)}return r}async function tr(e,t={}){let n;try{n=await import("parquet-wasm")}catch{throw new E("parquet-wasm is required to read Parquet files but is not installed. Run: npm install parquet-wasm")}try{const s=await(await import("./__vite-browser-external-9wXp6ZBx.js")).readFile(e),o=new Uint8Array(s.buffer,s.byteOffset,s.byteLength),i=n.readParquet(o),l=i.schema,c=l.numFields??l.fields?.length??0,u=i.numRows??0,a=[];for(let m=0;m<c;m++){const d=l.field(m),w=String(d.name),_=Zn(d);a.push({name:w,dtype:_,index:m})}const f=t.columns?a.filter(m=>t.columns.includes(m.name)):a,g=[],h={},p={};for(const m of f){g.push(m.name),p[m.name]=m.dtype;const d=i.getChildAt(m.index);d?h[m.name]=Xn(d,m.dtype,u):h[m.name]=new Array(u).fill(null)}return{header:g,columns:h,inferredTypes:p}}catch(r){if(r instanceof E)throw r;const s=r instanceof Error?r.message:String(r);throw new E(`Failed to read Parquet file '${e}': ${s}`)}}function er(e){const t=/^([A-Z]+)(\d+)$/.exec(e.toUpperCase());if(!t)throw new E(`Invalid cell reference: '${e}'`);const n=t[1],r=parseInt(t[2],10);let s=0;for(let o=0;o<n.length;o++)s=s*26+(n.charCodeAt(o)-64);return{col:s,row:r}}function Nt(e){let t="",n=e;for(;n>0;){const r=(n-1)%26;t=String.fromCharCode(65+r)+t,n=Math.floor((n-1)/26)}return t}async function nr(e,t,n,r={}){let s;try{s=await import("./exceljs.min-CskDqBR3.js").then(function(o){return o.e})}catch{throw new E("exceljs is required to write Excel files but is not installed. Run: npm install exceljs")}try{const o=new s.Workbook,i=r.sheet??"Sheet1",l=o.addWorksheet(i),c=r.startCell??"A1",{col:u,row:a}=er(c);for(let f=0;f<t.length;f++){const h=`${Nt(u+f)}${String(a)}`;l.getCell(h).value=t[f]}for(let f=0;f<n.length;f++){const g=n[f];for(let h=0;h<t.length;h++){const m=`${Nt(u+h)}${String(a+1+f)}`,d=h<g.length?g[h]:null;l.getCell(m).value=d??null}}if(r.autoFilter){const f=Nt(u+t.length-1),g=a+n.length;l.autoFilter=`${Nt(u)}${String(a)}:${f}${String(g)}`}if(r.freezePanes){const f=r.freezePanes.row,g=r.freezePanes.col;l.views=[{state:"frozen",xSplit:g,ySplit:a-1+f,topLeftCell:`${Nt(u+g)}${String(a+f)}`,activeCell:`${Nt(u)}${String(a)}`}]}if(r.columnWidths)for(let f=0;f<t.length;f++){const g=t[f],h=r.columnWidths[g];if(h!==void 0){const p=l.getColumn(u+f);p.width=h}}await o.xlsx.writeFile(e)}catch(o){if(o instanceof E)throw o;const i=o instanceof Error?o.message:String(o);throw new E(`Failed to write Excel file '${e}': ${i}`)}}function rr(e,t){switch(t){case"f64":return new e.Float64;case"i32":return new e.Int32;case"utf8":return new e.Utf8;case"bool":return new e.Bool;case"date":case"datetime":return new e.DateMillisecond;default:return new e.Utf8}}function sr(e,t){switch(t){case"f64":case"i32":return e.map(n=>n==null?null:Number(n));case"utf8":return e.map(n=>n==null?null:typeof n=="string"?n:typeof n=="number"||typeof n=="boolean"||typeof n=="bigint"?String(n):typeof n=="object"?JSON.stringify(n):String(n));case"bool":return e.map(n=>n==null?null:!!n);case"date":case"datetime":return e.map(n=>n==null?null:n instanceof Date?n.getTime():typeof n=="number"?n:null);default:return e.map(n=>n==null?null:typeof n=="string"?n:typeof n=="number"||typeof n=="boolean"||typeof n=="bigint"?String(n):typeof n=="object"?JSON.stringify(n):String(n))}}function or(e,t){const n=e.Compression;if(!n)return t.toUpperCase();switch(t){case"snappy":return n.SNAPPY;case"gzip":return n.GZIP;case"zstd":return n.ZSTD;case"none":return n.UNCOMPRESSED}}async function ir(e,t,n,r={}){let s;try{s=await import("parquet-wasm")}catch{throw new E("parquet-wasm is required to write Parquet files but is not installed. Run: npm install parquet-wasm")}let o;try{o=await import("apache-arrow")}catch{throw new E("apache-arrow is required to write Parquet files but is not installed. Run: npm install apache-arrow")}try{const i=[],l={};for(const _ of t){const C=n[_],S=rr(o,C.dtype);i.push(new o.Field(_,S,!0));const y=sr(C.values,C.dtype);l[_]=o.vectorFromArray(y,S)}const c=new o.Schema(i),u=new o.Table(c,l),a=o.tableToIPC(u,"stream"),f=s.Table.fromIPCStream(a),g=r.compression??"snappy",h=or(s,g);let p=new s.WriterPropertiesBuilder;p=p.setCompression(h),r.rowGroupSize!==void 0&&(p=p.setMaxRowGroupSize(r.rowGroupSize));const m=p.build(),d=s.writeParquet(f,m);await(await import("./__vite-browser-external-9wXp6ZBx.js")).writeFile(e,d)}catch(i){if(i instanceof E)throw i;const l=i instanceof Error?i.message:String(i);throw new E(`Failed to write Parquet file '${e}': ${l}`)}}function lr(e,t){switch(t){case"f64":return new e.Float64;case"i32":return new e.Int32;case"utf8":return new e.Utf8;case"bool":return new e.Bool;case"date":case"datetime":return new e.DateMillisecond;default:return new e.Utf8}}function cr(e,t){if(e==null)return null;switch(t){case"f64":case"i32":return Number(e);case"bool":return!!e;case"date":case"datetime":return e instanceof Date?e.getTime():typeof e=="number"?e:new Date(e).getTime();default:return typeof e=="string"?e:typeof e=="number"||typeof e=="boolean"||typeof e=="bigint"?String(e):typeof e=="object"?JSON.stringify(e):String(e)}}async function ur(e){let t;try{t=await import("apache-arrow")}catch{throw new E("apache-arrow is required for Arrow interop but is not installed. Run: npm install apache-arrow")}const{columnOrder:n,getColumnValues:r}=e,s={};for(const o of n){const{values:i,dtype:l}=r(o),c=lr(t,l),u=i.map(a=>cr(a,l));s[o]=t.vectorFromArray(u,c)}return new t.Table(s)}function ar(e){const t=e.type?.typeId,n=String(e.type??"");switch(t){case 2:return"i32";case 3:return"f64";case 5:return"utf8";case 6:return"bool";case 8:case 10:return"date";case-1:return n.includes("Utf8"),"utf8";default:return n.includes("Int")?"i32":n.includes("Float")?"f64":n.includes("Utf8")||n.includes("utf8")?"utf8":n.includes("Bool")?"bool":n.includes("Date")||n.includes("Timestamp")?"date":"utf8"}}function fr(e){if(!e||!e.schema||!e.schema.fields)throw new E("Invalid Arrow Table: missing schema or fields");const t=[],n={},r={},s=Number(e.numRows),o=e.schema.fields;for(const i of o){const l=String(i.name);t.push(l);const c=ar(i);r[l]=c;const u=e.getChild(l),a=[];for(let f=0;f<s;f++){const g=u.get(f);g==null?a.push(null):c==="date"&&typeof g=="number"?a.push(new Date(g)):a.push(g)}n[l]=a}return{header:t,columns:n,inferredTypes:r}}var hr=`
'use strict';
const { parentPort } = require('worker_threads');

function getNumericValue(data, nullMask, index, dtype) {
  // Check null mask
  if (nullMask) {
    const byteIndex = index >> 3;
    const bitIndex = index & 7;
    if (!((nullMask[byteIndex] >> bitIndex) & 1)) {
      return null; // null value
    }
  }
  if (dtype === 'float64' || dtype === 'int32' || dtype === 'date') {
    return data[index];
  }
  return null;
}

function getStringValue(data, nullMask, index) {
  if (nullMask) {
    const byteIndex = index >> 3;
    const bitIndex = index & 7;
    if (!((nullMask[byteIndex] >> bitIndex) & 1)) {
      return null;
    }
  }
  return data[index];
}

function getValue(colData, index) {
  if (colData.dtype === 'utf8') {
    return getStringValue(colData.data, colData.nullMaskArr, index);
  }
  return getNumericValue(colData.dataArr, colData.nullMaskArr, index, colData.dtype);
}

function computeAgg(colData, indices, aggType) {
  switch (aggType) {
    case 'sum': {
      let total = 0;
      let hasValue = false;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          total += v;
          hasValue = true;
        }
      }
      return hasValue ? total : null;
    }
    case 'mean': {
      let total = 0;
      let count = 0;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          total += v;
          count++;
        }
      }
      return count > 0 ? total / count : null;
    }
    case 'count': {
      let count = 0;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null) count++;
      }
      return count;
    }
    case 'count_distinct': {
      const seen = new Set();
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null) seen.add(v);
      }
      return seen.size;
    }
    case 'min': {
      let result = null;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          if (result === null || v < result) result = v;
        }
      }
      return result;
    }
    case 'max': {
      let result = null;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          if (result === null || v > result) result = v;
        }
      }
      return result;
    }
    case 'std': {
      let sum = 0;
      let sumSq = 0;
      let count = 0;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          sum += v;
          sumSq += v * v;
          count++;
        }
      }
      if (count < 2) return null;
      const mean = sum / count;
      const variance = sumSq / count - mean * mean;
      return Math.sqrt(variance);
    }
    case 'first': {
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null) return v;
      }
      return null;
    }
    case 'last': {
      for (let i = indices.length - 1; i >= 0; i--) {
        const v = getValue(colData, indices[i]);
        if (v !== null) return v;
      }
      return null;
    }
    default:
      return null;
  }
}

parentPort.on('message', (msg) => {
  const { columns, groups, aggSpecs, keyColumns } = msg;

  // Pre-process column data for fast access
  const processedColumns = {};
  for (const [name, colData] of Object.entries(columns)) {
    const processed = { ...colData };
    if (colData.dtype === 'float64' || colData.dtype === 'date') {
      processed.dataArr = new Float64Array(colData.data);
    } else if (colData.dtype === 'int32') {
      processed.dataArr = new Int32Array(colData.data);
    } else if (colData.dtype === 'boolean') {
      processed.dataArr = new Uint8Array(colData.data);
    }
    // utf8: data is already string[]
    if (colData.nullMask) {
      processed.nullMaskArr = new Uint8Array(colData.nullMask);
    } else {
      processed.nullMaskArr = null;
    }
    processedColumns[name] = processed;
  }

  const results = [];
  const aggEntries = Object.entries(aggSpecs);

  for (const [groupIndex, indices] of groups) {
    // Extract key values from first row
    const keyValues = [];
    const firstIndex = indices[0];
    for (const keyCol of keyColumns) {
      const colData = processedColumns[keyCol];
      if (colData) {
        keyValues.push(getValue(colData, firstIndex));
      } else {
        keyValues.push(null);
      }
    }

    // Compute aggregations
    const aggValues = {};
    for (const [outputName, spec] of aggEntries) {
      const colData = processedColumns[spec.columnName];
      if (colData) {
        aggValues[outputName] = computeAgg(colData, indices, spec.aggType);
      } else {
        aggValues[outputName] = null;
      }
    }

    results.push({ groupIndex, keyValues, aggValues });
  }

  parentPort.postMessage({ results });
});
`,gr=1e6,Ne=Math.max(1,ze.cpus().length-1),te=null;function mr(){return te===null?!0:te}function Ht(e,t){const n=t?.threshold??gr;return e<n||!mr()?!1:(t?.workerCount??Ne)>1}function pr(e,t){const n=t.length;let r=null;if(t.nullCount>0){const s=new Uint8Array(Math.ceil(n/8));for(let o=0;o<n;o++)t.get(o)!==null&&(s[o>>3]|=1<<(o&7));r=s.buffer}switch(t.dtype){case"f64":case"date":{const s=new Float64Array(n);for(let o=0;o<n;o++){const i=t.get(o);i===null?s[o]=0:i instanceof Date?s[o]=i.getTime():s[o]=i}return{name:e,dtype:t.dtype==="date"?"date":"float64",data:s.buffer,nullMask:r,length:n}}case"i32":{const s=new Int32Array(n);for(let o=0;o<n;o++){const i=t.get(o);s[o]=i===null?0:i}return{name:e,dtype:"int32",data:s.buffer,nullMask:r,length:n}}case"bool":{const s=new Uint8Array(n);for(let o=0;o<n;o++){const i=t.get(o);s[o]=i===null?0:i?1:0}return{name:e,dtype:"boolean",data:s.buffer,nullMask:r,length:n}}default:{const s=[];for(let o=0;o<n;o++){const i=t.get(o);i===null?s.push(""):typeof i=="string"?s.push(i):typeof i=="number"||typeof i=="boolean"?s.push(String(i)):s.push("")}return{name:e,dtype:"utf8",data:s,nullMask:r,length:n}}}}function dr(e,t){const n=Array.from({length:t},()=>[]);for(let r=0;r<e.length;r++){const[,s]=e[r];n[r%t].push([r,s])}return n}async function wr(e,t,n,r,s,o){const i=await import("./__vite-browser-external-9wXp6ZBx.js"),{Worker:l}=i;te=!0;const c=Math.min(o?.workerCount??Ne,e.length),u=new Set;for(const m of t)u.add(m);for(const m of Object.values(r))u.add(m.columnName);const a={};for(const m of u){const d=s.get(m);d&&(a[m]=pr(m,d))}const g=dr(e,c).map(m=>m.length===0?Promise.resolve({results:[]}):new Promise((d,w)=>{const _=new l(hr,{eval:!0}),C={columns:a,groups:m,aggSpecs:r,keyColumns:t};_.on("message",S=>{_.terminate(),d(S)}),_.on("error",S=>{_.terminate(),w(S)}),_.postMessage(C)})),h=await Promise.all(g),p=[];for(const m of h)p.push(...m.results);return p.sort((m,d)=>m.groupIndex-d.groupIndex),p}var _r=class{_df;_keys;_groupMap;constructor(e,t){this._df=e,this._keys=t;for(const r of t)if(!e.columns.includes(r))throw new P(r,e.columns);this._groupMap=new Map;const n=t.map(r=>e.col(r).column);if(t.length===1){const r=n[0];if(r instanceof q&&r.isInterned){const s=r.internedStorage,o=s.indices,i=s.dictionary.length,l=e.length,c=new Array(i);for(let u=0;u<i;u++)c[u]=[];if(r.allValid)for(let u=0;u<l;u++)c[o[u]].push(u);else{const u=r.nullMask;let a=null;for(let f=0;f<l;f++)u.getUnsafe(f)?c[o[f]].push(f):(a||(a=[]),a.push(f));a&&this._groupMap.set("\0null",a)}for(let u=0;u<i;u++){const a=c[u];a.length>0&&this._groupMap.set(`\0string${s.dictionary[u]}`,a)}return}}for(let r=0;r<e.length;r++){const s=this._serializeKey(n,r),o=this._groupMap.get(s);o?o.push(r):this._groupMap.set(s,[r])}}get keys(){return[...this._keys]}get dataframe(){return this._df}get groupMap(){return this._groupMap}nGroups(){return this._groupMap.size}agg(e,t){return(t||Ht(this._df.length))&&Ht(this._df.length,t),this._aggSync(e)}async aggAsync(e,t){const n={};for(const[p,m]of Object.entries(e))typeof m=="string"?n[p]=this._resolveShorthand(p,m):n[p]=m;if(!Ht(this._df.length,t))return this._aggSync(e);const s={};for(const[p,m]of Object.entries(n)){const d=this._aggExprToType(m);if(!d)return this._aggSync(e);s[p]={columnName:m.dependencies[0],aggType:d}}const o=new Map;for(const p of this._df.columns)o.set(p,this._df.col(p).column);const i=[...this._groupMap.entries()],l=this._keys.map(p=>this._df.col(p).column),c=await wr(i,[...this._keys],l,s,o,t),u=c.length,a=new Map,f=[];for(let p=0;p<this._keys.length;p++){const m=this._keys[p],d=c.map(w=>w.keyValues[p]??null);a.set(m,this._buildColumnLike(l[p],d)),f.push(m)}const g=Object.keys(e);for(const p of g){const m=c.map(d=>d.aggValues[p]??null);a.set(p,this._inferColumn(m,u)),f.push(p)}const h=this._df.constructor;return new h(a,f)}_aggSync(e){const t=[...this._groupMap.entries()],n=t.length,r=this._keys,s=Object.keys(e),o={};for(const[g,h]of Object.entries(e))typeof h=="string"?o[g]=this._resolveShorthand(g,h):o[g]=h;const i=new Map;for(const g of r)i.set(g,[]);const l=new Map;for(const g of s)l.set(g,[]);const c=r.map(g=>this._df.col(g).column);if(s.length===1){const g=s[0],h=o[g];if(h instanceof ve){const p=this._df.col(h.dependencies[0]).column;for(const[,_]of t){const C=_[0];for(let v=0;v<r.length;v++)i.get(r[v]).push(c[v].get(C));let S=0,y=!1;for(let v=0;v<_.length;v++){const b=p.get(_[v]);typeof b=="number"&&(S+=b,y=!0)}l.get(g).push(y?S:null)}const m=new Map,d=[];for(let _=0;_<r.length;_++){const C=r[_],S=i.get(C);m.set(C,this._buildColumnLike(c[_],S)),d.push(C)}m.set(g,N.from(l.get(g))),d.push(g);const w=this._df.constructor;return new w(m,d)}}for(const[,g]of t){const h=g[0];for(let _=0;_<r.length;_++)i.get(r[_]).push(c[_].get(h));const p=new Int32Array(g),m=new Map;for(const _ of this._df.columns)m.set(_,this._df.col(_).column.take(p));const d=this._df.constructor,w=new d(m,[...this._df.columns]);for(const _ of s){const S=o[_].evaluateFrame(w);l.get(_).push(S)}}const u=new Map,a=[];for(let g=0;g<r.length;g++){const h=r[g],p=c[g],m=i.get(h);u.set(h,this._buildColumnLike(p,m)),a.push(h)}for(const g of s){const h=l.get(g);u.set(g,this._inferColumn(h,n)),a.push(g)}const f=this._df.constructor;return new f(u,a)}_aggExprToType(e){const t=e.constructor.name;return{SumAggExpr:"sum",MeanAggExpr:"mean",CountAggExpr:"count",CountDistinctAggExpr:"count_distinct",MinAggExpr:"min",MaxAggExpr:"max",StdAggExpr:"std",FirstAggExpr:"first",LastAggExpr:"last"}[t]??null}_resolveShorthand(e,t){const n=ot(e);switch(t){case"sum":return n.sum();case"mean":return n.mean();case"count":return n.count();case"min":return n.min();case"max":return n.max();case"std":return n.std();case"first":return n.first();case"last":return n.last();default:throw new Error(`Unknown aggregation method: ${t}`)}}_buildColumnLike(e,t){switch(e.dtype){case"f64":return N.from(t);case"i32":return N.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);default:return N.from(t)}}_inferColumn(e,t){let n=null;for(const r of e)if(r!==null){n=r;break}return n===null||typeof n=="number"?N.from(e):typeof n=="string"?q.from(e):typeof n=="boolean"?U.from(e):n instanceof Date?G.from(e):N.from(e)}count(){const e=[...this._groupMap.entries()],t=this._keys.map(l=>this._df.col(l).column),n=new Map;for(const l of this._keys)n.set(l,[]);const r=[];for(const[,l]of e){const c=l[0];for(let u=0;u<this._keys.length;u++)n.get(this._keys[u]).push(t[u].get(c));r.push(l.length)}const s=new Map,o=[];for(let l=0;l<this._keys.length;l++){const c=this._keys[l],u=n.get(c);s.set(c,this._buildColumnLike(t[l],u)),o.push(c)}s.set("count",N.from(r)),o.push("count");const i=this._df.constructor;return new i(s,o)}sum(e){return this.agg({[e]:ot(e).sum()})}mean(e){return this.agg({[e]:ot(e).mean()})}min(e){return this.agg({[e]:ot(e).min()})}max(e){return this.agg({[e]:ot(e).max()})}first(){const e=this._df.columns.filter(n=>!this._keys.includes(n)),t={};for(const n of e)t[n]=ot(n).first();return this.agg(t)}last(){const e=this._df.columns.filter(n=>!this._keys.includes(n)),t={};for(const n of e)t[n]=ot(n).last();return this.agg(t)}apply(e){const t=[];for(const[,r]of this._groupMap){const s=this._buildSubFrame(r);t.push(e(s))}return t.length===0?this._df.slice(0,0):this._df.constructor.concat(...t)}groups(){const e=new Map;for(const[t,n]of this._groupMap)e.set(t,this._buildSubFrame(n));return e}_serializeKey(e,t){if(e.length===1){const r=e[0].get(t);return r===null?"\0null":r instanceof Date?`\0d${r.getTime()}`:typeof r=="number"||typeof r=="string"||typeof r=="boolean"?`\0${typeof r}${String(r)}`:`\0obj${JSON.stringify(r)}`}const n=[];for(const r of e){const s=r.get(t);s===null?n.push("\0null"):s instanceof Date?n.push(`\0d${s.getTime()}`):typeof s=="number"||typeof s=="string"||typeof s=="boolean"?n.push(`\0${typeof s}${String(s)}`):n.push(`\0obj${JSON.stringify(s)}`)}return n.join("")}_buildSubFrame(e){const t=new Int32Array(e),n=new Map,r=this._df.columns;for(const o of r)n.set(o,this._df.col(o).column.take(t));const s=this._df.constructor;return new s(n,r)}};function zt(e,t){const n=[];for(const r of e){const s=r.get(t);if(s===null)return null;s instanceof Date?n.push(`\0d${s.getTime()}`):typeof s=="number"||typeof s=="string"||typeof s=="boolean"?n.push(`\0${typeof s}${String(s)}`):n.push(`\0obj${JSON.stringify(s)}`)}return n.join("")}function It(e){return e===null?null:e instanceof Date?`\0d${e.getTime()}`:typeof e=="number"||typeof e=="string"||typeof e=="boolean"?e:`\0obj${JSON.stringify(e)}`}function yt(e,t){switch(e){case"f64":return N.from(t);case"i32":return at.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);default:return N.from(t)}}function Ae(e){if(typeof e=="string")return{leftKeys:[e],rightKeys:[e]};if(Array.isArray(e))return{leftKeys:e,rightKeys:e};const t=Array.isArray(e.left)?e.left:[e.left],n=Array.isArray(e.right)?e.right:[e.right];if(t.length!==n.length)throw new Error("Left and right key arrays must have the same length");return{leftKeys:t,rightKeys:n}}function yr(e,t,n){const r=e.length*t.length,s=new Map,o=[],i=new Map;for(const c of t.columns)e.columns.includes(c)?i.set(c,`${c}${n}`):i.set(c,c);for(const c of e.columns){const u=e.col(c).column,a=new Array(r);for(let f=0;f<e.length;f++){const g=u.get(f);for(let h=0;h<t.length;h++)a[f*t.length+h]=g}s.set(c,yt(u.dtype,a)),o.push(c)}for(const c of t.columns){const u=t.col(c).column,a=i.get(c),f=new Array(r);for(let g=0;g<e.length;g++)for(let h=0;h<t.length;h++)f[g*t.length+h]=u.get(h);s.set(a,yt(u.dtype,f)),o.push(a)}const l=e.constructor;return new l(s,o)}function ae(e,t,n,r){const{leftKeys:s,rightKeys:o}=Ae(n);for(const h of s)if(!e.columns.includes(h))throw new P(h,e.columns);for(const h of o)if(!t.columns.includes(h))throw new P(h,t.columns);const i=o.map(h=>t.col(h).column),l=s.map(h=>e.col(h).column),c=new Set;if(i.length===1){const h=i[0];for(let p=0;p<t.length;p++){const m=It(h.get(p));m!==null&&c.add(m)}}else for(let h=0;h<t.length;h++){const p=zt(i,h);p!==null&&c.add(p)}const u=[];if(l.length===1){const h=l[0];for(let p=0;p<e.length;p++){const m=It(h.get(p)),d=m!==null&&c.has(m);(r?!d:d)&&u.push(p)}}else for(let h=0;h<e.length;h++){const p=zt(l,h),m=p!==null&&c.has(p);(r?!m:m)&&u.push(h)}const a=new Map,f=[];for(const h of e.columns){const p=e.col(h).column,m=new Array(u.length);for(let d=0;d<u.length;d++)m[d]=p.get(u[d]);a.set(h,yt(p.dtype,m)),f.push(h)}const g=e.constructor;return new g(a,f)}function Sr(e,t,n,r="inner",s){const o=s?.suffix??"_right";if(r==="cross")return yr(e,t,o);if(r==="semi")return ae(e,t,n,!1);if(r==="anti")return ae(e,t,n,!0);const{leftKeys:i,rightKeys:l}=Ae(n);for(const y of i)if(!e.columns.includes(y))throw new P(y,e.columns);for(const y of l)if(!t.columns.includes(y))throw new P(y,t.columns);if(r==="left"&&i.length===1&&l.length===1){const y=e.col(i[0]).column,v=t.col(l[0]).column,b=new Map;let x=!0;for(let $=0;$<t.length;$++){const M=It(v.get($));if(M!==null){if(b.has(M)){x=!1;break}b.set(M,$)}}if(x){const $=new Map,M=[];for(const T of e.columns)$.set(T,e.col(T).column),M.push(T);const D=t.columns.filter(T=>T!==l[0]),H=new Map;for(const T of D)H.set(T,e.columns.includes(T)?`${T}${o}`:T);for(const T of D){const O=t.col(T).column,F=new Array(e.length);for(let L=0;L<e.length;L++){const B=It(y.get(L));if(B===null){F[L]=null;continue}const ft=b.get(B);F[L]=ft===void 0?null:O.get(ft)}const W=H.get(T);$.set(W,yt(O.dtype,F)),M.push(W)}const R=e.constructor;return new R($,M)}}const c=l.map(y=>t.col(y).column),u=new Map;if(c.length===1){const y=c[0];for(let v=0;v<t.length;v++){const b=It(y.get(v));if(b===null)continue;const x=u.get(b);x===void 0?u.set(b,v):typeof x=="number"?u.set(b,[x,v]):x.push(v)}}else for(let y=0;y<t.length;y++){const v=zt(c,y);if(v===null)continue;const b=u.get(v);b===void 0?u.set(v,[y]):typeof b=="number"?u.set(v,[b,y]):b.push(y)}const a=i.map(y=>e.col(y).column),f=[],g=[],h=new Uint8Array(t.length);if(a.length===1){const y=a[0];for(let v=0;v<e.length;v++){const b=It(y.get(v));if(b===null){(r==="left"||r==="outer")&&(f.push(v),g.push(null));continue}const x=u.get(b);if(x!==void 0)if(typeof x=="number")f.push(v),g.push(x),(r==="right"||r==="outer")&&(h[x]=1);else for(let $=0;$<x.length;$++){const M=x[$];f.push(v),g.push(M),(r==="right"||r==="outer")&&(h[M]=1)}else(r==="left"||r==="outer")&&(f.push(v),g.push(null))}}else for(let y=0;y<e.length;y++){const v=zt(a,y);if(v===null){(r==="left"||r==="outer")&&(f.push(y),g.push(null));continue}const b=u.get(v);if(b!==void 0)if(typeof b=="number")f.push(y),g.push(b),(r==="right"||r==="outer")&&(h[b]=1);else for(let x=0;x<b.length;x++){const $=b[x];f.push(y),g.push($),(r==="right"||r==="outer")&&(h[$]=1)}else(r==="left"||r==="outer")&&(f.push(y),g.push(null))}if(r==="right"||r==="outer")for(let y=0;y<t.length;y++)h[y]===0&&(f.push(-1),g.push(y));const p=new Map,m=[],d=f.length,w=t.columns.filter(y=>!l.includes(y)),_=e.columns.filter(y=>!i.includes(y)),C=new Map;for(const y of w)e.columns.includes(y)?C.set(y,`${y}${o}`):C.set(y,y);for(let y=0;y<i.length;y++){const v=i[y],b=l[y],x=e.col(v).column,$=t.col(b).column,M=new Array(d);for(let D=0;D<d;D++){const H=f[D],R=g[D];H>=0?M[D]=x.get(H):R!==null?M[D]=$.get(R):M[D]=null}p.set(v,yt(x.dtype,M)),m.push(v)}for(const y of _){const v=e.col(y).column,b=new Array(d);for(let x=0;x<d;x++){const $=f[x];b[x]=$>=0?v.get($):null}p.set(y,yt(v.dtype,b)),m.push(y)}for(const y of w){const v=t.col(y).column,b=C.get(y),x=new Array(d);for(let $=0;$<d;$++){const M=g[$];M!==null?x[$]=v.get(M):x[$]=null}p.set(b,yt(v.dtype,x)),m.push(b)}const S=e.constructor;return new S(p,m)}function fe(e,t){const n=[];for(const r of e){const s=r.get(t);if(s===null)return null;s instanceof Date?n.push(`\0d${s.getTime()}`):typeof s=="number"||typeof s=="string"||typeof s=="boolean"?n.push(`\0${typeof s}${String(s)}`):n.push(`\0obj${JSON.stringify(s)}`)}return n.join("")}function Cr(e,t){switch(e){case"f64":return N.from(t);case"i32":return at.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);default:return new dt(t)}}function br(e,t,n,r){if(!e.columns.includes(n))throw new P(n,e.columns);if(!t.columns.includes(n))throw new P(n,t.columns);const s=r??t.columns.filter(f=>f!==n);for(const f of s)if(!t.columns.includes(f))throw new P(f,t.columns);const o=[t.col(n).column],i=new Map;for(let f=0;f<t.length;f++){const g=fe(o,f);g!==null&&(i.has(g)||i.set(g,f))}const l=[e.col(n).column],c=new Map,u=[];for(const f of e.columns)c.set(f,e.col(f).column),u.push(f);for(const f of s){const g=t.col(f).column,h=new Array(e.length);for(let m=0;m<e.length;m++){const d=fe(l,m);if(d!==null){const w=i.get(d);h[m]=w!==void 0?g.get(w):null}else h[m]=null}const p=(e.columns.includes(f),f);c.set(p,Cr(g.dtype,h)),u.push(p)}const a=e.constructor;return new a(c,u)}function vr(e,t,n={}){if(!e.columns.includes(t))throw new P(t,e.columns);const{limit:r,name:s,drop:o=!1}=n,i=e.col(t).column,l=e.length;let c=!1,u=0;const a=new Set;for(let p=0;p<l;p++){const m=i.get(p);if(m!==null){if(Array.isArray(m))u=Math.max(u,m.length);else if(typeof m=="object"){c=!0;for(const d of Object.keys(m))a.add(d)}}}const f=new Map,g=[];for(const p of e.columns)o&&p===t||(f.set(p,e.col(p).column),g.push(p));if(c){const p=[...a],m=r!==void 0?p.slice(0,r):p;for(const d of m){const w=s?s(t,d):`${t}_${d}`,_=new Array(l);for(let C=0;C<l;C++){const S=i.get(C);if(S===null||typeof S!="object"||Array.isArray(S))_[C]=null;else{const y=S;_[C]=d in y?y[d]:null}}f.set(w,dt.from(_)),g.push(w)}}else{const p=r!==void 0?Math.min(u,r):u;for(let m=0;m<p;m++){const d=s?s(t,m):`${t}_${String(m)}`,w=new Array(l);for(let _=0;_<l;_++){const C=i.get(_);C===null||!Array.isArray(C)||m>=C.length?w[_]=null:w[_]=C[m]}f.set(d,dt.from(w)),g.push(d)}}const h=e.constructor;return new h(f,g)}function xr(e,t,n={}){const r=Array.isArray(t)?t:[t];for(const p of r)if(!e.columns.includes(p))throw new P(p,e.columns);const s=e.length,o=e.columns.filter(p=>!r.includes(p)),i=new Array(s);for(let p=0;p<s;p++){let m=0;for(const d of r){const w=e.col(d).column.get(p);Array.isArray(w)&&(m=Math.max(m,w.length))}i[p]=m}const l=i.reduce((p,m)=>p+m,0),c={};for(const p of o)c[p]=new Array(l);for(const p of r)c[p]=new Array(l);let u;n.index&&(u=new Array(l));let a=0;for(let p=0;p<s;p++){const m=i[p];if(m!==0)for(let d=0;d<m;d++){for(const w of o)c[w][a]=e.col(w).column.get(p);for(const w of r){const _=e.col(w).column.get(p);Array.isArray(_)&&d<_.length?c[w][a]=_[d]:c[w][a]=null}u&&(u[a]=d),a++}}const f=new Map,g=[];for(const p of e.columns)f.set(p,dt.from(c[p])),g.push(p);n.index&&u&&(f.set(n.index,dt.from(u)),g.push(n.index));const h=e.constructor;return new h(f,g)}function he(e,t){return t.map(n=>{const r=e[n];return r===null?"__null__":r instanceof Date?`__date__${String(r.getTime())}`:`__${typeof r}__${JSON.stringify(r)}`}).join("|")}function kr(e){if(e.length===0)return[[]];let t=[[]];for(const n of e){const r=[];for(const s of t)for(const o of n)r.push([...s,o]);t=r}return t}function Nr(e,t,n={}){for(const u of Object.keys(t))if(!e.columns.includes(u))throw new P(u,e.columns);const r=n.expand??[];for(const u of r)if(!e.columns.includes(u))throw new P(u,e.columns);const s=e.toArray();let o=s;if(r.length>0){const u=r.map(g=>{const h=new Set,p=[];for(const m of s){const d=m[g],w=d instanceof Date?`d:${String(d.getTime())}`:JSON.stringify(d);h.has(w)||(h.add(w),p.push(d??null))}return p}),a=kr(u),f=new Map;for(const g of s)f.set(he(g,r),g);o=a.map(g=>{const h={};for(let d=0;d<r.length;d++)h[r[d]]=g[d]??null;const p=f.get(he(h,r));if(p)return p;const m={};for(const d of e.columns)m[d]=h[d]??null;return m})}const i={};for(const u of e.columns)i[u]=o.map(a=>a[u]??null);const l={};for(const[u,a]of Object.entries(t))l[u]=typeof a=="function"?a(i):a;const c=o.map(u=>{const a={...u};for(const[f,g]of Object.entries(l))(a[f]??null)===null&&(a[f]=g);return a});return e.constructor.fromRows(c)}function Ar(e,t){switch(t){case"first":return e.length>0?e[0]:null;case"last":return e.length>0?e[e.length-1]:null;case"count":return e.length;case"sum":{let n=0;for(const r of e)typeof r=="number"&&(n+=r);return n}case"mean":{let n=0,r=0;for(const s of e)typeof s=="number"&&(n+=s,r++);return r>0?n/r:null}}}function ge(e,t,n){const r=[];for(const s of n){const o=e.col(s).get(t);o===null?r.push("\0null"):o instanceof Date?r.push(`\0d${o.getTime()}`):typeof o=="number"||typeof o=="string"||typeof o=="boolean"?r.push(`\0${typeof o}${String(o)}`):r.push(`\0obj${JSON.stringify(o)}`)}return r.join("")}function me(e,t){switch(e){case"f64":return N.from(t);case"i32":return at.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);default:return N.from(t)}}function $r(e,t){const n=Array.isArray(t.index)?t.index:[t.index],r=t.columns,s=t.values,o=t.aggFunc??"first";for(const w of[...n,r,s])if(!e.columns.includes(w))throw new P(w,e.columns);const i=[],l=new Map;for(let w=0;w<e.length;w++){const _=ge(e,w,n);l.has(_)||(i.push(_),l.set(_,[])),l.get(_).push(w)}const c=[],u=new Set,a=e.col(r);for(let w=0;w<e.length;w++){const _=a.get(w);let C;_===null?C="null":typeof _=="string"||typeof _=="number"||typeof _=="boolean"?C=String(_):_ instanceof Date?C=_.toISOString():C=JSON.stringify(_),u.has(C)||(u.add(C),c.push(C))}const f=new Map;for(let w=0;w<e.length;w++){const _=ge(e,w,n),C=a.get(w);let S;C===null?S="null":typeof C=="string"||typeof C=="number"||typeof C=="boolean"?S=String(C):C instanceof Date?S=C.toISOString():S=JSON.stringify(C);const y=_+""+S;f.has(y)||f.set(y,[]),f.get(y).push(e.col(s).get(w))}const g=e.col(s).column.dtype,h=o==="count"?"f64":g,p=new Map,m=[];for(const w of n){const _=[],C=e.col(w);for(const S of i){const y=l.get(S)[0];_.push(C.get(y))}p.set(w,me(C.column.dtype,_)),m.push(w)}for(const w of c){const _=[];for(const C of i){const S=C+""+w,y=f.get(S);y&&y.length>0?_.push(Ar(y,o)):_.push(null)}p.set(w,me(h,_)),m.push(w)}const d=e.constructor;return new d(p,m)}function pe(e,t){switch(e){case"f64":return N.from(t);case"i32":return at.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);default:return N.from(t)}}function Mr(e){for(const t of e)if(t!=null){if(typeof t=="number")return Number.isInteger(t),"f64";if(typeof t=="string")return"utf8";if(typeof t=="boolean")return"bool";if(t instanceof Date)return"date"}return"f64"}function Ir(e,t){const n=Array.isArray(t.idVars)?t.idVars:[t.idVars],r=t.varName??"variable",s=t.valueName??"value";for(const m of n)if(!e.columns.includes(m))throw new P(m,e.columns);let o;if(t.valueVars){o=Array.isArray(t.valueVars)?t.valueVars:[t.valueVars];for(const m of o)if(!e.columns.includes(m))throw new P(m,e.columns)}else{const m=new Set(n);o=e.columns.filter(d=>!m.has(d))}const i=e.length,l=o.length,c=i*l,u=new Map,a=[];for(const m of n){const d=e.col(m),w=new Array(c);for(let _=0;_<i;_++){const C=d.get(_);for(let S=0;S<l;S++)w[_*l+S]=C}u.set(m,pe(d.column.dtype,w)),a.push(m)}const f=new Array(c);for(let m=0;m<i;m++)for(let d=0;d<l;d++)f[m*l+d]=o[d];u.set(r,q.from(f)),a.push(r);const g=new Array(c);for(let m=0;m<i;m++)for(let d=0;d<l;d++)g[m*l+d]=e.col(o[d]).get(m);const h=Mr(g);u.set(s,pe(h,g)),a.push(s);const p=e.constructor;return new p(u,a)}function $e(e){for(const t of e)if(t!=null){if(typeof t=="number")return"f64";if(typeof t=="string")return"utf8";if(typeof t=="boolean")return"bool";if(t instanceof Date)return"date"}return"f64"}function Me(e,t){switch(e){case"f64":return N.from(t);case"i32":return at.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);default:return N.from(t)}}function Er(e){return e==null?"null":e instanceof Date?e.toISOString():typeof e=="number"||typeof e=="string"||typeof e=="boolean"?String(e):JSON.stringify(e)}function Dr(e,t){const n=e.constructor,r=e.length,s=e.columns;if(s.length===0||r===0)return new n(new Map,[]);let o,i;if(t){const u=e.col(t);o=[];for(let a=0;a<r;a++)o.push(Er(u.get(a)));i=s.filter(a=>a!==t)}else{o=[];for(let u=0;u<r;u++)o.push(String(u));i=s}const l=new Map,c=["column"];l.set("column",q.from(i));for(let u=0;u<r;u++){const a=o[u],f=[];for(const h of i)f.push(e.col(h).get(u));const g=$e(f);l.set(a,Me(g,f)),c.push(a)}return new n(l,c)}function Jt(...e){if(e.length===0)throw new pt("concat requires at least one DataFrame");const t=e[0],n=t.constructor;if(e.length===1)return t;const r=[],s=new Set;for(const c of e)for(const u of c.columns)s.has(u)||(s.add(u),r.push(u));const o=new Map;for(const c of e){const u=c.dtypes;for(const a of c.columns){const f=o.get(a),g=u[a];if(f!==void 0&&f!==g)throw new pt(`Column '${a}' has incompatible types: ${f} vs ${g}`);o.set(a,g)}}const i=e.reduce((c,u)=>c+u.length,0),l=new Map;for(const c of r){const u=new Array(i);let a=0;for(const g of e){const h=g.length;if(g.columns.includes(c)){const p=g.col(c);for(let m=0;m<h;m++)u[a+m]=p.get(m)}else for(let p=0;p<h;p++)u[a+p]=null;a+=h}const f=o.get(c)??$e(u);l.set(c,Me(f,u))}return new n(l,r)}function Et(e,t,n){const r=[];for(const s of n){const o=e.col(s).get(t);o===null?r.push("\0null"):o instanceof Date?r.push(`\0d${o.getTime()}`):typeof o=="number"||typeof o=="string"||typeof o=="boolean"?r.push(`\0${typeof o}${String(o)}`):r.push(`\0obj${JSON.stringify(o)}`)}return r.join("")}function re(e,t){const n=e.columns,r=t.columns;if(n.length!==r.length)throw new pt(`Schema mismatch: left has ${n.length} columns, right has ${r.length} columns`);const s=e.dtypes,o=t.dtypes;for(const i of n){if(!(i in o))throw new pt(`Schema mismatch: column '${i}' not found in right DataFrame`);if(s[i]!==o[i])throw new pt(`Schema mismatch: column '${i}' has dtype '${s[i]}' in left but '${o[i]}' in right`)}}function Ie(e,t){switch(e){case"f64":return N.from(t);case"i32":return at.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);default:return N.from(t)}}function Ee(e,t){const n=e.columns,r=e.dtypes,s=new Map;for(const i of n){const l=e.col(i),c=[];for(const u of t)c.push(l.get(u));s.set(i,Ie(r[i],c))}const o=e.constructor;return new o(s,[...n])}function Or(e,t){re(e,t);const n=e.columns,r=e.dtypes,s=new Set,o=new Map;for(const c of n)o.set(c,[]);for(let c=0;c<e.length;c++){const u=Et(e,c,n);if(!s.has(u)){s.add(u);for(const a of n)o.get(a).push(e.col(a).get(c))}}for(let c=0;c<t.length;c++){const u=Et(t,c,n);if(!s.has(u)){s.add(u);for(const a of n)o.get(a).push(t.col(a).get(c))}}const i=new Map;for(const c of n)i.set(c,Ie(r[c],o.get(c)));const l=e.constructor;return new l(i,[...n])}function Rr(e,t){re(e,t);const n=e.columns,r=new Set;for(let i=0;i<t.length;i++)r.add(Et(t,i,n));const s=new Set,o=[];for(let i=0;i<e.length;i++){const l=Et(e,i,n);r.has(l)&&!s.has(l)&&(s.add(l),o.push(i))}return Ee(e,o)}function Tr(e,t){re(e,t);const n=e.columns,r=new Set;for(let i=0;i<t.length;i++)r.add(Et(t,i,n));const s=new Set,o=[];for(let i=0;i<e.length;i++){const l=Et(e,i,n);!r.has(l)&&!s.has(l)&&(s.add(l),o.push(i))}return Ee(e,o)}function de(e){return`"${e.replace(/"/g,'""')}"`}function Fr(e){return e==null?"NULL":typeof e=="boolean"?e?"TRUE":"FALSE":typeof e=="number"?isFinite(e)?String(e):"NULL":typeof e=="bigint"?String(e):e instanceof Date?`'${e.toISOString()}'`:typeof e=="string"?`'${e.replace(/'/g,"''")}'`:`'${JSON.stringify(e).replace(/'/g,"''")}'`}function Lr(e,t,n,r={}){const s=r.batchSize??1e3;if(t.length===0||n.length===0)return"";const o=t.map(de).join(", "),i=[];for(let l=0;l<n.length;l+=s){const u=n.slice(l,l+s).map(a=>`(${a.map(Fr).join(", ")})`);i.push(`INSERT INTO ${de(e)} (${o}) VALUES
${u.join(`,
`)};`)}return i.join(`

`)}var Vr=0;function Ur(){return{type:"scan",id:Vr++}}function st(e,t=0){const n="  ".repeat(t);switch(e.type){case"scan":return e.projection?`${n}SCAN [id=${e.id}, cols=${e.projection.join(", ")}]`:`${n}SCAN [id=${e.id}]`;case"filter":return`${n}FILTER [${e.predicate.toString()}]
${st(e.input,t+1)}`;case"select":return`${n}SELECT [${e.columns.join(", ")}]
${st(e.input,t+1)}`;case"project":{const r=e.exprs.map(s=>s.toString()).join(", ");return`${n}PROJECT [${r}]
${st(e.input,t+1)}`}case"groupby":{const r=e.aggs.map(s=>s.toString()).join(", ");return`${n}GROUPBY [keys: ${e.keys.join(", ")}; aggs: ${r}]
${st(e.input,t+1)}`}case"join":return`${n}JOIN [${e.how}]
${n}  left:
${st(e.left,t+2)}
${n}  right:
${st(e.right,t+2)}`;case"sort":return`${n}SORT [${e.by} ${e.descending?"DESC":"ASC"}]
${st(e.input,t+1)}`;case"limit":return`${n}LIMIT [${e.n}]
${st(e.input,t+1)}`;case"distinct":return`${n}DISTINCT${e.subset?` [${e.subset.join(", ")}]`:""}
${st(e.input,t+1)}`}}function jr(e,t){function n(r){switch(r.type){case"scan":return r.projection?t.select(...r.projection):t;case"filter":return n(r.input).filter(r.predicate);case"select":return n(r.input).select(...r.columns);case"project":{const s=n(r.input);let o=s;for(const i of r.exprs){const l=i.evaluate(s);o=o.withColumn(l.name,i)}return o}case"groupby":{const o=n(r.input).groupBy(...r.keys),i={};for(const l of r.aggs){const c=l,a=c.dependencies[0]??"value";i[a]=c}return o.agg(i)}case"sort":return n(r.input).sortBy(r.by,r.descending?"desc":"asc");case"limit":return n(r.input).head(r.n);case"distinct":return n(r.input).unique(r.subset);case"join":{const s=n(r.left),o=n(r.right);return s.join(o,r.on,r.how)}}}return n(e)}function Br(e){const t=lt(e),n=ct(t);return rt(n)}function lt(e){switch(e.type){case"scan":return e;case"filter":{const n={type:"filter",input:lt(e.input),predicate:e.predicate};return qt(n)}case"select":return{type:"select",input:lt(e.input),columns:e.columns};case"project":return{type:"project",input:lt(e.input),exprs:e.exprs};case"groupby":return{type:"groupby",input:lt(e.input),keys:e.keys,aggs:e.aggs};case"sort":return{type:"sort",input:lt(e.input),by:e.by,descending:e.descending};case"limit":return{type:"limit",input:lt(e.input),n:e.n};case"distinct":return{type:"distinct",input:lt(e.input),subset:e.subset};case"join":return{type:"join",left:lt(e.left),right:lt(e.right),on:e.on,how:e.how}}}function qt(e){const t=e.input;switch(t.type){case"select":return{type:"select",input:qt({type:"filter",input:t.input,predicate:e.predicate}),columns:t.columns};case"project":return{type:"project",input:qt({type:"filter",input:t.input,predicate:e.predicate}),exprs:t.exprs};case"sort":return{type:"sort",input:qt({type:"filter",input:t.input,predicate:e.predicate}),by:t.by,descending:t.descending};case"groupby":return e;default:return e}}function ct(e){switch(e.type){case"scan":return e;case"filter":{const t=ct(e.input);return t.type==="filter"?{type:"filter",input:t.input,predicate:t.predicate.and(e.predicate)}:{type:"filter",input:t,predicate:e.predicate}}case"select":return{type:"select",input:ct(e.input),columns:e.columns};case"project":return{type:"project",input:ct(e.input),exprs:e.exprs};case"groupby":return{type:"groupby",input:ct(e.input),keys:e.keys,aggs:e.aggs};case"sort":return{type:"sort",input:ct(e.input),by:e.by,descending:e.descending};case"limit":return{type:"limit",input:ct(e.input),n:e.n};case"distinct":return{type:"distinct",input:ct(e.input),subset:e.subset};case"join":return{type:"join",left:ct(e.left),right:ct(e.right),on:e.on,how:e.how}}}function rt(e,t){switch(e.type){case"scan":{if(t&&t.size>0){const n=[...t].sort();return{type:"scan",id:e.id,projection:n}}return e}case"select":{const n=new Set(e.columns);return{type:"select",input:rt(e.input,n),columns:e.columns}}case"filter":{const n=new Set(t);for(const r of e.predicate.dependencies)n.add(r);return{type:"filter",input:rt(e.input,n),predicate:e.predicate}}case"project":{const n=new Set;for(const r of e.exprs)for(const s of r.dependencies)n.add(s);return{type:"project",input:rt(e.input,n),exprs:e.exprs}}case"groupby":{const n=new Set(e.keys);for(const r of e.aggs)for(const s of r.dependencies)n.add(s);return{type:"groupby",input:rt(e.input,n),keys:e.keys,aggs:e.aggs}}case"sort":{const n=new Set(t);return n.add(e.by),{type:"sort",input:rt(e.input,n),by:e.by,descending:e.descending}}case"limit":return{type:"limit",input:rt(e.input,t),n:e.n};case"distinct":{if(e.subset){const n=new Set(t);for(const r of e.subset)n.add(r);return{type:"distinct",input:rt(e.input,n),subset:e.subset}}return{type:"distinct",input:rt(e.input,t),subset:e.subset}}case"join":{const n=typeof e.on=="string"?[e.on]:e.on,r=new Set(t),s=new Set(t);for(const o of n)r.add(o),s.add(o);return{type:"join",left:rt(e.left,r),right:rt(e.right,s),on:e.on,how:e.how}}}}var Pr=class{_source;_plan;_keys;constructor(e,t,n){this._source=e,this._plan=t,this._keys=n}agg(...e){return new De(this._source,{type:"groupby",input:this._plan,keys:[...this._keys],aggs:e})}},De=class _t{_source;_plan;constructor(t,n){this._source=t,this._plan=n}filter(t){return new _t(this._source,{type:"filter",input:this._plan,predicate:t})}select(...t){return new _t(this._source,{type:"select",input:this._plan,columns:t})}project(...t){return new _t(this._source,{type:"project",input:this._plan,exprs:t})}sort(t,n=!1){return new _t(this._source,{type:"sort",input:this._plan,by:t,descending:n})}sortBy(t,n=!1){return this.sort(t,n)}limit(t){return new _t(this._source,{type:"limit",input:this._plan,n:t})}head(t){return this.limit(t)}distinct(t){return new _t(this._source,{type:"distinct",input:this._plan,subset:t})}unique(t){return this.distinct(t)}groupBy(...t){return new Pr(this._source,this._plan,t)}explain(){const t=st(this._plan),n=Br(this._plan),r=st(n);return`ORIGINAL:
${t}

OPTIMIZED:
${r}`}collect(){return Promise.resolve(jr(this._plan,this._source))}async sink(t){const n=await this.collect(),r=t.toLowerCase();if(r.endsWith(".csv")||r.endsWith(".tsv"))await n.toCSV(t);else if(r.endsWith(".ndjson")||r.endsWith(".jsonl"))await n.toNDJSON(t);else throw new Error(`Unsupported sink format for '${t}'. Supported: .csv, .tsv, .ndjson, .jsonl`)}};function Yt(e){return new De(e,Ur())}var qr=new Set(["SELECT","FROM","WHERE","ORDER","BY","LIMIT","GROUP","HAVING","AND","OR","IN","LIKE","IS","NOT","NULL","ASC","DESC","AS"]);function Wr(e){const t=[];let n=0;for(;n<e.length;){if(/\s/.test(e[n])){n++;continue}const r=n;if(e[n]==="'"){n++;let s="";for(;n<e.length&&e[n]!=="'";)e[n]==="'"&&e[n+1]==="'"?(s+="'",n+=2):(s+=e[n],n++);if(n>=e.length)throw new ut(`Unterminated string literal at position ${r}`);n++,t.push({type:"STRING",value:s,position:r});continue}if(/\d/.test(e[n])||e[n]==="-"&&n+1<e.length&&/\d/.test(e[n+1])){let s="";for(e[n]==="-"&&(s+="-",n++);n<e.length&&/[\d.]/.test(e[n]);)s+=e[n],n++;t.push({type:"NUMBER",value:s,position:r});continue}if(e[n]==="*"){t.push({type:"STAR",value:"*",position:r}),n++;continue}if(e[n]===","){t.push({type:"COMMA",value:",",position:r}),n++;continue}if(e[n]==="("){t.push({type:"LPAREN",value:"(",position:r}),n++;continue}if(e[n]===")"){t.push({type:"RPAREN",value:")",position:r}),n++;continue}if(e[n]==="!"&&e[n+1]==="="){t.push({type:"NEQ",value:"!=",position:r}),n+=2;continue}if(e[n]==="<"&&e[n+1]===">"){t.push({type:"NEQ",value:"<>",position:r}),n+=2;continue}if(e[n]===">"&&e[n+1]==="="){t.push({type:"GTE",value:">=",position:r}),n+=2;continue}if(e[n]==="<"&&e[n+1]==="="){t.push({type:"LTE",value:"<=",position:r}),n+=2;continue}if(e[n]===">"){t.push({type:"GT",value:">",position:r}),n++;continue}if(e[n]==="<"){t.push({type:"LT",value:"<",position:r}),n++;continue}if(e[n]==="="){t.push({type:"EQ",value:"=",position:r}),n++;continue}if(/[a-zA-Z_]/.test(e[n])){let s="";for(;n<e.length&&/[a-zA-Z0-9_]/.test(e[n]);)s+=e[n],n++;const o=s.toUpperCase();qr.has(o)?t.push({type:o,value:o,position:r}):t.push({type:"IDENTIFIER",value:s,position:r});continue}throw new ut(`Unexpected character '${e[n]}' at position ${r}`)}return t.push({type:"EOF",value:"",position:n}),t}var zr=class{tokens;pos;_selectItems=[];constructor(e){this.tokens=e,this.pos=0}current(){return this.tokens[this.pos]}peek(){return this.tokens[this.pos]}advance(){const e=this.tokens[this.pos];return this.pos++,e}expect(e){const t=this.current();if(t.type!==e)throw new ut(`Expected ${e} but got '${t.value}' at position ${t.position}`);return this.advance()}match(e){return this.current().type===e?(this.advance(),!0):!1}parse(){this.expect("SELECT");let e=!1;const t=[];if(this.current().type==="STAR")e=!0,this.advance();else for(t.push(this.parseSelectItem());this.match("COMMA");)t.push(this.parseSelectItem());this._selectItems=t,this.expect("FROM");const n=this.expect("IDENTIFIER");if(n.value!=="this")throw new ut(`FROM clause must reference 'this', got '${n.value}' at position ${n.position}`);let r;this.current().type==="WHERE"&&(this.advance(),r=this.parseOrExpr());const s=[];if(this.current().type==="GROUP")for(this.advance(),this.expect("BY"),s.push(this.expect("IDENTIFIER").value);this.match("COMMA");)s.push(this.expect("IDENTIFIER").value);let o;this.current().type==="HAVING"&&(this.advance(),o=this.parseOrExpr());const i=[];if(this.current().type==="ORDER")for(this.advance(),this.expect("BY"),i.push(this.parseOrderByItem());this.match("COMMA");)i.push(this.parseOrderByItem());let l;if(this.current().type==="LIMIT"){this.advance();const c=this.expect("NUMBER");l=parseInt(c.value,10)}if(this.current().type!=="EOF")throw new ut(`Unexpected token '${this.current().value}' at position ${this.current().position}`);return{selectItems:t,selectAll:e,whereExpr:r,groupByColumns:s,havingExpr:o,orderByItems:i,limit:l}}parseSelectItem(){const e=this.current(),t=e.value.toUpperCase();if(e.type==="IDENTIFIER"&&["SUM","AVG","COUNT","MIN","MAX"].includes(t)&&this.tokens[this.pos+1]?.type==="LPAREN"){const s=t;this.advance(),this.advance();let o;this.current().type==="STAR"?(o="*",this.advance()):o=this.expect("IDENTIFIER").value,this.expect("RPAREN");let i;return this.current().type==="AS"&&(this.advance(),i=this.expect("IDENTIFIER").value),{column:o,alias:i,aggregate:s}}const n=this.expect("IDENTIFIER").value;let r;return this.current().type==="AS"&&(this.advance(),r=this.expect("IDENTIFIER").value),{column:n,alias:r,aggregate:void 0}}parseOrderByItem(){const e=this.expect("IDENTIFIER").value;let t="asc";return this.current().type==="ASC"?(this.advance(),t="asc"):this.current().type==="DESC"&&(this.advance(),t="desc"),{column:e,direction:t}}parseOrExpr(){let e=this.parseAndExpr();for(;this.current().type==="OR";){this.advance();const t=this.parseAndExpr();e=e.or(t)}return e}parseAndExpr(){let e=this.parseComparison();for(;this.current().type==="AND";){this.advance();const t=this.parseComparison();e=e.and(t)}return e}parseComparison(){if(this.current().type==="LPAREN"){this.advance();const i=this.parseOrExpr();return this.expect("RPAREN"),i}if(this.current().type==="NOT")return this.advance(),this.parseComparison().not();const e=this.current(),t=e.value.toUpperCase();if(e.type==="IDENTIFIER"&&["SUM","AVG","COUNT","MIN","MAX"].includes(t)&&this.tokens[this.pos+1]?.type==="LPAREN")return this.parseAggregateComparison();const n=this.expect("IDENTIFIER").value,r=ot(n);if(this.current().type==="IS")return this.advance(),this.current().type==="NOT"?(this.advance(),this.expect("NULL"),new we(n,!0)):(this.expect("NULL"),new we(n,!1));if(this.current().type==="NOT"){if(this.advance(),this.current().type==="IN"){this.advance();const i=this.parseValueList();let l=r.eq(Y(i[0]));for(let c=1;c<i.length;c++)l=l.or(r.eq(Y(i[c])));return l.not()}if(this.current().type==="LIKE"){this.advance();const i=this.expect("STRING").value;return this.buildLikeExpr(n,i).not()}throw new ut(`Expected IN or LIKE after NOT at position ${this.current().position}`)}if(this.current().type==="IN"){this.advance();const i=this.parseValueList();let l=r.eq(Y(i[0]));for(let c=1;c<i.length;c++)l=l.or(r.eq(Y(i[c])));return l}if(this.current().type==="LIKE"){this.advance();const i=this.expect("STRING").value;return this.buildLikeExpr(n,i)}const s=this.current();this.advance();const o=this.parseLiteralValue();switch(s.type){case"EQ":return r.eq(Y(o));case"NEQ":return r.neq(Y(o));case"GT":return r.gt(Y(o));case"GTE":return r.gte(Y(o));case"LT":return r.lt(Y(o));case"LTE":return r.lte(Y(o));default:throw new ut(`Expected comparison operator at position ${s.position}, got '${s.value}'`)}}parseAggregateComparison(){const e=this.advance().value.toUpperCase();this.expect("LPAREN");let t;this.current().type==="STAR"?(t="*",this.advance()):t=this.expect("IDENTIFIER").value,this.expect("RPAREN");const r=this._selectItems.find(l=>l.aggregate===e&&l.column===t)?.alias??(t==="*"?`${e.toLowerCase()}`:`${e.toLowerCase()}_${t}`),s=ot(r),o=this.current();this.advance();const i=this.parseLiteralValue();switch(o.type){case"EQ":return s.eq(Y(i));case"NEQ":return s.neq(Y(i));case"GT":return s.gt(Y(i));case"GTE":return s.gte(Y(i));case"LT":return s.lt(Y(i));case"LTE":return s.lte(Y(i));default:throw new ut(`Expected comparison operator at position ${o.position}, got '${o.value}'`)}}parseLiteralValue(){const e=this.current();if(e.type==="NUMBER")return this.advance(),parseFloat(e.value);if(e.type==="STRING")return this.advance(),e.value;if(e.type==="NULL")return this.advance(),null;if(e.type==="IDENTIFIER"){const t=e.value.toUpperCase();if(t==="TRUE")return this.advance(),!0;if(t==="FALSE")return this.advance(),!1}throw new ut(`Expected literal value at position ${e.position}, got '${e.value}'`)}parseValueList(){this.expect("LPAREN");const e=[];for(e.push(this.parseLiteralValue());this.match("COMMA");)e.push(this.parseLiteralValue());return this.expect("RPAREN"),e}buildLikeExpr(e,t){const n="^"+t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/%/g,".*").replace(/_/g,".")+"$";return new Kr(e,n)}},Kr=class extends k{_columnName;_regexStr;constructor(e,t){super(),this._columnName=e,this._regexStr=t}get dependencies(){return[this._columnName]}evaluate(e){const t=e.col(this._columnName),n=new RegExp(this._regexStr),r=[];for(let s=0;s<t.length;s++){const o=t.column.get(s);o===null?r.push(null):r.push(n.test(typeof o=="string"?o:`${o}`))}return new A("like_result",U.from(r))}toString(){return`LIKE(${this._columnName}, ${this._regexStr})`}},we=class extends k{_columnName;_invert;constructor(e,t){super(),this._columnName=e,this._invert=t}get dependencies(){return[this._columnName]}evaluate(e){const t=e.col(this._columnName);return this._invert?t.isNotNull():t.isNull()}toString(){return`${this._columnName} IS ${this._invert?"NOT ":""}NULL`}};function Hr(e,t){const n={};for(const r of e){if(t.includes(r.column)||r.aggregate===void 0)continue;const s=r.alias??(r.column==="*"?`${r.aggregate.toLowerCase()}`:`${r.aggregate.toLowerCase()}_${r.column}`),o=r.column==="*"?t[0]:r.column,i=ot(o);switch(r.aggregate){case"SUM":n[s]=i.sum();break;case"AVG":n[s]=i.mean();break;case"COUNT":n[s]=i.count();break;case"MIN":n[s]=i.min();break;case"MAX":n[s]=i.max();break}}return n}function Jr(e,t){const n=Wr(t),s=new zr(n).parse();let o=e;if(s.whereExpr!==void 0&&(o=o.filter(s.whereExpr)),s.groupByColumns.length>0){const i=Hr(s.selectItems,s.groupByColumns);if(o=o.groupBy(...s.groupByColumns).agg(i),s.havingExpr!==void 0&&(o=o.filter(s.havingExpr)),!s.selectAll){const c=[];for(const u of s.selectItems)if(u.aggregate!==void 0){const a=u.alias??(u.column==="*"?`${u.aggregate.toLowerCase()}`:`${u.aggregate.toLowerCase()}_${u.column}`);c.push(a)}else c.push(u.alias??u.column);o=o.select(...c)}}else if(!s.selectAll){const i=s.selectItems.map(c=>c.column);o=o.select(...i);const l={};for(const c of s.selectItems)c.alias!==void 0&&(l[c.column]=c.alias);Object.keys(l).length>0&&(o=o.rename(l))}if(s.orderByItems.length>0){const i=s.orderByItems.map(c=>c.column),l=s.orderByItems.map(c=>c.direction);o=o.sortBy(i,l)}return s.limit!==void 0&&(o=o.head(s.limit)),o}var Dt=class I{static _readers=new Map;static _writers=new Map;_columns;_columnOrder;constructor(t,n){this._columns=t,this._columnOrder=n;for(const r of t.values())r.addRef()}get shape(){return[this.length,this._columnOrder.length]}get columns(){return[...this._columnOrder]}get dtypes(){const t={};for(const n of this._columnOrder)t[n]=this._columns.get(n).dtype;return t}get length(){return this._columnOrder.length===0?0:this._columns.get(this._columnOrder[0]).length}col(t){const n=this._columns.get(t);if(!n)throw new P(t,this._columnOrder);return new A(t,n)}row(t){if(t<0||t>=this.length)throw new V("INVALID_OPERATION",`Row index ${t} out of bounds for DataFrame with ${this.length} rows`);const n={};for(const r of this._columnOrder)n[r]=this._columns.get(r).get(t);return n}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.row(t)}rows(){return this[Symbol.iterator]()}toArray(){const t=[];for(let n=0;n<this.length;n++)t.push(this.row(n));return t}clone(){const t=new Map;for(const[n,r]of this._columns)t.set(n,r.clone());return new I(t,[...this._columnOrder])}reify(){return this.clone()}lazy(){return Yt(this)}select(...t){for(const r of t)if(!this._columns.has(r))throw new P(r,this._columnOrder);const n=new Map;for(const r of t)n.set(r,this._columns.get(r));return new I(n,[...t])}drop(...t){for(const o of t)if(!this._columns.has(o))throw new P(o,this._columnOrder);const n=new Set(t),r=new Map,s=[];for(const o of this._columnOrder)n.has(o)||(r.set(o,this._columns.get(o)),s.push(o));return new I(r,s)}head(t=5){return this.slice(0,Math.min(t,this.length))}tail(t=5){const n=Math.max(0,this.length-t);return this.slice(n,this.length)}slice(t,n){const r=n===void 0?this.length:Math.min(n,this.length),s=Math.max(0,t),o=new Map;for(const i of this._columnOrder)o.set(i,this._columns.get(i).slice(s,r));return new I(o,[...this._columnOrder])}withColumn(t,n){if(n instanceof k){const c=n.evaluate(this),u=new Map(this._columns);u.set(t,c.column);const a=this._columnOrder.includes(t)?[...this._columnOrder]:[...this._columnOrder,t];return new I(u,a)}let r;if(typeof n=="function"){const c=n;r=[];for(let u=0;u<this.length;u++)r.push(c(this.row(u)))}else if(r=n,r.length!==this.length)throw new pt(`Column '${t}' has length ${r.length}, expected ${this.length}`);const s=ye(r),o=mt(s,r),i=new Map(this._columns);i.set(t,o);const l=this._columnOrder.includes(t)?[...this._columnOrder]:[...this._columnOrder,t];return new I(i,l)}assign(t){if(t.length!==this.length&&t.columns.length>0&&this._columnOrder.length>0)throw new pt(`Cannot assign DataFrame with ${t.length} rows to DataFrame with ${this.length} rows`);const n=new Map(this._columns),r=[...this._columnOrder];for(const s of t.columns)n.set(s,t._columns.get(s)),this._columnOrder.includes(s)||r.push(s);return new I(n,r)}derive(t){let n=this;for(const[r,s]of Object.entries(t)){if(this.length===0){n=n.withColumn(r,[]);continue}const o=s(this.row(0));if(o instanceof k){n=n.withColumn(r,o.evaluate(this).toArray());continue}const i=[o];for(let l=1;l<this.length;l++)i.push(s(this.row(l)));n=n.withColumn(r,i)}return n}lookup(t,n,r){return br(this,t,n,r)}spread(t,n){return vr(this,t,n)}unroll(t,n){return xr(this,t,n)}impute(t,n){return Nr(this,t,n)}relocate(t,n){const{before:r,after:s}=n;if(r!==void 0&&s!==void 0)throw new V("INVALID_OPERATION",'Cannot specify both "before" and "after" in relocate');if(r===void 0&&s===void 0)throw new V("INVALID_OPERATION",'Must specify either "before" or "after" in relocate');for(const a of t)if(!this._columns.has(a))throw new P(a,this._columnOrder);const o=r??s;if(!this._columns.has(o))throw new P(o,this._columnOrder);const i=this._columnOrder.filter(a=>!t.includes(a)),l=i.indexOf(o),c=r!==void 0?l:l+1,u=[...i.slice(0,c),...t,...i.slice(c)];return new I(new Map(this._columns),u)}rename(t){for(const s of Object.keys(t))if(!this._columns.has(s))throw new P(s,this._columnOrder);const n=new Map,r=[];for(const s of this._columnOrder){const o=t[s]??s;n.set(o,this._columns.get(s)),r.push(o)}return new I(n,r)}filter(t){if(t instanceof k){const l=t;if(l._op!==void 0&&l._left instanceof Wt&&l._right instanceof tt){const g=l._left.dependencies[0],h=l._right._value,p=this._columns.get(g);if(p){if(p instanceof q&&p.isInterned&&typeof h=="string"&&(l._op==="eq"||l._op==="neq")){const _=p.internedStorage,C=_.dictionary.indexOf(h),S=l._op==="eq";if(S&&C===-1)return this.slice(0,0);const y=_.indices,v=this.length;if(p.allValid){let b=0;if(S)for(let M=0;M<v;M++)y[M]===C&&b++;else{if(C===-1)return this;for(let M=0;M<v;M++)y[M]!==C&&b++}if(b===v)return this;if(b===0)return this.slice(0,0);const x=new Int32Array(b);let $=0;if(S)for(let M=0;M<v;M++)y[M]===C&&(x[$++]=M);else for(let M=0;M<v;M++)y[M]!==C&&(x[$++]=M);return this._takeByInt32Indices(x)}else{const b=p.nullMask;let x=0;if(S)for(let D=0;D<v;D++)b.getUnsafe(D)&&y[D]===C&&x++;else for(let D=0;D<v;D++)b.getUnsafe(D)&&y[D]!==C&&x++;if(x===v)return this;if(x===0)return this.slice(0,0);const $=new Int32Array(x);let M=0;if(S)for(let D=0;D<v;D++)b.getUnsafe(D)&&y[D]===C&&($[M++]=D);else for(let D=0;D<v;D++)b.getUnsafe(D)&&y[D]!==C&&($[M++]=D);return this._takeByInt32Indices($)}}let m=0;for(let _=0;_<this.length;_++){const C=p.get(_);if(C===null||h===null)continue;let S=!1;switch(l._op){case"eq":S=C===h;break;case"neq":S=C!==h;break;case"gt":S=C>h;break;case"gte":S=C>=h;break;case"lt":S=C<h;break;case"lte":S=C<=h;break}S&&m++}if(m===this.length)return this;if(m===0)return this.slice(0,0);const d=new Int32Array(m);let w=0;for(let _=0;_<this.length;_++){const C=p.get(_);if(C===null||h===null)continue;let S=!1;switch(l._op){case"eq":S=C===h;break;case"neq":S=C!==h;break;case"gt":S=C>h;break;case"gte":S=C>=h;break;case"lt":S=C<h;break;case"lte":S=C<=h;break}S&&(d[w++]=_)}return this._takeByInt32Indices(d)}}const c=t.evaluate(this);let u=0;for(let g=0;g<this.length;g++)c.get(g)===!0&&u++;if(u===this.length)return this;if(u===0)return this.slice(0,0);const a=new Int32Array(u);let f=0;for(let g=0;g<this.length;g++)c.get(g)===!0&&(a[f++]=g);return this._takeByInt32Indices(a)}const n=t;let r=0;for(let i=0;i<this.length;i++)n(this.row(i))&&r++;if(r===this.length)return this;if(r===0)return this.slice(0,0);const s=new Int32Array(r);let o=0;for(let i=0;i<this.length;i++)n(this.row(i))&&(s[o++]=i);return this._takeByInt32Indices(s)}apply(t){if(this.length===0)return new I(new Map,[...this._columnOrder]);const n=[];for(let r=0;r<this.length;r++)n.push(t(this.row(r)));return I.fromRows(n)}where(t,n,r){const s=ot(t),o=r;let i;switch(n){case"=":i=s.eq(o);break;case"!=":i=s.neq(o);break;case">":i=s.gt(o);break;case">=":i=s.gte(o);break;case"<":i=s.lt(o);break;case"<=":i=s.lte(o);break}return this.filter(i)}sortBy(t,n){const r=Array.isArray(t)?t:[t],s=Array.isArray(n)?n:r.map(()=>n??"asc");for(const u of r)if(!this._columns.has(u))throw new P(u,this._columnOrder);if(r.length===1){const u=this._columns.get(r[0]),a=s[0]==="desc";if(u instanceof q&&u.isInterned){const m=u.internedStorage,d=m.dictionary.length,w=Array.from({length:d},(x,$)=>$);w.sort((x,$)=>{const M=m.dictionary[x],D=m.dictionary[$],H=M<D?-1:M>D?1:0;return a?-H:H});const _=new Uint32Array(d);for(let x=0;x<d;x++)_[w[x]]=x;const C=this.length,S=m.indices,y=Array.from({length:C},(x,$)=>$);if(u.allValid)y.sort((x,$)=>_[S[x]]-_[S[$]]);else{const x=u.nullMask;y.sort(($,M)=>{const D=x.getUnsafe($),H=x.getUnsafe(M);return!D&&!H?0:D?H?_[S[$]]-_[S[M]]:-1:1})}const v=new Int32Array(y),b=new Map;for(const x of this._columnOrder)b.set(x,this._columns.get(x).take(v));return new I(b,[...this._columnOrder])}const f=new Array(this.length);for(let m=0;m<this.length;m++)f[m]=u.get(m);const g=Array.from({length:this.length},(m,d)=>d);g.sort((m,d)=>{const w=f[m],_=f[d],C=w==null,S=_==null;if(C&&S)return 0;if(C)return 1;if(S)return-1;let y=0;return typeof w=="number"&&typeof _=="number"?y=w-_:typeof w=="string"&&typeof _=="string"?y=w<_?-1:w>_?1:0:typeof w=="boolean"&&typeof _=="boolean"?y=(w?1:0)-(_?1:0):w instanceof Date&&_ instanceof Date&&(y=w.getTime()-_.getTime()),a?-y:y});const h=new Int32Array(g),p=new Map;for(const m of this._columnOrder)p.set(m,this._columns.get(m).take(h));return new I(p,[...this._columnOrder])}if(r.length===2&&this._columns.get(r[0]).dtype==="utf8"&&(this._columns.get(r[1]).dtype==="f64"||this._columns.get(r[1]).dtype==="i32")){const u=this._columns.get(r[0]),a=this._columns.get(r[1]),f=new Array(this.length),g=new Array(this.length);for(let w=0;w<this.length;w++)f[w]=u.get(w),g[w]=a.get(w);const h=s[0]==="desc",p=s[1]==="desc",m=Array.from({length:this.length},(w,_)=>_);m.sort((w,_)=>{const C=f[w],S=f[_],y=C===null,v=S===null;if(!y||!v){if(y)return 1;if(v)return-1;const H=C<S?-1:C>S?1:0;if(H!==0)return h?-H:H}const b=g[w],x=g[_],$=b===null,M=x===null;if($&&M)return 0;if($)return 1;if(M)return-1;const D=b-x;return p?-D:D});const d=new Int32Array(m);return this._takeByInt32Indices(d)}const o=r.map(u=>{const a=this._columns.get(u),f=new Array(this.length);for(let g=0;g<this.length;g++)f[g]=a.get(g);return f}),i=Array.from({length:this.length},(u,a)=>a);i.sort((u,a)=>{for(let f=0;f<r.length;f++){const g=o[f][u],h=o[f][a],p=g==null,m=h==null;if(p&&m)continue;if(p)return 1;if(m)return-1;let d=0;if(g instanceof Date&&h instanceof Date?d=g.getTime()-h.getTime():typeof g=="string"&&typeof h=="string"?d=g<h?-1:g>h?1:0:typeof g=="number"&&typeof h=="number"?d=g-h:typeof g=="boolean"&&typeof h=="boolean"&&(d=(g?1:0)-(h?1:0)),d!==0)return s[f]==="desc"?-d:d}return 0});const l=new Int32Array(i),c=new Map;for(const u of this._columnOrder)c.set(u,this._columns.get(u).take(l));return new I(c,[...this._columnOrder])}unique(t,n="first"){const r=t===void 0?this._columnOrder:Array.isArray(t)?t:[t];for(const i of r)if(!this._columns.has(i))throw new P(i,this._columnOrder);const s=new Set,o=[];if(n==="first")for(let i=0;i<this.length;i++){const l=this._rowKey(i,r);s.has(l)||(s.add(l),o.push(i))}else{const i=new Map,l=[];for(let c=0;c<this.length;c++){const u=this._rowKey(c,r);i.has(u)||l.push(u),i.set(u,c)}for(const c of l)o.push(i.get(c))}return this._takeByIndices(o)}sample(t,n){if(this.length===0)return this.clone();let r;if(t>=1)r=Math.min(Math.floor(t),this.length);else if(t>0&&t<1)r=Math.max(1,Math.round(t*this.length));else throw new V("INVALID_OPERATION",`sample size must be positive, got ${t}`);const s=n?.seed!==void 0?Yr(n.seed):Math.random,o=Array.from({length:this.length},(i,l)=>l);for(let i=o.length-1;i>0;i--){const l=Math.floor(s()*(i+1)),c=o[i];o[i]=o[l],o[l]=c}return this._takeByIndices(o.slice(0,r))}groupBy(...t){return new _r(this,t)}join(t,n,r="inner",s){return Sr(this,t,n,r,s)}pivot(t){return $r(this,t)}melt(t){return Ir(this,t)}explode(t){if(!this._columns.has(t))throw new P(t,this._columnOrder);const n=this._columns.get(t),r=this._columnOrder.filter(o=>o!==t),s={};for(const o of this._columnOrder)s[o]=[];for(let o=0;o<this.length;o++){const i=n.get(o);if(i===null){s[t].push(null);for(const l of r)s[l].push(this._columns.get(l).get(o))}else if(Array.isArray(i)){if(i.length===0)continue;for(const l of i){s[t].push(l===void 0?null:l);for(const c of r)s[c].push(this._columns.get(c).get(o))}}else{s[t].push(i);for(const l of r)s[l].push(this._columns.get(l).get(o))}}return I.fromColumns(s)}transpose(t){return Dr(this,t)}static concat(...t){return Jt(...t)}_rowKey(t,n){const r=[];for(const s of n){const o=this._columns.get(s).get(t);o===null?r.push("\0null"):o instanceof Date?r.push(`\0d${o.getTime()}`):typeof o=="number"||typeof o=="string"||typeof o=="boolean"?r.push(`\0${typeof o}${String(o)}`):r.push(`\0obj${JSON.stringify(o)}`)}return r.join("")}_takeByIndices(t){const n=new Int32Array(t);return this._takeByInt32Indices(n)}_takeByInt32Indices(t){const n=new Map;for(const r of this._columnOrder)n.set(r,this._columns.get(r).take(t));return new I(n,[...this._columnOrder])}dropNull(t){const n=t===void 0?this._columnOrder:Array.isArray(t)?t:[t];for(const s of n)if(!this._columns.has(s))throw new P(s,this._columnOrder);const r=[];for(let s=0;s<this.length;s++){let o=!1;for(const i of n)if(this._columns.get(i).get(s)===null){o=!0;break}o||r.push(s)}return this._takeByIndices(r)}fillNull(t){if(typeof t=="string")return this._fillNullDirectional(t);for(const r of Object.keys(t))if(!this._columns.has(r))throw new P(r,this._columnOrder);const n=new Map;for(const r of this._columnOrder){const s=this._columns.get(r),o=t[r];if(o!==void 0){const i=[];for(let l=0;l<s.length;l++){const c=s.get(l);i.push(c===null?o:c)}n.set(r,mt(s.dtype,i))}else n.set(r,s)}return new I(n,[...this._columnOrder])}_fillNullDirectional(t){const n=new Map;for(const r of this._columnOrder){const s=this._columns.get(r);if(s.nullCount===0){n.set(r,s);continue}const o=[];for(let i=0;i<s.length;i++)o.push(s.get(i));if(t==="forward")for(let i=1;i<o.length;i++)o[i]===null&&o[i-1]!==null&&(o[i]=o[i-1]);else for(let i=o.length-2;i>=0;i--)o[i]===null&&o[i+1]!==null&&(o[i]=o[i+1]);n.set(r,mt(s.dtype,o))}return new I(n,[...this._columnOrder])}cast(t){for(const r of Object.keys(t))if(!this._columns.has(r))throw new P(r,this._columnOrder);const n=new Map;for(const r of this._columnOrder){const s=t[r];if(s){const i=new A(r,this._columns.get(r)).cast(s);n.set(r,i.column)}else n.set(r,this._columns.get(r))}return new I(n,[...this._columnOrder])}toString(t){const n=t?.maxRows??10,r=t?.maxCols??10,[s,o]=this.shape;if(o===0||s===0)return`Empty DataFrame
0 rows x ${o} columns`;const i=this._columnOrder;let l;if(i.length>r){const S=Math.floor(r/2);l=[...i.slice(0,S),"...",...i.slice(i.length-S)]}else l=[...i];let c;if(s>n){const S=Math.floor(n/2);c=[...Array.from({length:S},(y,v)=>v),-1,...Array.from({length:S},(y,v)=>s-S+v)]}else c=Array.from({length:s},(S,y)=>y);const u=S=>S===null?"null":S instanceof Date?S.toISOString():typeof S=="number"||typeof S=="string"||typeof S=="boolean"?String(S):JSON.stringify(S),a=["",...l],f=[];for(const S of c){if(S===-1){f.push(a.map(()=>"..."));continue}const y=[String(S)];for(const v of l)v==="..."?y.push("..."):y.push(u(this._columns.get(v).get(S)));f.push(y)}const g=a.map((S,y)=>{let v=S.length;for(const b of f)v=Math.max(v,b[y].length);return v}),h=(S,y,v)=>v===0?S.padStart(y):S.padEnd(y),p="",m=[],d=" "+a.map((S,y)=>h(S,g[y],y)).join("  ")+" ",w=""+g.map(S=>p.repeat(S)).join("")+"",_=""+g.map(S=>p.repeat(S)).join("")+"",C=""+g.map(S=>p.repeat(S)).join("")+"";m.push(w),m.push(d),m.push(_);for(const S of f)m.push(" "+S.map((y,v)=>h(y,g[v],v)).join("  ")+" ");return m.push(C),m.push(`${s} rows x ${o} columns`),m.join(`
`)}print(t){console.log(this.toString(t))}describe(){const n={stat:["count","mean","std","min","max"]};for(const r of this._columnOrder){const s=this._columns.get(r),o=s.dtype;if(o==="f64"||o==="i32"){const i=new A(r,s),l=i.length-i.nullCount,c=i.mean(),u=i.std(),a=i.min(),f=i.max();n[r]=[l,c,u,a,f]}}return I.fromColumns(n)}memoryUsage(){let t=0;for(const n of this._columnOrder)t+=this._columns.get(n).estimatedMemoryBytes();return t}info(){const[t,n]=this.shape,r=[];r.push(`DataFrame: ${t} rows x ${n} columns`),r.push("");const s=Math.max(6,...this._columnOrder.map(l=>l.length)),o=`${"Column".padEnd(s)}  ${"DType".padEnd(10)}  ${"Null Count".padEnd(10)}  Memory`;r.push(o),r.push("".repeat(o.length));let i=0;for(const l of this._columnOrder){const c=this._columns.get(l),u=c.dtype,a=c.nullCount,f=c.estimatedMemoryBytes();i+=f,r.push(`${l.padEnd(s)}  ${u.padEnd(10)}  ${String(a).padEnd(10)}  ${Se(f)}`)}r.push("".repeat(o.length)),r.push(`Total memory: ${Se(i)}`),console.log(r.join(`
`))}static fromColumns(t){const n=Object.keys(t);if(n.length===0)return I.empty();const r=n[0],s=t[r].length;for(const i of n)if(t[i].length!==s)throw new pt(`Column '${i}' has length ${t[i].length}, expected ${s}`);const o=new Map;for(const i of n){const l=t[i],c=ye(l),u=mt(c,l);o.set(i,u)}return new I(o,n)}static fromRows(t){if(t.length===0)return I.empty();const n=new Set;for(const o of t)for(const i of Object.keys(o))n.add(i);const r=[...n],s={};for(const o of r)s[o]=[];for(const o of t){const i=o;for(const l of r){const c=l in i?i[l]:null;s[l].push(c===void 0?null:c)}}return I.fromColumns(s)}static empty(){return new I(new Map,[])}static range(t,n,r,s=1){if(s===0)throw new V("INVALID_OPERATION","step must not be zero");if(n>=r)throw new V("INVALID_OPERATION",`start (${n}) must be less than end (${r})`);const o=Math.ceil((r-n)/s),i=new Float64Array(o);for(let a=0;a<o;a++)i[a]=n+a*s;const l=new j(o,!0),c=new N(i,l),u=new Map;return u.set(t,c),new I(u,[t])}static linspace(t,n,r,s){if(s<2)throw new V("INVALID_OPERATION","count must be at least 2");const o=new Float64Array(s),i=(r-n)/(s-1);for(let a=0;a<s;a++)o[a]=n+a*i;const l=new j(s,!0),c=new N(o,l),u=new Map;return u.set(t,c),new I(u,[t])}static async fromCSV(t,n={}){let r;if(typeof t!="string")try{const o=[];for await(const i of t)o.push(Buffer.isBuffer(i)?i:Buffer.from(i));r=Buffer.concat(o).toString(n.encoding??"utf-8")}catch(o){if(o instanceof E)throw o;const i=o instanceof Error?o.message:String(o);throw new E(`Failed to read CSV from stream: ${i}`)}else if(n.parse==="string")r=t;else if(t.startsWith("http://")||t.startsWith("https://"))try{const o=await fetch(t);if(!o.ok)throw new E(`Failed to fetch CSV from '${t}': HTTP ${String(o.status)} ${o.statusText}`);r=await o.text()}catch(o){if(o instanceof E)throw o;const i=o instanceof Error?o.message:String(o);throw new E(`Failed to fetch CSV from '${t}': ${i}`)}else try{r=await(await import("./__vite-browser-external-9wXp6ZBx.js")).readFile(t,n.encoding??"utf-8")}catch(o){if(o instanceof E)throw o;const i=o instanceof Error?o.message:String(o);throw new E(`Failed to read CSV file '${t}': ${i}`)}const s=Nn(r,n);return _e(s.header,s.columns,s.inferredTypes)}static async*streamCSV(t,n={}){for await(const r of Vn(t,n))yield _e(r.header,r.rawColumns,r.inferredTypes)}static scanCSV(t,n={}){const r=I.empty(),s=Yt(r);return s.collect.bind(s),s.collect=async()=>{const o=[];for await(const i of I.streamCSV(t,n))o.push(i);return o.length===0?I.empty():o.length===1?o[0]:Jt(...o)},s}static async*streamNDJSON(t,n={}){for await(const r of qn(t,n))yield I.fromRows(r)}static scanNDJSON(t,n={}){const r=I.empty(),s=Yt(r);return s.collect.bind(s),s.collect=async()=>{const o=[];for await(const i of I.streamNDJSON(t,n))o.push(i);return o.length===0?I.empty():o.length===1?o[0]:Jt(...o)},s}toCSV(t,n){let r,s,o;typeof t=="string"?(r=t,o=n??{}):t!=null&&typeof t=="object"&&"write"in t&&typeof t.write=="function"?(s=t,o=n??{}):o=t??{};const{header:i,rows:l}=this._extractRows(),c=Fn(i,l,o);if(s){const u=s;return new Promise((a,f)=>{let g=!1;const h=p=>{g||(g=!0,f(new E(`Failed to write CSV to stream: ${p.message}`)))};u.once("error",h),u.write(c,"utf-8",p=>{if(p)h(p);else{if(g)return;g=!0,u.removeListener("error",h),a()}})})}return r?import("./__vite-browser-external-9wXp6ZBx.js").then(u=>u.writeFile(r,c,"utf-8").catch(a=>{const f=a instanceof Error?a.message:String(a);throw new E(`Failed to write CSV file '${r}': ${f}`)})):c}static async fromJSON(t,n={}){let r;if(n.parse==="string")r=t;else try{r=await(await import("./__vite-browser-external-9wXp6ZBx.js")).readFile(t,"utf-8")}catch(o){if(o instanceof E)throw o;const i=o instanceof Error?o.message:String(o);throw new E(`Failed to read JSON file '${t}': ${i}`)}let s=JSON.parse(r);if(n.path){const o=n.path.split(".");for(const i of o)if(s!==null&&typeof s=="object"&&!Array.isArray(s))s=s[i];else throw new E(`JSON path '${n.path}' not found: '${i}' is not an object`)}if(!Array.isArray(s))throw new E("JSON content must be an array of objects");return I.fromRows(s)}toJSON(t,n){let r,s;typeof t=="string"?(r=t,s=n??{}):s=t??{};const{header:o,rows:i}=this._extractRows(),l=Wn(o,i,s);return r?import("./__vite-browser-external-9wXp6ZBx.js").then(c=>c.writeFile(r,l,"utf-8").catch(u=>{const a=u instanceof Error?u.message:String(u);throw new E(`Failed to write JSON file '${r}': ${a}`)})):l}static async fromNDJSON(t,n={}){let r;if(n.parse==="string")r=t;else try{r=await(await import("./__vite-browser-external-9wXp6ZBx.js")).readFile(t,"utf-8")}catch(i){if(i instanceof E)throw i;const l=i instanceof Error?i.message:String(i);throw new E(`Failed to read NDJSON file '${t}': ${l}`)}const o=r.split(`
`).filter(i=>i.trim()!=="").map(i=>JSON.parse(i));return I.fromRows(o)}static async fromExcel(t,n={}){const r=await Qn(t,n);if(r.header.length===0)return I.empty();const s=new Map;for(const o of r.header){const i=r.inferredTypes[o]??"f64",l=r.columns[o];s.set(o,mt(i,l))}return new I(s,[...r.header])}static async fromParquet(t,n={}){const r=await tr(t,n);if(r.header.length===0)return I.empty();const s=new Map;for(const o of r.header){const i=r.inferredTypes[o]??"f64",l=r.columns[o];s.set(o,mt(i,l))}return new I(s,[...r.header])}async toExcel(t,n={}){const{header:r,rows:s}=this._extractRows();await nr(t,r,s,n)}async toParquet(t,n={}){const r=this._columnOrder,s={};for(const o of r){const i=this._columns.get(o),l=[];for(let c=0;c<i.length;c++)l.push(i.get(c));s[o]={values:l,dtype:i.dtype}}await ir(t,r,s,n)}async toArrow(){return ur({columnOrder:this._columnOrder,getColumnValues:t=>{const n=this._columns.get(t),r=[];for(let s=0;s<n.length;s++)r.push(n.get(s));return{values:r,dtype:n.dtype}}})}static fromArrow(t){const n=fr(t);if(n.header.length===0)return I.empty();const r=new Map;for(const s of n.header){const o=n.inferredTypes[s]??"f64",i=n.columns[s];r.set(s,mt(o,i))}return new I(r,[...n.header])}async toArrowIPC(){let t;try{t=await import("apache-arrow")}catch{throw new E("apache-arrow is required for Arrow IPC serialization but is not installed. Run: npm install apache-arrow")}const n=await this.toArrow();return t.tableToIPC(n,"stream")}static async fromArrowIPC(t){let n;try{n=await import("apache-arrow")}catch{throw new E("apache-arrow is required for Arrow IPC deserialization but is not installed. Run: npm install apache-arrow")}const r=n.tableFromIPC(t);return I.fromArrow(r)}toNDJSON(t){const{header:n,rows:r}=this._extractRows(),s=zn(n,r);return t?import("./__vite-browser-external-9wXp6ZBx.js").then(o=>o.writeFile(t,s,"utf-8").catch(i=>{const l=i instanceof Error?i.message:String(i);throw new E(`Failed to write NDJSON file '${t}': ${l}`)})):s}toSQL(t,n){const{header:r,rows:s}=this._extractRows();return Lr(t,r,s,n)}_extractRows(){const t=this._columnOrder,n=[];for(let r=0;r<this.length;r++){const s=[];for(const o of this._columnOrder)s.push(this._columns.get(o).get(r));n.push(s)}return{header:t,rows:n}}union(t){return Or(this,t)}intersection(t){return Rr(this,t)}difference(t){return Tr(this,t)}query(t){return Jr(this,t)}static registerReader(t,n){const r=t.startsWith(".")?t.slice(1):t;I._readers.set(r.toLowerCase(),n)}static registerWriter(t,n){const r=t.startsWith(".")?t.slice(1):t;I._writers.set(r.toLowerCase(),n)}static async fromFile(t,n){const r=t.split(".").pop()?.toLowerCase();if(!r)throw new E(`Cannot determine file extension from path: '${t}'`);const s=I._readers.get(r);if(!s)throw new E(`No reader registered for extension '.${r}'. Use DataFrame.registerReader('${r}', readerFn) to register one.`);const o=await import("./__vite-browser-external-9wXp6ZBx.js");let i;try{i=await o.readFile(t)}catch(l){const c=l instanceof Error?l.message:String(l);throw new E(`Failed to read file '${t}': ${c}`)}return s(i,n)}async toFile(t,n){const r=t.split(".").pop()?.toLowerCase();if(!r)throw new E(`Cannot determine file extension from path: '${t}'`);const s=I._writers.get(r);if(!s)throw new E(`No writer registered for extension '.${r}'. Use DataFrame.registerWriter('${r}', writerFn) to register one.`);await s(this,t,n)}};function Yr(e){let t=e|0;return()=>{t=t+1831565813|0;let n=Math.imul(t^t>>>15,1|t);return n=n+Math.imul(n^n>>>7,61|n)^n,((n^n>>>14)>>>0)/4294967296}}function _e(e,t,n){if(e.length===0)return Dt.empty();const r=new Map;for(const s of e){const o=n[s]??"utf8",i=t[s],l=Gr(i,o);r.set(s,mt(o,l))}return new Dt(r,[...e])}function Gr(e,t){switch(t){case"f64":case"i32":return e.map(n=>n===null?null:Number(n));case"bool":return e.map(n=>n===null?null:n.toLowerCase()==="true");case"date":return e.map(n=>n===null?null:new Date(n));default:return e}}function ye(e){for(const t of e)if(t!=null){if(typeof t=="number")return"f64";if(typeof t=="string")return"utf8";if(typeof t=="boolean")return"bool";if(t instanceof Date)return"date";if(Array.isArray(t)||typeof t=="object")return"object"}return"f64"}function mt(e,t){switch(e){case"f64":return N.from(t);case"i32":return at.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);case"object":return dt.from(t);default:throw new V("INVALID_OPERATION",`Unsupported dtype for column construction: ${e}`)}}function Se(e){return e<1024?`${e} B`:e<1024*1024?`${(e/1024).toFixed(1)} KB`:e<1024*1024*1024?`${(e/(1024*1024)).toFixed(1)} MB`:`${(e/(1024*1024*1024)).toFixed(1)} GB`}tn((e,t)=>new Dt(e,t));function Ce(e){return typeof e=="number"?"f64":typeof e=="string"?"utf8":typeof e=="boolean"?"bool":e instanceof Date?"date":"f64"}function Qr(e,t){switch(e){case"f64":return N.from(t);case"utf8":return q.from(t);case"bool":return U.from(t);case"date":return G.from(t);default:return N.from(t)}}var Zr=class extends k{_clauses;_otherwise;constructor(e,t){super(),this._clauses=e,this._otherwise=t}get dependencies(){const e=new Set;for(const t of this._clauses){for(const n of t.condition.dependencies)e.add(n);for(const n of t.value.dependencies)e.add(n)}if(this._otherwise)for(const t of this._otherwise.dependencies)e.add(t);return[...e]}toString(){const e=this._clauses.map(t=>`WHEN ${t.condition.toString()} THEN ${t.value.toString()}`);return this._otherwise&&e.push(`ELSE ${this._otherwise.toString()}`),`CASE ${e.join(" ")} END`}evaluate(e){const t=e.length,n=this._clauses.map(u=>u.condition.evaluate(e)),r=this._clauses.map(u=>u.value.evaluate(e)),s=this._otherwise?this._otherwise.evaluate(e):null,o=[];let i=null;for(let u=0;u<t;u++){let a=!1;for(let f=0;f<this._clauses.length;f++)if(n[f].get(u)===!0){const h=r[f].get(u);o.push(h),i===null&&h!==null&&(i=Ce(h)),a=!0;break}if(!a)if(s){const f=s.get(u);o.push(f),i===null&&f!==null&&(i=Ce(f))}else o.push(null)}const c=Qr(i??"f64",o);return new A("",c)}},Xr=class{_condition;constructor(e){this._condition=e}then(e){const t=e instanceof k?e:new tt(e);return new Oe([{condition:this._condition,value:t}])}},Oe=class{_clauses;constructor(e){this._clauses=e}when(e){return new ts(this._clauses,e)}otherwise(e){const t=e instanceof k?e:new tt(e);return new Zr(this._clauses,t)}},ts=class{_clauses;_condition;constructor(e,t){this._clauses=e,this._condition=t}then(e){const t=e instanceof k?e:new tt(e);return new Oe([...this._clauses,{condition:this._condition,value:t}])}};function Ts(e){return new Xr(e)}var Gt=class extends k{_inner;_op;constructor(e,t){super(),this._inner=e,this._op=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.${this._op}()`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);if(s===null)n.push(null);else switch(this._op){case"toLowerCase":n.push(s.toLowerCase());break;case"toUpperCase":n.push(s.toUpperCase());break;case"trim":n.push(s.trim());break}}return new A("",q.from(n))}},es=class extends k{_inner;_pattern;constructor(e,t){super(),this._inner=e,this._pattern=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.contains("${this._pattern}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);n.push(s===null?null:s.includes(this._pattern))}return new A("",U.from(n))}},ns=class extends k{_inner;_prefix;constructor(e,t){super(),this._inner=e,this._prefix=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.startsWith("${this._prefix}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);n.push(s===null?null:s.startsWith(this._prefix))}return new A("",U.from(n))}},rs=class extends k{_inner;_suffix;constructor(e,t){super(),this._inner=e,this._suffix=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.endsWith("${this._suffix}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);n.push(s===null?null:s.endsWith(this._suffix))}return new A("",U.from(n))}},ss=class extends k{_inner;_pattern;_replacement;constructor(e,t,n){super(),this._inner=e,this._pattern=t,this._replacement=n}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.replace("${this._pattern}", "${this._replacement}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);n.push(s===null?null:s.replaceAll(this._pattern,this._replacement))}return new A("",q.from(n))}},os=class extends k{_inner;_start;_end;constructor(e,t,n){super(),this._inner=e,this._start=t,this._end=n}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.slice(${this._start}${this._end!==void 0?`, ${this._end}`:""})`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);n.push(s===null?null:s.slice(this._start,this._end))}return new A("",q.from(n))}},is=class extends k{_inner;constructor(e){super(),this._inner=e}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.length()`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);n.push(s===null?null:s.length)}return new A("",N.from(n))}},ls=class extends k{_parts;constructor(e){super(),this._parts=e}get dependencies(){const e=new Set;for(const t of this._parts)if(t instanceof k)for(const n of t.dependencies)e.add(n);return[...e]}toString(){return`concat(${this._parts.map(t=>t instanceof k?t.toString():`"${t}"`).join(", ")})`}evaluate(e){const t=e.length,n=this._parts.map(s=>s instanceof k?s.evaluate(e):s),r=[];for(let s=0;s<t;s++){let o=!1,i="";for(const l of n)if(typeof l=="string")i+=l;else{const c=l.get(s);if(c===null){o=!0;break}i+=c}r.push(o?null:i)}return new A("",q.from(r))}},Fs=class{_expr;constructor(e){this._expr=e}toLowerCase(){return new Gt(this._expr,"toLowerCase")}toUpperCase(){return new Gt(this._expr,"toUpperCase")}trim(){return new Gt(this._expr,"trim")}contains(e){return new es(this._expr,e)}startsWith(e){return new ns(this._expr,e)}endsWith(e){return new rs(this._expr,e)}replace(e,t){return new ss(this._expr,e,t)}slice(e,t){return new os(this._expr,e,t)}length(){return new is(this._expr)}concat(...e){return new ls([this._expr,...e])}};function cs(e,t){switch(t){case"year":return e.getFullYear();case"month":return e.getMonth()+1;case"day":return e.getDate();case"hour":return e.getHours();case"minute":return e.getMinutes();case"second":return e.getSeconds();case"dayOfWeek":return e.getDay();case"dayOfYear":{const n=new Date(e.getFullYear(),0,0),r=e.getTime()-n.getTime(),s=1e3*60*60*24;return Math.floor(r/s)}case"weekNumber":{const n=new Date(e.getTime());n.setHours(0,0,0,0),n.setDate(n.getDate()+3-(n.getDay()+6)%7);const r=new Date(n.getFullYear(),0,4),s=(n.getTime()-r.getTime())/(1e3*60*60*24);return 1+Math.round((s-3+(r.getDay()+6)%7)/7)}case"quarter":return Math.floor(e.getMonth()/3)+1;case"timestamp":return e.getTime()}}var nt=class extends k{_inner;_op;constructor(e,t){super(),this._inner=e,this._op=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.dt.${this._op}()`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);n.push(s===null?null:cs(s,this._op))}return new A("",N.from(n))}},us=class extends k{_inner;_unit;constructor(e,t){super(),this._inner=e,this._unit=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.dt.truncate("${this._unit}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let r=0;r<t.length;r++){const s=t.get(r);s===null?n.push(null):n.push(hs(s,this._unit))}return new A("",G.from(n))}},as=class extends k{_left;_right;_unit;constructor(e,t,n){super(),this._left=e,this._right=t,this._unit=n}get dependencies(){return[...new Set([...this._left.dependencies,...this._right.dependencies])]}toString(){return`dateDiff(${this._left.toString()}, ${this._right.toString()}, "${this._unit}")`}evaluate(e){const t=this._left.evaluate(e),n=this._right.evaluate(e),r=t.length,s=[];for(let o=0;o<r;o++){const i=t.get(o),l=n.get(o);if(i===null||l===null)s.push(null);else{const c=i.getTime()-l.getTime();s.push(fs(c,this._unit))}}return new A("",N.from(s))}};function fs(e,t){switch(t){case"milliseconds":return e;case"seconds":return e/1e3;case"minutes":return e/(1e3*60);case"hours":return e/(1e3*60*60);case"days":return e/(1e3*60*60*24)}}function hs(e,t){switch(t){case"year":return new Date(e.getFullYear(),0,1);case"month":return new Date(e.getFullYear(),e.getMonth(),1);case"day":return new Date(e.getFullYear(),e.getMonth(),e.getDate());case"hour":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours());case"minute":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours(),e.getMinutes());case"second":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours(),e.getMinutes(),e.getSeconds())}}var Ls=class{_expr;constructor(e){this._expr=e}year(){return new nt(this._expr,"year")}month(){return new nt(this._expr,"month")}day(){return new nt(this._expr,"day")}hour(){return new nt(this._expr,"hour")}minute(){return new nt(this._expr,"minute")}second(){return new nt(this._expr,"second")}dayOfWeek(){return new nt(this._expr,"dayOfWeek")}dayOfYear(){return new nt(this._expr,"dayOfYear")}weekNumber(){return new nt(this._expr,"weekNumber")}quarter(){return new nt(this._expr,"quarter")}timestamp(){return new nt(this._expr,"timestamp")}truncate(e){return new us(this._expr,e)}diff(e,t="days"){return new as(this._expr,e,t)}},Rt=class extends k{_source;_descending;constructor(e,t=!1){super(),this._source=e,this._descending=t}get dependencies(){return this._source.dependencies}_sortCompare(e,t){return this._descending?-Ot(e,t):Ot(e,t)}},gs=class Re extends Rt{toString(){return`rank(${this._source.toString()})`}withDescending(t){return new Re(this._source,t)}evaluate(t){const n=this._source.evaluate(t),r=n.length,s=[];for(let l=0;l<r;l++)s.push({value:n.get(l),idx:l});s.sort((l,c)=>this._sortCompare(l.value,c.value));const o=new Array(r);let i=1;for(let l=0;l<s.length;l++)l>0&&Ot(s[l].value,s[l-1].value)!==0&&(i=l+1),o[s[l].idx]=i;return new A("rank",N.from(o))}},ms=class Te extends Rt{toString(){return`dense_rank(${this._source.toString()})`}withDescending(t){return new Te(this._source,t)}evaluate(t){const n=this._source.evaluate(t),r=n.length,s=[];for(let l=0;l<r;l++)s.push({value:n.get(l),idx:l});s.sort((l,c)=>this._sortCompare(l.value,c.value));const o=new Array(r);let i=1;for(let l=0;l<s.length;l++)l>0&&Ot(s[l].value,s[l-1].value)!==0&&i++,o[s[l].idx]=i;return new A("dense_rank",N.from(o))}},ps=class Fe extends Rt{toString(){return`row_number(${this._source.toString()})`}withDescending(t){return new Fe(this._source,t)}evaluate(t){const n=this._source.evaluate(t),r=n.length,s=new Array(r);for(let l=0;l<r;l++)s[l]=n.get(l);const o=Array.from({length:r},(l,c)=>c);o.sort((l,c)=>this._sortCompare(s[l],s[c]));const i=new Array(r);for(let l=0;l<o.length;l++)i[o[l]]=l+1;return new A("row_number",N.from(i))}},ds=class Le extends Rt{toString(){return`percent_rank(${this._source.toString()})`}withDescending(t){return new Le(this._source,t)}evaluate(t){const n=this._source.evaluate(t),r=n.length;if(r<=1){const l=new Array(r).fill(0);return new A("percent_rank",N.from(l))}const s=[];for(let l=0;l<r;l++)s.push({value:n.get(l),idx:l});s.sort((l,c)=>this._sortCompare(l.value,c.value));const o=new Array(r);let i=1;for(let l=0;l<s.length;l++)l>0&&Ot(s[l].value,s[l-1].value)!==0&&(i=l+1),o[s[l].idx]=(i-1)/(r-1);return new A("percent_rank",N.from(o))}},ws=class Ve extends Rt{_n;constructor(t,n,r=!1){super(t,r),this._n=n}toString(){return`ntile(${this._source.toString()}, ${this._n})`}withDescending(t){return new Ve(this._source,this._n,t)}evaluate(t){const n=this._source.evaluate(t),r=n.length,s=[];for(let i=0;i<r;i++)s.push({value:n.get(i),idx:i});s.sort((i,l)=>this._sortCompare(i.value,l.value));const o=new Array(r);for(let i=0;i<s.length;i++)o[s[i].idx]=Math.floor(i*this._n/r)+1;return new A("ntile",N.from(o))}};function Ot(e,t){if(e===null&&t===null)return 0;if(e===null)return 1;if(t===null)return-1;if(typeof e=="number"&&typeof t=="number")return e-t;if(typeof e=="string"&&typeof t=="string")return e<t?-1:e>t?1:0;if(e instanceof Date&&t instanceof Date)return e.getTime()-t.getTime();const n=typeof e=="string"?e:typeof e=="number"?`${e}`:typeof e=="boolean"?`${e}`:"object",r=typeof t=="string"?t:typeof t=="number"?`${t}`:typeof t=="boolean"?`${t}`:"object";return n<r?-1:n>r?1:0}var Ut=class extends k{_source;constructor(e){super(),this._source=e}get dependencies(){return this._source.dependencies}},_s=class extends Ut{toString(){return`cumSum(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,r=new Array(n);let s=0;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(s+=i),r[o]=s}return new A("cumSum",N.from(r))}},ys=class extends Ut{toString(){return`cumMax(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,r=new Array(n);let s=null;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(s=s===null?i:Math.max(s,i)),r[o]=s}return new A("cumMax",N.from(r))}},Ss=class extends Ut{toString(){return`cumMin(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,r=new Array(n);let s=null;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(s=s===null?i:Math.min(s,i)),r[o]=s}return new A("cumMin",N.from(r))}},Cs=class extends Ut{toString(){return`cumProd(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,r=new Array(n);let s=1;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(s*=i),r[o]=s}return new A("cumProd",N.from(r))}},bs=class extends Ut{toString(){return`cumCount(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,r=new Array(n);let s=0;for(let o=0;o<n;o++)t.get(o)!==null&&s++,r[o]=s;return new A("cumCount",N.from(r))}},se=class extends k{_source;_offset;constructor(e,t){super(),this._source=e,this._offset=t}get dependencies(){return this._source.dependencies}},vs=class extends se{toString(){return`shift(${this._source.toString()}, ${this._offset})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,r=new Array(n);for(let s=0;s<n;s++){const o=s-this._offset;if(o<0||o>=n)r[s]=null;else{const i=t.get(o);r[s]=i!==null&&typeof i=="number"?i:null}}return new A("shift",N.from(r))}},xs=class extends se{toString(){return`diff(${this._source.toString()}, ${this._offset})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,r=new Array(n);for(let s=0;s<n;s++){const o=s-this._offset;if(o<0||o>=n)r[s]=null;else{const i=t.get(s),l=t.get(o);i!==null&&typeof i=="number"&&l!==null&&typeof l=="number"?r[s]=i-l:r[s]=null}}return new A("diff",N.from(r))}},ks=class extends se{toString(){return`pctChange(${this._source.toString()}, ${this._offset})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,r=new Array(n);for(let s=0;s<n;s++){const o=s-this._offset;if(o<0||o>=n)r[s]=null;else{const i=t.get(s),l=t.get(o);i!==null&&typeof i=="number"&&l!==null&&typeof l=="number"&&l!==0?r[s]=(i-l)/l:r[s]=null}}return new A("pctChange",N.from(r))}},jt=class extends k{_source;_windowSize;constructor(e,t){super(),this._source=e,this._windowSize=t}get dependencies(){return this._source.dependencies}_getNumericValues(e){const t=this._source.evaluate(e),n=t.length,r=[];for(let s=0;s<n;s++){const o=t.get(s);r.push(o!==null&&typeof o=="number"?o:null)}return r}},Ns=class extends jt{toString(){return`rollingMean(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,r=new Array(n);for(let s=0;s<n;s++)if(s<this._windowSize-1)r[s]=null;else{let o=0,i=0;for(let l=s-this._windowSize+1;l<=s;l++){const c=t[l];c!==null&&(o+=c,i++)}r[s]=i>0?o/i:null}return new A("rollingMean",N.from(r))}},As=class extends jt{toString(){return`rollingSum(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,r=new Array(n);for(let s=0;s<n;s++)if(s<this._windowSize-1)r[s]=null;else{let o=0;for(let i=s-this._windowSize+1;i<=s;i++){const l=t[i];l!==null&&(o+=l)}r[s]=o}return new A("rollingSum",N.from(r))}},$s=class extends jt{toString(){return`rollingStd(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,r=new Array(n);for(let s=0;s<n;s++)if(s<this._windowSize-1)r[s]=null;else{const o=[];for(let i=s-this._windowSize+1;i<=s;i++){const l=t[i];l!==null&&o.push(l)}if(o.length<2)r[s]=null;else{let i=0;for(const u of o)i+=u;const l=i/o.length;let c=0;for(const u of o)c+=(u-l)*(u-l);r[s]=Math.sqrt(c/(o.length-1))}}return new A("rollingStd",N.from(r))}},Ms=class extends jt{toString(){return`rollingMin(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,r=new Array(n);for(let s=0;s<n;s++)if(s<this._windowSize-1)r[s]=null;else{let o=null;for(let i=s-this._windowSize+1;i<=s;i++){const l=t[i];l!==null&&(o=o===null?l:Math.min(o,l))}r[s]=o}return new A("rollingMin",N.from(r))}},Is=class extends jt{toString(){return`rollingMax(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,r=new Array(n);for(let s=0;s<n;s++)if(s<this._windowSize-1)r[s]=null;else{let o=null;for(let i=s-this._windowSize+1;i<=s;i++){const l=t[i];l!==null&&(o=o===null?l:Math.max(o,l))}r[s]=o}return new A("rollingMax",N.from(r))}},Es=class extends k{_source;_alpha;constructor(e,t){super(),this._source=e,this._alpha=t}get dependencies(){return this._source.dependencies}toString(){return`ewm(${this._source.toString()}, ${this._alpha})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,r=new Array(n);let s=null;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(s===null?s=i:s=this._alpha*i+(1-this._alpha)*s),r[o]=s}return new A("ewm",N.from(r))}},ee=class extends k{_inner;_partitionCols;constructor(e,t){super(),this._inner=e,this._partitionCols=t}get dependencies(){return[...new Set([...this._inner.dependencies,...this._partitionCols])]}toString(){return`${this._inner.toString()}.over(${this._partitionCols.join(", ")})`}evaluate(e){const t=e.length,n=new Array(t),r=new Map,s=this._partitionCols.map(i=>e.col(i).column);for(let i=0;i<t;i++){const l=Ds(s,i),c=r.get(l);c?c.push(i):r.set(l,[i])}const o=e.columns;for(const i of r.values()){const l=new Int32Array(i),c=new Map;for(const f of o)c.set(f,e.col(f).column.take(l));const u=new Dt(c,o),a=this._inner.evaluate(u);for(let f=0;f<i.length;f++)n[i[f]]=a.get(f)}return new A("over",N.from(n))}};function Ds(e,t){const n=[];for(const r of e){const s=r.get(t);s===null?n.push("\0null"):s instanceof Date?n.push(`\0d${s.getTime()}`):typeof s=="number"||typeof s=="string"||typeof s=="boolean"?n.push(`\0${typeof s}${String(s)}`):n.push(`\0obj${JSON.stringify(s)}`)}return n.join("")}var Os=class extends k{_inner;_orderCol;_direction;constructor(e,t,n="asc"){super(),this._inner=e,this._orderCol=t,this._direction=n}get dependencies(){return[...new Set([...this._inner.dependencies,this._orderCol])]}toString(){return`${this._inner.toString()}.orderBy(${this._orderCol}, ${this._direction})`}evaluate(e){const t=e.length,n=this._direction==="desc",r=Ue(this._inner,n),s=e.col(this._orderCol).column,o=[];for(let h=0;h<t;h++)o.push(h);const i=n?-1:1;o.sort((h,p)=>i*Ot(s.get(h),s.get(p)));const l=new Int32Array(o),c=e.columns,u=new Map;for(const h of c)u.set(h,e.col(h).column.take(l));const a=new Dt(u,c),f=r.evaluate(a),g=new Array(t);for(let h=0;h<t;h++)g[o[h]]=f.get(h);return new A("orderBy",N.from(g))}};function Ue(e,t){if(e instanceof Rt)return e.withDescending(t);if(e instanceof ee){const n=Ue(e._inner,t);return new ee(n,e._partitionCols)}return e}k.prototype.rank=function(){return new gs(this)};k.prototype.denseRank=function(){return new ms(this)};k.prototype.rowNumber=function(){return new ps(this)};k.prototype.percentRank=function(){return new ds(this)};k.prototype.ntile=function(e){return new ws(this,e)};k.prototype.cumSum=function(){return new _s(this)};k.prototype.cumMax=function(){return new ys(this)};k.prototype.cumMin=function(){return new Ss(this)};k.prototype.cumProd=function(){return new Cs(this)};k.prototype.cumCount=function(){return new bs(this)};k.prototype.shift=function(e){return new vs(this,e)};k.prototype.diff=function(e=1){return new xs(this,e)};k.prototype.pctChange=function(e=1){return new ks(this,e)};k.prototype.rollingMean=function(e){return new Ns(this,e)};k.prototype.rollingSum=function(e){return new As(this,e)};k.prototype.rollingStd=function(e){return new $s(this,e)};k.prototype.rollingMin=function(e){return new Ms(this,e)};k.prototype.rollingMax=function(e){return new Is(this,e)};k.prototype.ewm=function(e){return new Es(this,e)};k.prototype.over=function(...e){return new ee(this,e)};k.prototype.orderBy=function(e,t="asc"){return new Os(this,e,t)};function Vs(e){return Dt.fromRows(e)}export{it as AggExpr,j as BitArray,U as BooleanColumn,Ct as Column,P as ColumnNotFoundError,un as CountAggExpr,an as CountDistinctAggExpr,bs as CumCountExpr,ys as CumMaxExpr,Ss as CumMinExpr,Cs as CumProdExpr,_s as CumSumExpr,Ke as DType,Dt as DataFrame,Ge as DateAccessor,G as DateColumn,Ls as DateExprAccessor,xs as DiffExpr,He as ErrorCode,k as Expr,mn as FirstAggExpr,N as Float64Column,V as FrameKitError,_r as GroupBy,E as IOError,at as Int32Column,pn as LastAggExpr,De as LazyFrame,Pr as LazyGroupBy,dn as ListAggExpr,hn as MaxAggExpr,cn as MeanAggExpr,fn as MinAggExpr,wn as ModeAggExpr,en as NamedExpr,dt as ObjectColumn,Os as OrderedWindowExpr,ut as ParseError,ee as PartitionedWindowExpr,ks as PctChangeExpr,A as Series,pt as ShapeMismatchError,vs as ShiftExpr,gn as StdAggExpr,Je as StringAccessor,Fs as StringExprAccessor,ve as SumAggExpr,Oe as ThenBuilder,St as TypeMismatchError,q as Utf8Column,Xr as WhenBuilder,ms as WindowDenseRankExpr,ws as WindowNtileExpr,ds as WindowPercentRankExpr,gs as WindowRankExpr,ps as WindowRowNumberExpr,ot as col,Vs as df,jr as execute,Y as lit,Br as optimize,Ts as when};
//# sourceMappingURL=browser-DxMxCeRD.js.map
