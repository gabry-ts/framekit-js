{"version":3,"file":"browser-DxMxCeRD.js","sources":["../src/shims/os.ts","../../../dist/browser.js"],"sourcesContent":["// Browser shim for Node.js 'os' module\n// Only the subset used by framekit-js/browser is implemented\n\nexport function cpus(): { model: string }[] {\n  const count =\n    typeof navigator !== 'undefined' && navigator.hardwareConcurrency\n      ? navigator.hardwareConcurrency\n      : 2;\n  return Array.from({ length: count }, () => ({ model: 'browser' }));\n}\n\nexport function platform(): string {\n  return 'browser';\n}\n\nexport function arch(): string {\n  return 'unknown';\n}\n\nexport function tmpdir(): string {\n  return '/tmp';\n}\n\nexport const EOL = '\\n';\n\nexport default { cpus, platform, arch, tmpdir, EOL };\n","// src/types/dtype.ts\nvar DType = /* @__PURE__ */ ((DType2) => {\n  DType2[\"Float64\"] = \"f64\";\n  DType2[\"Int32\"] = \"i32\";\n  DType2[\"Int64\"] = \"i64\";\n  DType2[\"Utf8\"] = \"utf8\";\n  DType2[\"Boolean\"] = \"bool\";\n  DType2[\"Date\"] = \"date\";\n  DType2[\"DateTime\"] = \"datetime\";\n  DType2[\"Null\"] = \"null\";\n  DType2[\"BigInt\"] = \"bigint\";\n  DType2[\"Object\"] = \"object\";\n  return DType2;\n})(DType || {});\n\n// src/errors.ts\nvar ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {\n  ErrorCode2[\"COLUMN_NOT_FOUND\"] = \"COLUMN_NOT_FOUND\";\n  ErrorCode2[\"TYPE_MISMATCH\"] = \"TYPE_MISMATCH\";\n  ErrorCode2[\"SHAPE_MISMATCH\"] = \"SHAPE_MISMATCH\";\n  ErrorCode2[\"PARSE_ERROR\"] = \"PARSE_ERROR\";\n  ErrorCode2[\"IO_ERROR\"] = \"IO_ERROR\";\n  ErrorCode2[\"OUT_OF_MEMORY\"] = \"OUT_OF_MEMORY\";\n  ErrorCode2[\"INVALID_OPERATION\"] = \"INVALID_OPERATION\";\n  return ErrorCode2;\n})(ErrorCode || {});\nvar FrameKitError = class extends Error {\n  code;\n  constructor(code, message) {\n    super(message);\n    this.name = \"FrameKitError\";\n    this.code = code;\n  }\n};\nvar ColumnNotFoundError = class extends FrameKitError {\n  constructor(column, available) {\n    super(\n      \"COLUMN_NOT_FOUND\" /* COLUMN_NOT_FOUND */,\n      `Column '${column}' not found. Available columns: [${available.join(\", \")}]`\n    );\n    this.name = \"ColumnNotFoundError\";\n  }\n};\nvar TypeMismatchError = class extends FrameKitError {\n  constructor(message) {\n    super(\"TYPE_MISMATCH\" /* TYPE_MISMATCH */, message);\n    this.name = \"TypeMismatchError\";\n  }\n};\nvar ShapeMismatchError = class extends FrameKitError {\n  constructor(message) {\n    super(\"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */, message);\n    this.name = \"ShapeMismatchError\";\n  }\n};\nvar ParseError = class extends FrameKitError {\n  constructor(message) {\n    super(\"PARSE_ERROR\" /* PARSE_ERROR */, message);\n    this.name = \"ParseError\";\n  }\n};\nvar IOError = class extends FrameKitError {\n  constructor(message) {\n    super(\"IO_ERROR\" /* IO_ERROR */, message);\n    this.name = \"IOError\";\n  }\n};\n\n// src/storage/bitarray.ts\nvar BitArray = class _BitArray {\n  _buffer;\n  _length;\n  constructor(length, initialValue = false) {\n    if (length < 0) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `BitArray length must be non-negative, got ${length}`\n      );\n    }\n    this._length = length;\n    const byteCount = Math.ceil(length / 8);\n    this._buffer = new Uint8Array(byteCount);\n    if (initialValue) {\n      this._buffer.fill(255);\n    }\n  }\n  get length() {\n    return this._length;\n  }\n  get byteLength() {\n    return this._buffer.byteLength;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    return this.getUnsafe(index);\n  }\n  getUnsafe(index) {\n    const byteIndex = index >> 3;\n    const bitIndex = index & 7;\n    return (this._buffer[byteIndex] & 1 << bitIndex) !== 0;\n  }\n  set(index, value) {\n    this._boundsCheck(index);\n    this.setUnsafe(index, value);\n  }\n  setUnsafe(index, value) {\n    const byteIndex = index >> 3;\n    const bitIndex = index & 7;\n    if (value) {\n      this._buffer[byteIndex] = this._buffer[byteIndex] | 1 << bitIndex;\n    } else {\n      this._buffer[byteIndex] = this._buffer[byteIndex] & ~(1 << bitIndex);\n    }\n  }\n  countOnes() {\n    let count = 0;\n    for (let i = 0; i < this._length; i++) {\n      if (this.get(i)) {\n        count++;\n      }\n    }\n    return count;\n  }\n  countZeros() {\n    return this._length - this.countOnes();\n  }\n  and(other) {\n    this._lengthCheck(other);\n    const result = new _BitArray(this._length);\n    for (let i = 0; i < this._buffer.length; i++) {\n      result._buffer[i] = this._buffer[i] & other._buffer[i];\n    }\n    return result;\n  }\n  or(other) {\n    this._lengthCheck(other);\n    const result = new _BitArray(this._length);\n    for (let i = 0; i < this._buffer.length; i++) {\n      result._buffer[i] = this._buffer[i] | other._buffer[i];\n    }\n    return result;\n  }\n  clone() {\n    const result = new _BitArray(this._length);\n    result._buffer.set(this._buffer);\n    return result;\n  }\n  not() {\n    const result = new _BitArray(this._length);\n    for (let i = 0; i < this._buffer.length; i++) {\n      result._buffer[i] = ~this._buffer[i] & 255;\n    }\n    return result;\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `BitArray index ${index} out of bounds for length ${this._length}`\n      );\n    }\n  }\n  _lengthCheck(other) {\n    if (this._length !== other._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `BitArray length mismatch: ${this._length} vs ${other._length}`\n      );\n    }\n  }\n};\n\n// src/storage/column.ts\nvar Column = class {\n  _nullMask;\n  _length;\n  _refCount = 1;\n  constructor(length, nullMask) {\n    this._length = length;\n    this._nullMask = nullMask ?? new BitArray(length, true);\n  }\n  get length() {\n    return this._length;\n  }\n  get nullCount() {\n    return this._nullMask.countZeros();\n  }\n  addRef() {\n    this._refCount++;\n  }\n  release() {\n    if (this._refCount > 0) {\n      this._refCount--;\n    }\n  }\n  get refCount() {\n    return this._refCount;\n  }\n  get isShared() {\n    return this._refCount > 1;\n  }\n};\n\n// src/storage/numeric.ts\nvar Float64Column = class _Float64Column extends Column {\n  dtype = \"f64\" /* Float64 */;\n  _data;\n  _allValid;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n    this._allValid = nullMask === void 0;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (this._allValid) {\n      return this._data[index];\n    }\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return this._data[index];\n  }\n  slice(start, end) {\n    const sliced = this._data.subarray(start, end);\n    if (this._allValid) {\n      return new _Float64Column(sliced);\n    }\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _Float64Column(sliced, mask);\n  }\n  clone() {\n    if (this._allValid) {\n      return new _Float64Column(new Float64Array(this._data));\n    }\n    return new _Float64Column(new Float64Array(this._data), this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Float64Array(indices.length);\n    const mask = this._allValid ? void 0 : new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      if (mask) {\n        mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n      }\n    }\n    return new _Float64Column(data, mask);\n  }\n  sum() {\n    let total = 0;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        total += this._data[i];\n      }\n    }\n    return total;\n  }\n  mean() {\n    const validCount = this._length - this.nullCount;\n    if (validCount === 0) return null;\n    return this.sum() / validCount;\n  }\n  min() {\n    let result = null;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        const val = this._data[i];\n        if (result === null || val < result) {\n          result = val;\n        }\n      }\n    }\n    return result;\n  }\n  max() {\n    let result = null;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        const val = this._data[i];\n        if (result === null || val > result) {\n          result = val;\n        }\n      }\n    }\n    return result;\n  }\n  estimatedMemoryBytes() {\n    return this._length * 8 + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Float64Array(values.length);\n    const mask = new BitArray(values.length);\n    let hasNull = false;\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v;\n        mask.setUnsafe(i, true);\n      } else {\n        hasNull = true;\n      }\n    }\n    return hasNull ? new _Float64Column(data, mask) : new _Float64Column(data);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Float64Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _Float64Column(data, mask);\n  }\n};\nvar Int32Column = class _Int32Column extends Column {\n  dtype = \"i32\" /* Int32 */;\n  _data;\n  _allValid;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n    this._allValid = nullMask === void 0;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (this._allValid) {\n      return this._data[index];\n    }\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return this._data[index];\n  }\n  slice(start, end) {\n    const sliced = this._data.subarray(start, end);\n    if (this._allValid) {\n      return new _Int32Column(sliced);\n    }\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _Int32Column(sliced, mask);\n  }\n  clone() {\n    if (this._allValid) {\n      return new _Int32Column(new Int32Array(this._data));\n    }\n    return new _Int32Column(new Int32Array(this._data), this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Int32Array(indices.length);\n    const mask = this._allValid ? void 0 : new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      if (mask) {\n        mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n      }\n    }\n    return new _Int32Column(data, mask);\n  }\n  sum() {\n    let total = 0;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        total += this._data[i];\n      }\n    }\n    return total;\n  }\n  mean() {\n    const validCount = this._length - this.nullCount;\n    if (validCount === 0) return null;\n    return this.sum() / validCount;\n  }\n  min() {\n    let result = null;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        const val = this._data[i];\n        if (result === null || val < result) {\n          result = val;\n        }\n      }\n    }\n    return result;\n  }\n  max() {\n    let result = null;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        const val = this._data[i];\n        if (result === null || val > result) {\n          result = val;\n        }\n      }\n    }\n    return result;\n  }\n  estimatedMemoryBytes() {\n    return this._length * 4 + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Int32Array(values.length);\n    const mask = new BitArray(values.length);\n    let hasNull = false;\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v;\n        mask.setUnsafe(i, true);\n      } else {\n        hasNull = true;\n      }\n    }\n    return hasNull ? new _Int32Column(data, mask) : new _Int32Column(data);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Int32Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _Int32Column(data, mask);\n  }\n};\n\n// src/storage/string.ts\nvar Utf8Column = class _Utf8Column extends Column {\n  dtype = \"utf8\" /* Utf8 */;\n  _data;\n  _interned;\n  _allValid;\n  constructor(data, nullMask, interned) {\n    super(data.length, nullMask);\n    if (interned) {\n      this._data = null;\n      this._interned = interned;\n    } else {\n      this._data = data;\n      this._interned = null;\n    }\n    this._allValid = nullMask === void 0;\n  }\n  /** Whether this column uses interned (dictionary-encoded) storage. */\n  get isInterned() {\n    return this._interned !== null;\n  }\n  /** Raw interned storage — exposed for fast-path operations (filter, groupby, sort). */\n  get internedStorage() {\n    return this._interned;\n  }\n  /** Whether all values are non-null. */\n  get allValid() {\n    return this._allValid;\n  }\n  /** Raw null mask. */\n  get nullMask() {\n    return this._nullMask;\n  }\n  /** Raw data array (only for non-interned columns). */\n  get rawData() {\n    return this._data;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (this._allValid) {\n      if (this._interned) {\n        return this._interned.dictionary[this._interned.indices[index]];\n      }\n      return this._data[index];\n    }\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    if (this._interned) {\n      return this._interned.dictionary[this._interned.indices[index]];\n    }\n    return this._data[index];\n  }\n  slice(start, end) {\n    const len = end - start;\n    if (this._allValid) {\n      if (this._interned) {\n        const slicedIndices = this._interned.indices.slice(start, end);\n        return new _Utf8Column(new Array(len), void 0, {\n          dictionary: this._interned.dictionary,\n          indices: slicedIndices\n        });\n      }\n      return new _Utf8Column(this._data.slice(start, end));\n    }\n    const mask = new BitArray(len);\n    for (let i = 0; i < len; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    if (this._interned) {\n      const slicedIndices = this._interned.indices.slice(start, end);\n      return new _Utf8Column(new Array(len), mask, {\n        dictionary: this._interned.dictionary,\n        indices: slicedIndices\n      });\n    }\n    const sliced = this._data.slice(start, end);\n    return new _Utf8Column(sliced, mask);\n  }\n  clone() {\n    if (this._allValid) {\n      if (this._interned) {\n        return new _Utf8Column(new Array(this._length), void 0, {\n          dictionary: [...this._interned.dictionary],\n          indices: new Uint32Array(this._interned.indices)\n        });\n      }\n      return new _Utf8Column([...this._data]);\n    }\n    if (this._interned) {\n      return new _Utf8Column(new Array(this._length), this._nullMask.clone(), {\n        dictionary: [...this._interned.dictionary],\n        indices: new Uint32Array(this._interned.indices)\n      });\n    }\n    return new _Utf8Column([...this._data], this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const len = indices.length;\n    const mask = this._allValid ? void 0 : new BitArray(len);\n    if (this._interned) {\n      const newIndices = new Uint32Array(len);\n      for (let i = 0; i < len; i++) {\n        const idx = indices[i];\n        newIndices[i] = this._interned.indices[idx];\n        if (mask) {\n          mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n        }\n      }\n      return new _Utf8Column(new Array(len), mask, {\n        dictionary: this._interned.dictionary,\n        indices: newIndices\n      });\n    }\n    const data = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      if (mask) {\n        mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n      }\n    }\n    return new _Utf8Column(data, mask);\n  }\n  estimatedMemoryBytes() {\n    let bytes = this._nullMask.byteLength;\n    if (this._interned) {\n      for (const s of this._interned.dictionary) {\n        bytes += s.length * 2;\n      }\n      bytes += this._interned.indices.byteLength;\n    } else {\n      for (let i = 0; i < this._length; i++) {\n        if (this._nullMask.get(i)) {\n          bytes += this._data[i].length * 2;\n        }\n      }\n    }\n    return bytes;\n  }\n  /**\n   * Single-pass construction from values array.\n   * Builds dictionary, indices, and null mask in one loop.\n   * Falls back to plain storage if cardinality > 50%.\n   */\n  static from(values) {\n    const len = values.length;\n    if (len === 0) {\n      return new _Utf8Column([]);\n    }\n    const dictMap = /* @__PURE__ */ new Map();\n    const dictionary = [];\n    const indices = new Uint32Array(len);\n    const mask = new BitArray(len);\n    let hasNull = false;\n    let dictSize = 0;\n    for (let i = 0; i < len; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        mask.set(i, true);\n        let idx = dictMap.get(v);\n        if (idx === void 0) {\n          idx = dictSize++;\n          dictMap.set(v, idx);\n          dictionary.push(v);\n        }\n        indices[i] = idx;\n      } else {\n        hasNull = true;\n      }\n    }\n    if (dictSize > 0 && dictSize < len * 0.5) {\n      return hasNull ? new _Utf8Column(new Array(len), mask, { dictionary, indices }) : new _Utf8Column(new Array(len), void 0, { dictionary, indices });\n    }\n    const data = new Array(len);\n    for (let i = 0; i < len; i++) {\n      data[i] = values[i] ?? \"\";\n    }\n    return hasNull ? new _Utf8Column(data, mask) : new _Utf8Column(data);\n  }\n  /**\n   * Construct from pre-interned data.\n   * Used when caller already knows the dictionary (e.g., from CSV parser).\n   */\n  static fromPreInterned(dictionary, indices, nullMask) {\n    const len = indices.length;\n    return new _Utf8Column(new Array(len), nullMask, { dictionary, indices });\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const len = indices.length;\n    const mask = new BitArray(len);\n    if (this._interned) {\n      const newIndices = new Uint32Array(len);\n      for (let i = 0; i < len; i++) {\n        const idx = indices[i];\n        newIndices[i] = this._interned.indices[idx];\n        mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n      }\n      return new _Utf8Column(new Array(len), mask, {\n        dictionary: this._interned.dictionary,\n        indices: newIndices\n      });\n    }\n    const data = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _Utf8Column(data, mask);\n  }\n};\n\n// src/storage/boolean.ts\nvar BooleanColumn = class _BooleanColumn extends Column {\n  dtype = \"bool\" /* Boolean */;\n  _data;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return this._data[index] !== 0;\n  }\n  slice(start, end) {\n    const sliced = this._data.subarray(start, end);\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _BooleanColumn(sliced, mask);\n  }\n  clone() {\n    return new _BooleanColumn(new Uint8Array(this._data), this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Uint8Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _BooleanColumn(data, mask);\n  }\n  estimatedMemoryBytes() {\n    return this._length + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Uint8Array(values.length);\n    const mask = new BitArray(values.length);\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v ? 1 : 0;\n        mask.setUnsafe(i, true);\n      }\n    }\n    return new _BooleanColumn(data, mask);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Uint8Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _BooleanColumn(data, mask);\n  }\n};\n\n// src/storage/date.ts\nvar DateColumn = class _DateColumn extends Column {\n  dtype = \"date\" /* Date */;\n  _data;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return new Date(this._data[index]);\n  }\n  slice(start, end) {\n    const sliced = this._data.subarray(start, end);\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _DateColumn(sliced, mask);\n  }\n  clone() {\n    return new _DateColumn(new Float64Array(this._data), this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Float64Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _DateColumn(data, mask);\n  }\n  estimatedMemoryBytes() {\n    return this._length * 8 + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Float64Array(values.length);\n    const mask = new BitArray(values.length);\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v.getTime();\n        mask.setUnsafe(i, true);\n      }\n    }\n    return new _DateColumn(data, mask);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Float64Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _DateColumn(data, mask);\n  }\n};\n\n// src/storage/object.ts\nvar ObjectColumn = class _ObjectColumn extends Column {\n  dtype = \"object\" /* Object */;\n  _data;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return this._data[index];\n  }\n  slice(start, end) {\n    const sliced = this._data.slice(start, end);\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _ObjectColumn(sliced, mask);\n  }\n  clone() {\n    return new _ObjectColumn([...this._data], this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _ObjectColumn(data, mask);\n  }\n  estimatedMemoryBytes() {\n    return this._length * 8 + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Array(values.length);\n    const mask = new BitArray(values.length);\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v;\n        mask.setUnsafe(i, true);\n      } else {\n        data[i] = null;\n      }\n    }\n    return new _ObjectColumn(data, mask);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _ObjectColumn(data, mask);\n  }\n};\n\n// src/accessors/string-accessor.ts\nvar StringAccessor = class {\n  _series;\n  constructor(series) {\n    if (series.dtype !== \"utf8\" /* Utf8 */) {\n      throw new TypeMismatchError(\n        `StringAccessor requires Series with dtype Utf8, got '${series.dtype}'`\n      );\n    }\n    this._series = series;\n  }\n  toLowerCase() {\n    return this._mapString((s) => s.toLowerCase());\n  }\n  toUpperCase() {\n    return this._mapString((s) => s.toUpperCase());\n  }\n  trim() {\n    return this._mapString((s) => s.trim());\n  }\n  startsWith(prefix) {\n    return this._mapBoolean((s) => s.startsWith(prefix));\n  }\n  endsWith(suffix) {\n    return this._mapBoolean((s) => s.endsWith(suffix));\n  }\n  contains(pattern) {\n    return this._mapBoolean((s) => s.includes(pattern));\n  }\n  replace(pattern, replacement) {\n    return this._mapString((s) => s.replaceAll(pattern, replacement));\n  }\n  split(separator) {\n    const data = [];\n    const mask = new BitArray(this._series.length);\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        data.push([]);\n      } else {\n        data.push(val.split(separator));\n        mask.set(i, true);\n      }\n    }\n    const col2 = new ListColumn(data, mask);\n    return new Series(this._series.name, col2);\n  }\n  slice(start, end) {\n    return this._mapString((s) => s.slice(start, end));\n  }\n  length() {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(val.length);\n      }\n    }\n    return new Series(this._series.name, Float64Column.from(results));\n  }\n  padStart(length, fillChar) {\n    return this._mapString((s) => s.padStart(length, fillChar));\n  }\n  padEnd(length, fillChar) {\n    return this._mapString((s) => s.padEnd(length, fillChar));\n  }\n  extract(pattern) {\n    const source = pattern.source;\n    if (!source.includes(\"(\") || source.replace(/\\\\\\(/g, \"\").indexOf(\"(\") === -1) {\n      throw new TypeMismatchError(\n        \"extract() pattern must contain at least one capture group\"\n      );\n    }\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        const match = val.match(pattern);\n        if (match && match[1] !== void 0) {\n          results.push(match[1]);\n        } else {\n          results.push(null);\n        }\n      }\n    }\n    return new Series(this._series.name, Utf8Column.from(results));\n  }\n  _mapString(fn) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(fn(val));\n      }\n    }\n    return new Series(this._series.name, Utf8Column.from(results));\n  }\n  _mapBoolean(fn) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(fn(val));\n      }\n    }\n    return new Series(this._series.name, BooleanColumn.from(results));\n  }\n};\nvar ListColumn = class _ListColumn extends Column {\n  dtype = \"utf8\" /* Utf8 */;\n  _data;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n  }\n  get(index) {\n    if (index < 0 || index >= this._length) {\n      throw new Error(`Index ${index} out of bounds for column of length ${this._length}`);\n    }\n    if (!this._nullMask.get(index)) return null;\n    return this._data[index];\n  }\n  slice(start, end) {\n    const sliced = this._data.slice(start, end);\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.set(i, this._nullMask.get(start + i));\n    }\n    return new _ListColumn(sliced, mask);\n  }\n  clone() {\n    return new _ListColumn(\n      this._data.map((arr) => [...arr]),\n      this._nullMask.clone()\n    );\n  }\n  filter(mask) {\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) indices.push(i);\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const idxArray = [];\n    for (let i = 0; i < indices.length; i++) {\n      idxArray.push(indices[i]);\n    }\n    return this._takeByIndices(idxArray);\n  }\n  estimatedMemoryBytes() {\n    let bytes = this._nullMask.byteLength;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.get(i)) {\n        for (const s of this._data[i]) {\n          bytes += s.length * 2;\n        }\n      }\n    }\n    return bytes;\n  }\n  _takeByIndices(indices) {\n    const data = [];\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data.push(this._data[idx]);\n      mask.set(i, this._nullMask.get(idx));\n    }\n    return new _ListColumn(data, mask);\n  }\n};\n\n// src/accessors/date-accessor.ts\nvar DateAccessor = class {\n  _series;\n  constructor(series) {\n    if (series.dtype !== \"date\" /* Date */) {\n      throw new TypeMismatchError(\n        `DateAccessor requires Series with dtype Date, got '${series.dtype}'`\n      );\n    }\n    this._series = series;\n  }\n  year() {\n    return this._mapNumber((d) => d.getFullYear());\n  }\n  month() {\n    return this._mapNumber((d) => d.getMonth() + 1);\n  }\n  day() {\n    return this._mapNumber((d) => d.getDate());\n  }\n  hour() {\n    return this._mapNumber((d) => d.getHours());\n  }\n  minute() {\n    return this._mapNumber((d) => d.getMinutes());\n  }\n  second() {\n    return this._mapNumber((d) => d.getSeconds());\n  }\n  dayOfWeek() {\n    return this._mapNumber((d) => d.getDay());\n  }\n  dayOfYear() {\n    return this._mapNumber((d) => {\n      const start = new Date(d.getFullYear(), 0, 0);\n      const diff = d.getTime() - start.getTime();\n      const oneDay = 1e3 * 60 * 60 * 24;\n      return Math.floor(diff / oneDay);\n    });\n  }\n  weekNumber() {\n    return this._mapNumber((d) => {\n      const target = new Date(d.getTime());\n      target.setHours(0, 0, 0, 0);\n      target.setDate(target.getDate() + 3 - (target.getDay() + 6) % 7);\n      const jan4 = new Date(target.getFullYear(), 0, 4);\n      const dayDiff = (target.getTime() - jan4.getTime()) / (1e3 * 60 * 60 * 24);\n      return 1 + Math.round((dayDiff - 3 + (jan4.getDay() + 6) % 7) / 7);\n    });\n  }\n  quarter() {\n    return this._mapNumber((d) => Math.floor(d.getMonth() / 3) + 1);\n  }\n  timestamp() {\n    return this._mapNumber((d) => d.getTime());\n  }\n  format(pattern) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(formatDate(val, pattern));\n      }\n    }\n    return new Series(this._series.name, Utf8Column.from(results));\n  }\n  diff(other, unit) {\n    if (other.dtype !== \"date\" /* Date */) {\n      throw new TypeMismatchError(\n        `diff() requires a Date Series, got '${other.dtype}'`\n      );\n    }\n    if (other.length !== this._series.length) {\n      throw new TypeMismatchError(\n        `diff() requires Series of equal length, got ${this._series.length} and ${other.length}`\n      );\n    }\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const a = this._series.get(i);\n      const b = other.get(i);\n      if (a === null || b === null) {\n        results.push(null);\n      } else {\n        results.push(dateDiff(a, b, unit));\n      }\n    }\n    return new Series(this._series.name, Float64Column.from(results));\n  }\n  truncate(unit) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(truncateDate(val, unit));\n      }\n    }\n    return new Series(this._series.name, DateColumn.from(results));\n  }\n  _mapNumber(fn) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(fn(val));\n      }\n    }\n    return new Series(this._series.name, Float64Column.from(results));\n  }\n};\nfunction formatDate(date, pattern) {\n  const pad2 = (n) => String(n).padStart(2, \"0\");\n  const pad4 = (n) => String(n).padStart(4, \"0\");\n  return pattern.replace(\"YYYY\", pad4(date.getFullYear())).replace(\"MM\", pad2(date.getMonth() + 1)).replace(\"DD\", pad2(date.getDate())).replace(\"HH\", pad2(date.getHours())).replace(\"mm\", pad2(date.getMinutes())).replace(\"ss\", pad2(date.getSeconds()));\n}\nfunction dateDiff(a, b, unit) {\n  const msA = a.getTime();\n  const msB = b.getTime();\n  const diffMs = msB - msA;\n  switch (unit) {\n    case \"second\":\n      return diffMs / 1e3;\n    case \"minute\":\n      return diffMs / (1e3 * 60);\n    case \"hour\":\n      return diffMs / (1e3 * 60 * 60);\n    case \"day\":\n      return diffMs / (1e3 * 60 * 60 * 24);\n    case \"month\": {\n      const yearDiff = b.getFullYear() - a.getFullYear();\n      const monthDiff = b.getMonth() - a.getMonth();\n      const dayFrac = (b.getDate() - a.getDate()) / 30;\n      return yearDiff * 12 + monthDiff + dayFrac;\n    }\n    case \"year\": {\n      const yearDiff = b.getFullYear() - a.getFullYear();\n      const monthFrac = (b.getMonth() - a.getMonth()) / 12;\n      const dayFrac = (b.getDate() - a.getDate()) / 365;\n      return yearDiff + monthFrac + dayFrac;\n    }\n  }\n}\nfunction truncateDate(date, unit) {\n  switch (unit) {\n    case \"year\":\n      return new Date(date.getFullYear(), 0, 1);\n    case \"month\":\n      return new Date(date.getFullYear(), date.getMonth(), 1);\n    case \"day\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n    case \"hour\":\n      return new Date(\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours()\n      );\n    case \"minute\":\n      return new Date(\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes()\n      );\n    case \"second\":\n      return new Date(\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds()\n      );\n  }\n}\n\n// src/series.ts\nvar _createDataFrame;\nfunction _registerDataFrameFactory(factory) {\n  _createDataFrame = factory;\n}\nvar Series = class _Series {\n  _name;\n  _column;\n  constructor(name, column) {\n    this._name = name;\n    this._column = column;\n  }\n  get name() {\n    return this._name;\n  }\n  get dtype() {\n    return this._column.dtype;\n  }\n  get length() {\n    return this._column.length;\n  }\n  get nullCount() {\n    return this._column.nullCount;\n  }\n  get column() {\n    return this._column;\n  }\n  get str() {\n    return new StringAccessor(this);\n  }\n  get dt() {\n    return new DateAccessor(this);\n  }\n  get(index) {\n    return this._column.get(index);\n  }\n  toArray() {\n    const result = [];\n    for (let i = 0; i < this._column.length; i++) {\n      result.push(this._column.get(i));\n    }\n    return result;\n  }\n  // Numeric methods — only valid when T extends number\n  sum() {\n    const col2 = this._asNumericColumn();\n    return col2.sum();\n  }\n  mean() {\n    const col2 = this._asNumericColumn();\n    return col2.mean();\n  }\n  min() {\n    const col2 = this._asNumericColumn();\n    return col2.min();\n  }\n  max() {\n    const col2 = this._asNumericColumn();\n    return col2.max();\n  }\n  std() {\n    const col2 = this._asNumericColumn();\n    const m = col2.mean();\n    if (m === null) return null;\n    const validCount = col2.length - col2.nullCount;\n    if (validCount < 2) return null;\n    let sumSqDiff = 0;\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val !== null) {\n        const diff = val - m;\n        sumSqDiff += diff * diff;\n      }\n    }\n    return Math.sqrt(sumSqDiff / (validCount - 1));\n  }\n  median() {\n    const col2 = this._asNumericColumn();\n    const values = [];\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val !== null) {\n        values.push(val);\n      }\n    }\n    if (values.length === 0) return null;\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    }\n    return values[mid];\n  }\n  between(low, high) {\n    const col2 = this._asNumericColumn();\n    const results = [];\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(val >= low && val <= high);\n      }\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  cumSum() {\n    const col2 = this._asNumericColumn();\n    const results = [];\n    let running = 0;\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        running += val;\n        results.push(running);\n      }\n    }\n    return new _Series(this._name, Float64Column.from(results));\n  }\n  abs() {\n    const col2 = this._asNumericColumn();\n    const results = [];\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(Math.abs(val));\n      }\n    }\n    return new _Series(this._name, Float64Column.from(results));\n  }\n  round(decimals = 0) {\n    const col2 = this._asNumericColumn();\n    const factor = Math.pow(10, decimals);\n    const results = [];\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(Math.round(val * factor) / factor);\n      }\n    }\n    return new _Series(this._name, Float64Column.from(results));\n  }\n  // Comparison methods\n  eq(value) {\n    return this._compareScalar(value, (a, b) => a === b);\n  }\n  neq(value) {\n    return this._compareScalar(value, (a, b) => a !== b);\n  }\n  gt(value) {\n    return this._compareScalar(value, (a, b) => a > b);\n  }\n  gte(value) {\n    return this._compareScalar(value, (a, b) => a >= b);\n  }\n  lt(value) {\n    return this._compareScalar(value, (a, b) => a < b);\n  }\n  lte(value) {\n    return this._compareScalar(value, (a, b) => a <= b);\n  }\n  isIn(values) {\n    const set = new Set(values.map((v) => this._toComparable(v)));\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(set.has(this._toComparable(val)));\n      }\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  isNull() {\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      results.push(this._column.get(i) === null);\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  isNotNull() {\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      results.push(this._column.get(i) !== null);\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  fillNull(value) {\n    const values = this.toArray();\n    const filled = values.map((v) => v === null ? value : v);\n    return new _Series(this._name, this._buildColumn(filled));\n  }\n  unique() {\n    const seen = /* @__PURE__ */ new Set();\n    const values = [];\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      const key = val === null ? \"__null__\" : String(this._toComparable(val));\n      if (!seen.has(key)) {\n        seen.add(key);\n        values.push(val);\n      }\n    }\n    return new _Series(this._name, this._buildColumn(values));\n  }\n  nUnique() {\n    const seen = /* @__PURE__ */ new Set();\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      const key = val === null ? \"__null__\" : String(this._toComparable(val));\n      seen.add(key);\n    }\n    return seen.size;\n  }\n  valueCounts() {\n    if (!_createDataFrame) {\n      throw new FrameKitError(\"INVALID_OPERATION\" /* INVALID_OPERATION */, \"DataFrame factory not registered\");\n    }\n    const counts = /* @__PURE__ */ new Map();\n    const order = [];\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      const key = val === null ? \"__null__\" : String(this._toComparable(val));\n      const entry = counts.get(key);\n      if (entry) {\n        entry.count++;\n      } else {\n        counts.set(key, { value: val, count: 1 });\n        order.push(key);\n      }\n    }\n    order.sort((a, b) => counts.get(b).count - counts.get(a).count);\n    const values = [];\n    const countValues = [];\n    for (const key of order) {\n      const entry = counts.get(key);\n      values.push(entry.value);\n      countValues.push(entry.count);\n    }\n    const valueCol = this._buildColumn(values);\n    const countCol = Float64Column.from(countValues);\n    const columns = /* @__PURE__ */ new Map();\n    columns.set(\"value\", valueCol);\n    columns.set(\"count\", countCol);\n    return _createDataFrame(columns, [\"value\", \"count\"]);\n  }\n  cast(dtype) {\n    const values = this.toArray();\n    const converted = values.map((v) => {\n      if (v === null) return null;\n      return this._castValue(v, dtype);\n    });\n    const col2 = buildColumnFromDType(dtype, converted);\n    return new _Series(this._name, col2);\n  }\n  apply(fn) {\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      results.push(fn(this._column.get(i)));\n    }\n    let resultDType = \"f64\" /* Float64 */;\n    for (const r of results) {\n      if (r !== null) {\n        if (typeof r === \"string\") resultDType = \"utf8\" /* Utf8 */;\n        else if (typeof r === \"boolean\") resultDType = \"bool\" /* Boolean */;\n        else if (r instanceof Date) resultDType = \"date\" /* Date */;\n        else resultDType = \"f64\" /* Float64 */;\n        break;\n      }\n    }\n    const col2 = buildColumnFromDType(resultDType, results);\n    return new _Series(this._name, col2);\n  }\n  _asNumericColumn() {\n    if (this._column instanceof Float64Column) return this._column;\n    if (this._column instanceof Int32Column) return this._column;\n    throw new TypeMismatchError(\n      `Cannot perform numeric operation on Series with dtype '${this.dtype}'`\n    );\n  }\n  _compareScalar(value, predicate) {\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(predicate(val, value));\n      }\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  _toComparable(value) {\n    if (value instanceof Date) return value.getTime();\n    return value;\n  }\n  _buildColumn(values) {\n    switch (this._column.dtype) {\n      case \"f64\" /* Float64 */:\n        return Float64Column.from(values);\n      case \"i32\" /* Int32 */:\n        return Int32Column.from(values);\n      case \"utf8\" /* Utf8 */:\n        return Utf8Column.from(values);\n      case \"bool\" /* Boolean */:\n        return BooleanColumn.from(values);\n      case \"date\" /* Date */:\n        return DateColumn.from(values);\n      case \"object\" /* Object */:\n        return ObjectColumn.from(values);\n      default:\n        throw new FrameKitError(\n          \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n          `Unsupported dtype: ${this._column.dtype}`\n        );\n    }\n  }\n  _castValue(value, targetDType) {\n    switch (targetDType) {\n      case \"f64\" /* Float64 */:\n      case \"i32\" /* Int32 */:\n        if (typeof value === \"number\") return value;\n        if (typeof value === \"string\") return Number(value);\n        if (typeof value === \"boolean\") return value ? 1 : 0;\n        if (value instanceof Date) return value.getTime();\n        return Number(value);\n      case \"utf8\" /* Utf8 */:\n        if (value instanceof Date) return value.toISOString();\n        return String(value);\n      case \"bool\" /* Boolean */:\n        return Boolean(value);\n      case \"date\" /* Date */:\n        if (value instanceof Date) return value;\n        if (typeof value === \"number\") return new Date(value);\n        if (typeof value === \"string\") return new Date(value);\n        return new Date(String(value));\n      default:\n        throw new TypeMismatchError(\n          `Cannot cast to dtype '${targetDType}'`\n        );\n    }\n  }\n};\nfunction buildColumnFromDType(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    case \"object\" /* Object */:\n      return ObjectColumn.from(values);\n    default:\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Unsupported dtype for column construction: ${dtype}`\n      );\n  }\n}\n\n// src/expr/expr.ts\nvar Expr = class _Expr {\n  as(name) {\n    return new NamedExpr(this, name);\n  }\n  // Arithmetic\n  add(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"add\");\n  }\n  sub(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"sub\");\n  }\n  mul(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"mul\");\n  }\n  div(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"div\");\n  }\n  mod(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"mod\");\n  }\n  pow(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"pow\");\n  }\n  // Comparison\n  eq(other) {\n    return new ComparisonExpr(this, wrap(other), \"eq\");\n  }\n  neq(other) {\n    return new ComparisonExpr(this, wrap(other), \"neq\");\n  }\n  gt(other) {\n    return new ComparisonExpr(this, wrap(other), \"gt\");\n  }\n  gte(other) {\n    return new ComparisonExpr(this, wrap(other), \"gte\");\n  }\n  lt(other) {\n    return new ComparisonExpr(this, wrap(other), \"lt\");\n  }\n  lte(other) {\n    return new ComparisonExpr(this, wrap(other), \"lte\");\n  }\n  // Logical\n  and(other) {\n    return new LogicalExpr(this, wrapBool(other), \"and\");\n  }\n  or(other) {\n    return new LogicalExpr(this, wrapBool(other), \"or\");\n  }\n  not() {\n    return new NotExpr(this);\n  }\n  // ── Aggregation (returns AggExpr for use in groupBy().agg()) ──\n  _aggColumnName() {\n    const deps = this.dependencies;\n    if (deps.length === 0) {\n      throw new Error(\"Aggregation requires a column reference\");\n    }\n    return deps[0];\n  }\n  sum() {\n    return new SumAggExpr(this._aggColumnName());\n  }\n  mean() {\n    return new MeanAggExpr(this._aggColumnName());\n  }\n  count() {\n    return new CountAggExpr(this._aggColumnName());\n  }\n  countDistinct() {\n    return new CountDistinctAggExpr(this._aggColumnName());\n  }\n  min() {\n    return new MinAggExpr(this._aggColumnName());\n  }\n  max() {\n    return new MaxAggExpr(this._aggColumnName());\n  }\n  std() {\n    return new StdAggExpr(this._aggColumnName());\n  }\n  first() {\n    return new FirstAggExpr(this._aggColumnName());\n  }\n  last() {\n    return new LastAggExpr(this._aggColumnName());\n  }\n  list() {\n    return new ListAggExpr(this._aggColumnName());\n  }\n  mode() {\n    return new ModeAggExpr(this._aggColumnName());\n  }\n  // ── Null handling ──\n  coalesce(...others) {\n    const exprs = others.map((o) => o instanceof _Expr ? o : new LiteralExpr(o));\n    return new CoalesceExpr([this, ...exprs]);\n  }\n  fillNull(value) {\n    const valExpr = value instanceof _Expr ? value : new LiteralExpr(value);\n    return new FillNullExpr(this, valExpr);\n  }\n  isNull() {\n    return new IsNullExpr(this);\n  }\n  isNotNull() {\n    return new IsNotNullExpr(this);\n  }\n};\nvar NamedExpr = class {\n  expr;\n  name;\n  constructor(expr, name) {\n    this.expr = expr;\n    this.name = name;\n  }\n  get dependencies() {\n    return this.expr.dependencies;\n  }\n  toString() {\n    return `${this.expr.toString()} AS ${this.name}`;\n  }\n};\nfunction wrap(value) {\n  if (value instanceof Expr) return value;\n  return new LiteralExpr(value);\n}\nfunction wrapNum(value) {\n  if (value instanceof Expr) return value;\n  return new LiteralExpr(value);\n}\nfunction wrapBool(value) {\n  if (value instanceof Expr) return value;\n  return new LiteralExpr(value);\n}\nfunction buildColumnForValues(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction detectLiteralDType(value) {\n  if (typeof value === \"number\") return \"f64\" /* Float64 */;\n  if (typeof value === \"string\") return \"utf8\" /* Utf8 */;\n  if (typeof value === \"boolean\") return \"bool\" /* Boolean */;\n  if (value instanceof Date) return \"date\" /* Date */;\n  return \"f64\" /* Float64 */;\n}\nvar LiteralExpr = class extends Expr {\n  _value;\n  constructor(value) {\n    super();\n    this._value = value;\n  }\n  get dependencies() {\n    return [];\n  }\n  toString() {\n    if (typeof this._value === \"string\") return `\"${this._value}\"`;\n    if (this._value instanceof Date) return this._value.toISOString();\n    return String(this._value);\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const values = new Array(len).fill(this._value);\n    const dtype = detectLiteralDType(this._value);\n    const col2 = buildColumnForValues(dtype, values);\n    return new Series(\"literal\", col2);\n  }\n};\nvar ColumnExpr = class extends Expr {\n  _name;\n  constructor(name) {\n    super();\n    this._name = name;\n  }\n  get dependencies() {\n    return [this._name];\n  }\n  toString() {\n    return this._name;\n  }\n  evaluate(df2) {\n    return df2.col(this._name);\n  }\n};\nvar ARITH_OP_SYMBOLS = {\n  add: \"+\",\n  sub: \"-\",\n  mul: \"*\",\n  div: \"/\",\n  mod: \"%\",\n  pow: \"**\"\n};\nvar ArithmeticExpr = class extends Expr {\n  _left;\n  _right;\n  _op;\n  constructor(left, right, op) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._op = op;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._left.dependencies, ...this._right.dependencies])];\n  }\n  toString() {\n    return `(${this._left.toString()} ${ARITH_OP_SYMBOLS[this._op]} ${this._right.toString()})`;\n  }\n  evaluate(df2) {\n    const leftSeries = this._left.evaluate(df2);\n    const rightSeries = this._right.evaluate(df2);\n    const len = leftSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const a = leftSeries.get(i);\n      const b = rightSeries.get(i);\n      if (a === null || b === null) {\n        results.push(null);\n      } else {\n        results.push(applyArithOp(a, b, this._op));\n      }\n    }\n    return new Series(\"\", Float64Column.from(results));\n  }\n};\nfunction applyArithOp(a, b, op) {\n  switch (op) {\n    case \"add\":\n      return a + b;\n    case \"sub\":\n      return a - b;\n    case \"mul\":\n      return a * b;\n    case \"div\":\n      return a / b;\n    case \"mod\":\n      return a % b;\n    case \"pow\":\n      return Math.pow(a, b);\n  }\n}\nvar CMP_OP_SYMBOLS = {\n  eq: \"==\",\n  neq: \"!=\",\n  gt: \">\",\n  gte: \">=\",\n  lt: \"<\",\n  lte: \"<=\"\n};\nvar ComparisonExpr = class extends Expr {\n  _left;\n  _right;\n  _op;\n  constructor(left, right, op) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._op = op;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._left.dependencies, ...this._right.dependencies])];\n  }\n  toString() {\n    return `(${this._left.toString()} ${CMP_OP_SYMBOLS[this._op]} ${this._right.toString()})`;\n  }\n  evaluate(df2) {\n    if (this._left instanceof ColumnExpr && this._right instanceof LiteralExpr) {\n      const columnName = this._left.dependencies[0];\n      const literal = this._right._value;\n      const source = df2.col(columnName).column;\n      const len2 = source.length;\n      const results2 = new Array(len2);\n      for (let i = 0; i < len2; i++) {\n        const a = source.get(i);\n        if (a === null || literal === null) {\n          results2[i] = null;\n        } else {\n          results2[i] = applyCmpOp(a, literal, this._op);\n        }\n      }\n      return new Series(\"\", BooleanColumn.from(results2));\n    }\n    if (this._left instanceof LiteralExpr && this._right instanceof ColumnExpr) {\n      const literal = this._left._value;\n      const columnName = this._right.dependencies[0];\n      const source = df2.col(columnName).column;\n      const len2 = source.length;\n      const results2 = new Array(len2);\n      for (let i = 0; i < len2; i++) {\n        const b = source.get(i);\n        if (literal === null || b === null) {\n          results2[i] = null;\n        } else {\n          results2[i] = applyCmpOp(literal, b, this._op);\n        }\n      }\n      return new Series(\"\", BooleanColumn.from(results2));\n    }\n    const leftSeries = this._left.evaluate(df2);\n    const rightSeries = this._right.evaluate(df2);\n    const len = leftSeries.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const a = leftSeries.get(i);\n      const b = rightSeries.get(i);\n      if (a === null || b === null) {\n        results[i] = null;\n      } else {\n        results[i] = applyCmpOp(a, b, this._op);\n      }\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nfunction applyCmpOp(a, b, op) {\n  switch (op) {\n    case \"eq\":\n      return a === b;\n    case \"neq\":\n      return a !== b;\n    case \"gt\":\n      return a > b;\n    case \"gte\":\n      return a >= b;\n    case \"lt\":\n      return a < b;\n    case \"lte\":\n      return a <= b;\n  }\n}\nvar LogicalExpr = class extends Expr {\n  _left;\n  _right;\n  _op;\n  constructor(left, right, op) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._op = op;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._left.dependencies, ...this._right.dependencies])];\n  }\n  toString() {\n    return `(${this._left.toString()} ${this._op.toUpperCase()} ${this._right.toString()})`;\n  }\n  evaluate(df2) {\n    const leftSeries = this._left.evaluate(df2);\n    const rightSeries = this._right.evaluate(df2);\n    const len = leftSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const a = leftSeries.get(i);\n      const b = rightSeries.get(i);\n      if (a === null || b === null) {\n        results.push(null);\n      } else if (this._op === \"and\") {\n        results.push(a && b);\n      } else {\n        results.push(a || b);\n      }\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar NotExpr = class extends Expr {\n  _inner;\n  constructor(inner) {\n    super();\n    this._inner = inner;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `NOT ${this._inner.toString()}`;\n  }\n  evaluate(df2) {\n    const innerSeries = this._inner.evaluate(df2);\n    const len = innerSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const v = innerSeries.get(i);\n      results.push(v === null ? null : !v);\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nfunction col(name) {\n  return new ColumnExpr(name);\n}\nfunction lit(value) {\n  return new LiteralExpr(value);\n}\nfunction toComparableKey(v) {\n  if (v instanceof Date) return `\\0date${v.getTime()}`;\n  if (typeof v === \"string\") return `\\0str${v}`;\n  if (typeof v === \"number\") return `\\0num${v}`;\n  if (typeof v === \"boolean\") return `\\0bool${v}`;\n  return `\\0other${String(v)}`;\n}\nvar AggExpr = class extends Expr {\n  _columnName;\n  constructor(columnName) {\n    super();\n    this._columnName = columnName;\n  }\n  get dependencies() {\n    return [this._columnName];\n  }\n  toString() {\n    return `${this._aggName}(${this._columnName})`;\n  }\n  evaluate(df2) {\n    const result = this.evaluateFrame(df2);\n    const values = [result];\n    const col2 = Float64Column.from(values);\n    return new Series(\"\", col2);\n  }\n  evaluateFrame(df2) {\n    const series = df2.col(this._columnName);\n    return this.evaluateColumn(series.column);\n  }\n};\nvar SumAggExpr = class extends AggExpr {\n  _aggName = \"sum\";\n  evaluateColumn(column) {\n    let total = 0;\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        total += v;\n      }\n    }\n    return total;\n  }\n};\nvar MeanAggExpr = class extends AggExpr {\n  _aggName = \"mean\";\n  evaluateColumn(column) {\n    let total = 0;\n    let count = 0;\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        total += v;\n        count++;\n      }\n    }\n    return count === 0 ? null : total / count;\n  }\n};\nvar CountAggExpr = class extends AggExpr {\n  _aggName = \"count\";\n  evaluateColumn(column) {\n    let count = 0;\n    for (let i = 0; i < column.length; i++) {\n      if (column.get(i) !== null) {\n        count++;\n      }\n    }\n    return count;\n  }\n};\nvar CountDistinctAggExpr = class extends AggExpr {\n  _aggName = \"count_distinct\";\n  evaluateColumn(column) {\n    const seen = /* @__PURE__ */ new Set();\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null) {\n        seen.add(toComparableKey(v));\n      }\n    }\n    return seen.size;\n  }\n};\nvar MinAggExpr = class extends AggExpr {\n  _aggName = \"min\";\n  evaluateColumn(column) {\n    let result = null;\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        if (result === null || v < result) {\n          result = v;\n        }\n      }\n    }\n    return result;\n  }\n};\nvar MaxAggExpr = class extends AggExpr {\n  _aggName = \"max\";\n  evaluateColumn(column) {\n    let result = null;\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        if (result === null || v > result) {\n          result = v;\n        }\n      }\n    }\n    return result;\n  }\n};\nvar StdAggExpr = class extends AggExpr {\n  _aggName = \"std\";\n  evaluateColumn(column) {\n    const values = [];\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        values.push(v);\n      }\n    }\n    if (values.length < 2) return null;\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\n    const sumSqDiff = values.reduce((acc, v) => acc + (v - mean) ** 2, 0);\n    return Math.sqrt(sumSqDiff / (values.length - 1));\n  }\n};\nvar FirstAggExpr = class extends AggExpr {\n  _aggName = \"first\";\n  evaluateColumn(column) {\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null) {\n        return v;\n      }\n    }\n    return null;\n  }\n};\nvar LastAggExpr = class extends AggExpr {\n  _aggName = \"last\";\n  evaluateColumn(column) {\n    for (let i = column.length - 1; i >= 0; i--) {\n      const v = column.get(i);\n      if (v !== null) {\n        return v;\n      }\n    }\n    return null;\n  }\n};\nvar ListAggExpr = class extends AggExpr {\n  _aggName = \"list\";\n  evaluateColumn(column) {\n    const result = [];\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null) {\n        result.push(v);\n      }\n    }\n    return result;\n  }\n};\nvar ModeAggExpr = class extends AggExpr {\n  _aggName = \"mode\";\n  evaluateColumn(column) {\n    const counts = /* @__PURE__ */ new Map();\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null) {\n        const key = toComparableKey(v);\n        const entry = counts.get(key);\n        if (entry) {\n          entry.count++;\n        } else {\n          counts.set(key, { value: v, count: 1 });\n        }\n      }\n    }\n    let best = null;\n    let bestCount = 0;\n    for (const entry of counts.values()) {\n      if (entry.count > bestCount) {\n        best = entry.value;\n        bestCount = entry.count;\n      }\n    }\n    return best;\n  }\n};\nvar CoalesceExpr = class extends Expr {\n  _exprs;\n  constructor(exprs) {\n    super();\n    this._exprs = exprs;\n  }\n  get dependencies() {\n    const deps = /* @__PURE__ */ new Set();\n    for (const e of this._exprs) {\n      for (const d of e.dependencies) {\n        deps.add(d);\n      }\n    }\n    return [...deps];\n  }\n  toString() {\n    return `coalesce(${this._exprs.map((e) => e.toString()).join(\", \")})`;\n  }\n  evaluate(df2) {\n    const evaluated = this._exprs.map((e) => e.evaluate(df2));\n    const len = evaluated[0].length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      let found = null;\n      for (const s of evaluated) {\n        const v = s.get(i);\n        if (v !== null) {\n          found = v;\n          break;\n        }\n      }\n      results.push(found);\n    }\n    const firstSeries = evaluated[0];\n    const dtype = firstSeries.column.dtype;\n    const col2 = buildColumnForValues(dtype, results);\n    return new Series(\"\", col2);\n  }\n};\nvar FillNullExpr = class extends Expr {\n  _inner;\n  _fill;\n  constructor(inner, fill) {\n    super();\n    this._inner = inner;\n    this._fill = fill;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._inner.dependencies, ...this._fill.dependencies])];\n  }\n  toString() {\n    return `fillNull(${this._inner.toString()}, ${this._fill.toString()})`;\n  }\n  evaluate(df2) {\n    const innerSeries = this._inner.evaluate(df2);\n    const fillSeries = this._fill.evaluate(df2);\n    const len = innerSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const v = innerSeries.get(i);\n      results.push(v !== null ? v : fillSeries.get(i));\n    }\n    const dtype = innerSeries.column.dtype;\n    const col2 = buildColumnForValues(dtype, results);\n    return new Series(\"\", col2);\n  }\n};\nvar IsNullExpr = class extends Expr {\n  _inner;\n  constructor(inner) {\n    super();\n    this._inner = inner;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()} IS NULL`;\n  }\n  evaluate(df2) {\n    const innerSeries = this._inner.evaluate(df2);\n    const len = innerSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      results.push(innerSeries.get(i) === null);\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar IsNotNullExpr = class extends Expr {\n  _inner;\n  constructor(inner) {\n    super();\n    this._inner = inner;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()} IS NOT NULL`;\n  }\n  evaluate(df2) {\n    const innerSeries = this._inner.evaluate(df2);\n    const len = innerSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      results.push(innerSeries.get(i) !== null);\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\n\n// src/io/csv/parser.ts\nvar DEFAULT_NULL_VALUES = [\"\", \"null\", \"NULL\", \"NA\", \"N/A\", \"NaN\", \"nan\", \"None\", \"none\"];\nvar CH_QUOTE = 34;\nvar CH_LF = 10;\nvar CH_CR = 13;\nvar CH_COMMA = 44;\nvar CH_SEMI = 59;\nvar CH_TAB = 9;\nvar CH_PIPE = 124;\nfunction parseCSV(content, options = {}) {\n  if (content.length === 0) {\n    return { header: [], columns: {}, inferredTypes: {} };\n  }\n  const comment = options.comment;\n  const hasHeader = options.hasHeader !== false;\n  const nullValues = new Set(options.nullValues ?? DEFAULT_NULL_VALUES);\n  const skipRows = options.skipRows ?? 0;\n  const delimiter = options.delimiter ?? detectDelimiterFast(content);\n  const delimCode = delimiter.charCodeAt(0);\n  const delimLen = delimiter.length;\n  const multiCharDelim = delimLen > 1;\n  let pos = 0;\n  let skipped = 0;\n  while (skipped < skipRows && pos < content.length) {\n    pos = skipLine(content, pos);\n    skipped++;\n  }\n  if (comment) {\n    while (pos < content.length) {\n      let lineStart = pos;\n      while (lineStart < content.length) {\n        const c = content.charCodeAt(lineStart);\n        if (c !== 32 && c !== CH_TAB) break;\n        lineStart++;\n      }\n      if (lineStart < content.length && content.startsWith(comment, lineStart)) {\n        pos = skipLine(content, pos);\n      } else {\n        break;\n      }\n    }\n  }\n  let header;\n  if (options.header) {\n    header = options.header;\n    if (hasHeader) {\n      pos = skipLine(content, pos);\n    }\n  } else if (hasHeader) {\n    const headerResult = parseLineFields(content, pos, delimCode, delimLen, multiCharDelim, delimiter);\n    header = headerResult.fields.map((h) => h.trim());\n    pos = headerResult.nextPos;\n  } else {\n    const peek = parseLineFields(content, pos, delimCode, delimLen, multiCharDelim, delimiter);\n    header = peek.fields.map((_, i) => `column_${i}`);\n  }\n  if (header.length === 0) {\n    return { header: [], columns: {}, inferredTypes: {} };\n  }\n  const selectedColumns = options.columns ? new Set(options.columns) : null;\n  const activeHeader = [];\n  const colIndices = [];\n  for (let i = 0; i < header.length; i++) {\n    const name = header[i];\n    if (selectedColumns && !selectedColumns.has(name)) continue;\n    activeHeader.push(name);\n    colIndices.push(i);\n  }\n  const estimatedRows = Math.max(1, Math.floor(content.length / 40));\n  const columns = {};\n  for (const name of activeHeader) {\n    const arr = [];\n    if (estimatedRows > 1e3) {\n      arr.length = estimatedRows;\n      arr.length = 0;\n    }\n    columns[name] = arr;\n  }\n  const maxRows = options.nRows ?? Infinity;\n  let rowCount = 0;\n  const numActiveCols = activeHeader.length;\n  const allColumns = numActiveCols === header.length;\n  while (pos < content.length && rowCount < maxRows) {\n    if (comment) {\n      let lineStart = pos;\n      while (lineStart < content.length) {\n        const c = content.charCodeAt(lineStart);\n        if (c !== 32 && c !== CH_TAB) break;\n        lineStart++;\n      }\n      if (lineStart < content.length && content.startsWith(comment, lineStart)) {\n        pos = skipLine(content, pos);\n        continue;\n      }\n    }\n    if (content.charCodeAt(pos) === CH_LF || content.charCodeAt(pos) === CH_CR) {\n      pos = skipLine(content, pos);\n      continue;\n    }\n    if (allColumns) {\n      pos = parseRowDirect(content, pos, delimCode, delimLen, multiCharDelim, delimiter, columns, activeHeader, numActiveCols, nullValues);\n    } else {\n      pos = parseRowFiltered(content, pos, delimCode, delimLen, multiCharDelim, delimiter, columns, activeHeader, colIndices, numActiveCols, nullValues);\n    }\n    rowCount++;\n  }\n  const inferredTypes = inferColumnTypes(columns, activeHeader, options);\n  return { header: activeHeader, columns, inferredTypes };\n}\nfunction skipLine(content, pos) {\n  let inQuotes = false;\n  while (pos < content.length) {\n    const ch = content.charCodeAt(pos);\n    if (ch === CH_QUOTE) {\n      inQuotes = !inQuotes;\n    } else if (!inQuotes) {\n      if (ch === CH_CR) {\n        pos++;\n        if (pos < content.length && content.charCodeAt(pos) === CH_LF) pos++;\n        return pos;\n      }\n      if (ch === CH_LF) {\n        return pos + 1;\n      }\n    }\n    pos++;\n  }\n  return pos;\n}\nfunction parseLineFields(content, pos, delimCode, delimLen, multiCharDelim, delimiter) {\n  const fields = [];\n  const len = content.length;\n  while (pos <= len) {\n    if (pos >= len) {\n      fields.push(\"\");\n      break;\n    }\n    const ch = content.charCodeAt(pos);\n    if (ch === CH_CR || ch === CH_LF) {\n      fields.push(\"\");\n      if (ch === CH_CR && pos + 1 < len && content.charCodeAt(pos + 1) === CH_LF) {\n        pos += 2;\n      } else {\n        pos += 1;\n      }\n      return { fields, nextPos: pos };\n    }\n    if (ch === CH_QUOTE) {\n      pos++;\n      const fieldStart = pos;\n      let hasEscape = false;\n      while (pos < len) {\n        const c = content.charCodeAt(pos);\n        if (c === CH_QUOTE) {\n          if (pos + 1 < len && content.charCodeAt(pos + 1) === CH_QUOTE) {\n            hasEscape = true;\n            pos += 2;\n          } else {\n            break;\n          }\n        } else {\n          pos++;\n        }\n      }\n      let value;\n      if (hasEscape) {\n        value = content.substring(fieldStart, pos).replace(/\"\"/g, '\"');\n      } else {\n        value = content.substring(fieldStart, pos);\n      }\n      fields.push(value);\n      if (pos < len) pos++;\n      if (pos < len) {\n        const next = content.charCodeAt(pos);\n        if (next === CH_CR || next === CH_LF) {\n          if (next === CH_CR && pos + 1 < len && content.charCodeAt(pos + 1) === CH_LF) {\n            pos += 2;\n          } else {\n            pos += 1;\n          }\n          return { fields, nextPos: pos };\n        }\n        if (multiCharDelim ? content.startsWith(delimiter, pos) : next === delimCode) {\n          pos += delimLen;\n        }\n      }\n    } else {\n      const fieldStart = pos;\n      while (pos < len) {\n        const c2 = content.charCodeAt(pos);\n        if (c2 === CH_CR || c2 === CH_LF) break;\n        if (multiCharDelim ? content.startsWith(delimiter, pos) : c2 === delimCode) break;\n        pos++;\n      }\n      fields.push(content.substring(fieldStart, pos));\n      if (pos >= len) {\n        return { fields, nextPos: pos };\n      }\n      const c = content.charCodeAt(pos);\n      if (c === CH_CR || c === CH_LF) {\n        if (c === CH_CR && pos + 1 < len && content.charCodeAt(pos + 1) === CH_LF) {\n          pos += 2;\n        } else {\n          pos += 1;\n        }\n        return { fields, nextPos: pos };\n      }\n      pos += delimLen;\n    }\n  }\n  return { fields, nextPos: pos };\n}\nfunction parseRowDirect(content, pos, delimCode, delimLen, multiCharDelim, delimiter, columns, activeHeader, numCols, nullValues) {\n  const len = content.length;\n  let colIdx = 0;\n  while (pos < len && colIdx <= numCols) {\n    const ch = content.charCodeAt(pos);\n    if (ch === CH_CR || ch === CH_LF) {\n      while (colIdx < numCols) {\n        columns[activeHeader[colIdx]].push(null);\n        colIdx++;\n      }\n      if (ch === CH_CR && pos + 1 < len && content.charCodeAt(pos + 1) === CH_LF) {\n        return pos + 2;\n      }\n      return pos + 1;\n    }\n    if (colIdx >= numCols) {\n      return skipToEOL(content, pos);\n    }\n    if (ch === CH_QUOTE) {\n      pos++;\n      const fieldStart = pos;\n      let hasEscape = false;\n      while (pos < len) {\n        const c = content.charCodeAt(pos);\n        if (c === CH_QUOTE) {\n          if (pos + 1 < len && content.charCodeAt(pos + 1) === CH_QUOTE) {\n            hasEscape = true;\n            pos += 2;\n          } else {\n            break;\n          }\n        } else {\n          pos++;\n        }\n      }\n      let value;\n      if (hasEscape) {\n        value = content.substring(fieldStart, pos).replace(/\"\"/g, '\"');\n      } else {\n        value = content.substring(fieldStart, pos);\n      }\n      if (pos < len) pos++;\n      const colArr = columns[activeHeader[colIdx]];\n      colArr.push(nullValues.has(value) ? null : value);\n      colIdx++;\n      if (pos < len) {\n        const next = content.charCodeAt(pos);\n        if (next === CH_CR || next === CH_LF) continue;\n        if (multiCharDelim ? content.startsWith(delimiter, pos) : next === delimCode) {\n          pos += delimLen;\n        }\n      }\n    } else {\n      const fieldStart = pos;\n      while (pos < len) {\n        const c2 = content.charCodeAt(pos);\n        if (c2 === CH_CR || c2 === CH_LF) break;\n        if (multiCharDelim ? content.startsWith(delimiter, pos) : c2 === delimCode) break;\n        pos++;\n      }\n      const value = content.substring(fieldStart, pos);\n      const colArr = columns[activeHeader[colIdx]];\n      colArr.push(nullValues.has(value) ? null : value);\n      colIdx++;\n      if (pos >= len) break;\n      const c = content.charCodeAt(pos);\n      if (c === CH_CR || c === CH_LF) continue;\n      pos += delimLen;\n    }\n  }\n  while (colIdx < numCols) {\n    columns[activeHeader[colIdx]].push(null);\n    colIdx++;\n  }\n  return pos;\n}\nfunction parseRowFiltered(content, pos, delimCode, delimLen, multiCharDelim, delimiter, columns, activeHeader, colIndices, numActiveCols, nullValues) {\n  const len = content.length;\n  let fieldIdx = 0;\n  let activeIdx = 0;\n  const nextWanted = colIndices[0] ?? -1;\n  let currentWanted = nextWanted;\n  while (pos < len) {\n    const ch = content.charCodeAt(pos);\n    if (ch === CH_CR || ch === CH_LF) {\n      while (activeIdx < numActiveCols) {\n        columns[activeHeader[activeIdx]].push(null);\n        activeIdx++;\n      }\n      if (ch === CH_CR && pos + 1 < len && content.charCodeAt(pos + 1) === CH_LF) {\n        return pos + 2;\n      }\n      return pos + 1;\n    }\n    const wanted = fieldIdx === currentWanted;\n    if (ch === CH_QUOTE) {\n      pos++;\n      if (wanted) {\n        const fieldStart = pos;\n        let hasEscape = false;\n        while (pos < len) {\n          const c2 = content.charCodeAt(pos);\n          if (c2 === CH_QUOTE) {\n            if (pos + 1 < len && content.charCodeAt(pos + 1) === CH_QUOTE) {\n              hasEscape = true;\n              pos += 2;\n            } else {\n              break;\n            }\n          } else {\n            pos++;\n          }\n        }\n        let value;\n        if (hasEscape) {\n          value = content.substring(fieldStart, pos).replace(/\"\"/g, '\"');\n        } else {\n          value = content.substring(fieldStart, pos);\n        }\n        if (pos < len) pos++;\n        columns[activeHeader[activeIdx]].push(nullValues.has(value) ? null : value);\n        activeIdx++;\n        currentWanted = activeIdx < numActiveCols ? colIndices[activeIdx] : -1;\n      } else {\n        while (pos < len) {\n          const c2 = content.charCodeAt(pos);\n          if (c2 === CH_QUOTE) {\n            if (pos + 1 < len && content.charCodeAt(pos + 1) === CH_QUOTE) {\n              pos += 2;\n            } else {\n              pos++;\n              break;\n            }\n          } else {\n            pos++;\n          }\n        }\n      }\n    } else {\n      const fieldStart = pos;\n      while (pos < len) {\n        const c2 = content.charCodeAt(pos);\n        if (c2 === CH_CR || c2 === CH_LF) break;\n        if (multiCharDelim ? content.startsWith(delimiter, pos) : c2 === delimCode) break;\n        pos++;\n      }\n      if (wanted) {\n        const value = content.substring(fieldStart, pos);\n        columns[activeHeader[activeIdx]].push(nullValues.has(value) ? null : value);\n        activeIdx++;\n        currentWanted = activeIdx < numActiveCols ? colIndices[activeIdx] : -1;\n      }\n    }\n    fieldIdx++;\n    if (pos >= len) break;\n    const c = content.charCodeAt(pos);\n    if (c === CH_CR || c === CH_LF) continue;\n    if (multiCharDelim ? content.startsWith(delimiter, pos) : c === delimCode) {\n      pos += delimLen;\n    }\n  }\n  while (activeIdx < numActiveCols) {\n    columns[activeHeader[activeIdx]].push(null);\n    activeIdx++;\n  }\n  return pos;\n}\nfunction skipToEOL(content, pos) {\n  let inQuotes = false;\n  const len = content.length;\n  while (pos < len) {\n    const ch = content.charCodeAt(pos);\n    if (ch === CH_QUOTE) {\n      inQuotes = !inQuotes;\n    } else if (!inQuotes) {\n      if (ch === CH_CR) {\n        pos++;\n        if (pos < len && content.charCodeAt(pos) === CH_LF) pos++;\n        return pos;\n      }\n      if (ch === CH_LF) {\n        return pos + 1;\n      }\n    }\n    pos++;\n  }\n  return pos;\n}\nfunction detectDelimiterFast(content) {\n  const candidates = [CH_COMMA, CH_SEMI, CH_TAB, CH_PIPE];\n  const candidateStrs = [\",\", \";\", \"\t\", \"|\"];\n  const maxLines = 10;\n  let bestDelimiter = \",\";\n  let bestScore = -1;\n  for (let ci = 0; ci < candidates.length; ci++) {\n    const delimCode = candidates[ci];\n    const counts = [];\n    let pos = 0;\n    let lineIdx = 0;\n    while (pos < content.length && lineIdx < maxLines) {\n      let count = 0;\n      let inQuotes = false;\n      while (pos < content.length) {\n        const ch = content.charCodeAt(pos);\n        if (ch === CH_QUOTE) {\n          inQuotes = !inQuotes;\n        } else if (!inQuotes) {\n          if (ch === delimCode) count++;\n          if (ch === CH_CR || ch === CH_LF) {\n            if (ch === CH_CR && pos + 1 < content.length && content.charCodeAt(pos + 1) === CH_LF) {\n              pos++;\n            }\n            pos++;\n            break;\n          }\n        }\n        pos++;\n      }\n      counts.push(count);\n      lineIdx++;\n    }\n    if (counts.length === 0) continue;\n    const avg = counts.reduce((a, b) => a + b, 0) / counts.length;\n    if (avg === 0) continue;\n    const allSame = counts.every((c) => c === counts[0]);\n    const score = allSame ? avg * 2 : avg;\n    if (score > bestScore) {\n      bestScore = score;\n      bestDelimiter = candidateStrs[ci];\n    }\n  }\n  return bestDelimiter;\n}\nfunction inferColumnTypes(columns, header, options) {\n  const types = {};\n  const parseNumbers = options.parseNumbers !== false;\n  const parseDates = options.parseDates !== false;\n  for (const name of header) {\n    if (options.dtypes && name in options.dtypes) {\n      types[name] = options.dtypes[name];\n      continue;\n    }\n    const values = columns[name];\n    const sample = values.slice(0, 100).filter((v) => v !== null);\n    if (sample.length === 0) {\n      types[name] = \"utf8\" /* Utf8 */;\n      continue;\n    }\n    if (parseNumbers && sample.every(isNumericString)) {\n      types[name] = sample.every(isIntegerString) ? \"i32\" /* Int32 */ : \"f64\" /* Float64 */;\n      continue;\n    }\n    if (sample.every(isBooleanString)) {\n      types[name] = \"bool\" /* Boolean */;\n      continue;\n    }\n    if (parseDates && sample.every(isDateString)) {\n      types[name] = \"date\" /* Date */;\n      continue;\n    }\n    types[name] = \"utf8\" /* Utf8 */;\n  }\n  return types;\n}\nfunction isNumericString(s) {\n  if (s.length === 0) return false;\n  const n = Number(s);\n  return !Number.isNaN(n) && s.trim().length > 0;\n}\nfunction isIntegerString(s) {\n  if (!isNumericString(s)) return false;\n  const n = Number(s);\n  return Number.isInteger(n) && !s.includes(\".\") && !s.includes(\"e\") && !s.includes(\"E\");\n}\nfunction isBooleanString(s) {\n  const lower = s.toLowerCase();\n  return lower === \"true\" || lower === \"false\";\n}\nvar ISO_DATE_RE = /^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}(:\\d{2})?(\\.\\d+)?(Z|[+-]\\d{2}:?\\d{2})?)?$/;\nfunction isDateString(s) {\n  if (!ISO_DATE_RE.test(s)) return false;\n  const d = new Date(s);\n  return !Number.isNaN(d.getTime());\n}\n\n// src/io/csv/writer.ts\nfunction writeCSV(header, rows, options = {}) {\n  const delimiter = options.delimiter ?? \",\";\n  const quoteStyle = options.quoteStyle ?? \"necessary\";\n  const nullValue = options.nullValue ?? \"\";\n  const includeHeader = options.header !== false;\n  const bom = options.bom === true;\n  const lines = [];\n  if (bom) {\n    lines.push(\"\\uFEFF\");\n  }\n  if (includeHeader) {\n    lines.push(header.map((h) => quoteField(h, delimiter, quoteStyle)).join(delimiter));\n  }\n  for (const row of rows) {\n    const fields = row.map((value) => {\n      if (value === null || value === void 0) {\n        return quoteField(nullValue, delimiter, quoteStyle);\n      }\n      if (value instanceof Date) {\n        return quoteField(value.toISOString(), delimiter, quoteStyle);\n      }\n      if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n        return quoteField(String(value), delimiter, quoteStyle);\n      }\n      return quoteField(JSON.stringify(value), delimiter, quoteStyle);\n    });\n    lines.push(fields.join(delimiter));\n  }\n  return lines.join(\"\\n\") + \"\\n\";\n}\nfunction quoteField(value, delimiter, quoteStyle) {\n  if (quoteStyle === \"never\") {\n    return value;\n  }\n  if (quoteStyle === \"always\") {\n    return '\"' + value.replace(/\"/g, '\"\"') + '\"';\n  }\n  if (value.includes(delimiter) || value.includes('\"') || value.includes(\"\\n\") || value.includes(\"\\r\")) {\n    return '\"' + value.replace(/\"/g, '\"\"') + '\"';\n  }\n  return value;\n}\n\n// src/engine/streaming/scanner.ts\nvar DEFAULT_NULL_VALUES2 = [\"\", \"null\", \"NULL\", \"NA\", \"N/A\", \"NaN\", \"nan\", \"None\", \"none\"];\nasync function* streamCSVFile(filePath, options = {}) {\n  const chunkSize = options.chunkSize ?? 1e4;\n  const fs = await import(\"fs\");\n  const { createReadStream } = fs;\n  let stream;\n  try {\n    stream = createReadStream(filePath, { encoding: options.encoding ?? \"utf-8\" });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to open CSV file '${filePath}': ${message}`);\n  }\n  const hasHeader = options.hasHeader !== false;\n  const nullValues = new Set(options.nullValues ?? DEFAULT_NULL_VALUES2);\n  const comment = options.comment;\n  const skipRows = options.skipRows ?? 0;\n  let schema = null;\n  let buffer = \"\";\n  let inQuotes = false;\n  let pendingLines = [];\n  let linesSkipped = 0;\n  let headerConsumed = false;\n  let chunkRows = {};\n  let rowCount = 0;\n  let totalRowsEmitted = 0;\n  const nRows = options.nRows;\n  function parseLine(line, delimiter) {\n    const fields = [];\n    let current = \"\";\n    let quoted = false;\n    let i = 0;\n    while (i < line.length) {\n      const ch = line[i];\n      if (quoted) {\n        if (ch === '\"') {\n          if (i + 1 < line.length && line[i + 1] === '\"') {\n            current += '\"';\n            i += 2;\n          } else {\n            quoted = false;\n            i++;\n          }\n        } else {\n          current += ch;\n          i++;\n        }\n      } else {\n        if (ch === '\"' && current.length === 0) {\n          quoted = true;\n          i++;\n        } else if (line.startsWith(delimiter, i)) {\n          fields.push(current);\n          current = \"\";\n          i += delimiter.length;\n        } else {\n          current += ch;\n          i++;\n        }\n      }\n    }\n    if (quoted) {\n      throw new ParseError(\"Unterminated quoted field in CSV\");\n    }\n    fields.push(current);\n    return fields;\n  }\n  function detectDelimiter(lines) {\n    const candidates = [\",\", \";\", \"\t\", \"|\"];\n    let bestDelimiter = \",\";\n    let bestScore = -1;\n    for (const delim of candidates) {\n      const counts = lines.map((line) => {\n        let count = 0;\n        let q = false;\n        for (let i = 0; i < line.length; i++) {\n          const ch = line[i];\n          if (ch === '\"') q = !q;\n          else if (!q && line.startsWith(delim, i)) count++;\n        }\n        return count;\n      });\n      if (counts.length === 0) continue;\n      const avg = counts.reduce((a, b) => a + b, 0) / counts.length;\n      if (avg === 0) continue;\n      const allSame = counts.every((c) => c === counts[0]);\n      const score = allSame ? avg * 2 : avg;\n      if (score > bestScore) {\n        bestScore = score;\n        bestDelimiter = delim;\n      }\n    }\n    return bestDelimiter;\n  }\n  function inferTypes(columns, header, opts) {\n    const types = {};\n    const parseNumbers = opts.parseNumbers !== false;\n    const parseDates = opts.parseDates !== false;\n    for (const name of header) {\n      if (opts.dtypes && name in opts.dtypes) {\n        types[name] = opts.dtypes[name];\n        continue;\n      }\n      const values = columns[name];\n      const sample = values.slice(0, 100).filter((v) => v !== null);\n      if (sample.length === 0) {\n        types[name] = \"utf8\" /* Utf8 */;\n        continue;\n      }\n      if (parseNumbers && sample.every(isNumericString2)) {\n        types[name] = sample.every(isIntegerString2) ? \"i32\" /* Int32 */ : \"f64\" /* Float64 */;\n        continue;\n      }\n      if (sample.every(isBooleanString2)) {\n        types[name] = \"bool\" /* Boolean */;\n        continue;\n      }\n      if (parseDates && sample.every(isDateString2)) {\n        types[name] = \"date\" /* Date */;\n        continue;\n      }\n      types[name] = \"utf8\" /* Utf8 */;\n    }\n    return types;\n  }\n  function initChunkRows(header) {\n    const cols = {};\n    for (const name of header) {\n      cols[name] = [];\n    }\n    return cols;\n  }\n  function addRowToChunk(fields, schema2) {\n    for (let i = 0; i < schema2.header.length; i++) {\n      const name = schema2.header[i];\n      const raw = i < fields.length ? fields[i] : \"\";\n      const value = schema2.nullValues.has(raw) ? null : raw;\n      chunkRows[name].push(value);\n    }\n    rowCount++;\n  }\n  let parsedHeader = null;\n  let detectedDelimiter = null;\n  function processLine(line) {\n    if (comment && line.trimStart().startsWith(comment)) {\n      return null;\n    }\n    if (linesSkipped < skipRows) {\n      linesSkipped++;\n      return null;\n    }\n    if (!headerConsumed) {\n      detectedDelimiter = options.delimiter ?? detectDelimiter([line]);\n      if (options.header) {\n        parsedHeader = options.header;\n        pendingLines.push(line);\n      } else if (hasHeader) {\n        parsedHeader = parseLine(line, detectedDelimiter).map((h) => h.trim());\n      } else {\n        const firstFields = parseLine(line, detectedDelimiter);\n        parsedHeader = firstFields.map((_, i) => `column_${i}`);\n        pendingLines.push(line);\n      }\n      headerConsumed = true;\n      return null;\n    }\n    if (!schema) {\n      pendingLines.push(line);\n      const delimiter = detectedDelimiter;\n      const header = parsedHeader;\n      const tempCols = initChunkRows(header);\n      for (const pl of pendingLines) {\n        const fields2 = parseLine(pl, delimiter);\n        for (let i = 0; i < header.length; i++) {\n          const name = header[i];\n          const raw = i < fields2.length ? fields2[i] : \"\";\n          const value = nullValues.has(raw) ? null : raw;\n          tempCols[name].push(value);\n        }\n      }\n      const inferredTypes = inferTypes(tempCols, header, options);\n      schema = { header, delimiter, nullValues, inferredTypes };\n      chunkRows = initChunkRows(header);\n      for (const pl of pendingLines) {\n        const fields2 = parseLine(pl, delimiter);\n        addRowToChunk(fields2, schema);\n      }\n      pendingLines = [];\n      if (rowCount >= chunkSize) {\n        const result = { header: schema.header, rawColumns: chunkRows, inferredTypes: schema.inferredTypes };\n        chunkRows = initChunkRows(schema.header);\n        totalRowsEmitted += rowCount;\n        rowCount = 0;\n        return result;\n      }\n      return null;\n    }\n    const fields = parseLine(line, schema.delimiter);\n    addRowToChunk(fields, schema);\n    if (rowCount >= chunkSize) {\n      const result = { header: schema.header, rawColumns: chunkRows, inferredTypes: schema.inferredTypes };\n      chunkRows = initChunkRows(schema.header);\n      totalRowsEmitted += rowCount;\n      rowCount = 0;\n      return result;\n    }\n    return null;\n  }\n  for await (const rawChunk of stream) {\n    buffer += rawChunk;\n    let lineStart = 0;\n    for (let i = 0; i < buffer.length; i++) {\n      const ch = buffer[i];\n      if (ch === '\"') {\n        inQuotes = !inQuotes;\n      } else if (!inQuotes && (ch === \"\\n\" || ch === \"\\r\")) {\n        const line = buffer.slice(lineStart, i);\n        if (ch === \"\\r\" && i + 1 < buffer.length && buffer[i + 1] === \"\\n\") {\n          i++;\n        }\n        lineStart = i + 1;\n        if (line.length > 0) {\n          if (nRows !== void 0 && totalRowsEmitted + rowCount >= nRows) {\n            break;\n          }\n          const result = processLine(line);\n          if (result) {\n            yield result;\n            if (nRows !== void 0 && totalRowsEmitted >= nRows) {\n              stream.destroy();\n              return;\n            }\n          }\n        }\n      }\n    }\n    buffer = buffer.slice(lineStart);\n    if (nRows !== void 0 && totalRowsEmitted >= nRows) {\n      stream.destroy();\n      return;\n    }\n  }\n  if (buffer.length > 0 && !(nRows !== void 0 && totalRowsEmitted >= nRows)) {\n    if (!comment || !buffer.trimStart().startsWith(comment)) {\n      processLine(buffer);\n    }\n  }\n  const finalSchema = schema;\n  if (rowCount > 0 && finalSchema !== null) {\n    if (nRows !== void 0) {\n      const remaining = nRows - totalRowsEmitted;\n      if (remaining <= 0) return;\n      if (remaining < rowCount) {\n        for (const name of finalSchema.header) {\n          chunkRows[name] = chunkRows[name].slice(0, remaining);\n        }\n      }\n    }\n    yield { header: finalSchema.header, rawColumns: chunkRows, inferredTypes: finalSchema.inferredTypes };\n  }\n}\nfunction isNumericString2(s) {\n  if (s.length === 0) return false;\n  const n = Number(s);\n  return !Number.isNaN(n) && s.trim().length > 0;\n}\nfunction isIntegerString2(s) {\n  if (!isNumericString2(s)) return false;\n  const n = Number(s);\n  return Number.isInteger(n) && !s.includes(\".\") && !s.includes(\"e\") && !s.includes(\"E\");\n}\nfunction isBooleanString2(s) {\n  const lower = s.toLowerCase();\n  return lower === \"true\" || lower === \"false\";\n}\nvar ISO_DATE_RE2 = /^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}(:\\d{2})?(\\.\\d+)?(Z|[+-]\\d{2}:?\\d{2})?)?$/;\nfunction isDateString2(s) {\n  if (!ISO_DATE_RE2.test(s)) return false;\n  const d = new Date(s);\n  return !Number.isNaN(d.getTime());\n}\n\n// src/engine/streaming/ndjson-scanner.ts\nasync function* streamNDJSONFile(filePath, options = {}) {\n  const chunkSize = options.chunkSize ?? 1e4;\n  const nRows = options.nRows;\n  const fs = await import(\"fs\");\n  const { createReadStream } = fs;\n  let stream;\n  try {\n    stream = createReadStream(filePath, { encoding: options.encoding ?? \"utf-8\" });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to open NDJSON file '${filePath}': ${message}`);\n  }\n  let buffer = \"\";\n  let chunk = [];\n  let totalEmitted = 0;\n  for await (const rawChunk of stream) {\n    buffer += rawChunk;\n    let lineStart = 0;\n    for (let i = 0; i < buffer.length; i++) {\n      const ch = buffer[i];\n      if (ch === \"\\n\" || ch === \"\\r\") {\n        const line = buffer.slice(lineStart, i);\n        if (ch === \"\\r\" && i + 1 < buffer.length && buffer[i + 1] === \"\\n\") {\n          i++;\n        }\n        lineStart = i + 1;\n        if (line.trim().length > 0) {\n          chunk.push(JSON.parse(line));\n          if (chunk.length >= chunkSize) {\n            yield chunk;\n            totalEmitted += chunk.length;\n            chunk = [];\n            if (nRows !== void 0 && totalEmitted >= nRows) {\n              stream.destroy();\n              return;\n            }\n          }\n        }\n      }\n    }\n    buffer = buffer.slice(lineStart);\n  }\n  if (buffer.trim().length > 0) {\n    chunk.push(JSON.parse(buffer));\n  }\n  if (chunk.length > 0) {\n    if (nRows !== void 0) {\n      const remaining = nRows - totalEmitted;\n      if (remaining <= 0) return;\n      if (remaining < chunk.length) {\n        chunk = chunk.slice(0, remaining);\n      }\n    }\n    yield chunk;\n  }\n}\n\n// src/io/json/writer.ts\nfunction writeJSON(header, rows, options = {}) {\n  const objects = [];\n  for (const row of rows) {\n    const obj = {};\n    for (let i = 0; i < header.length; i++) {\n      const value = row[i];\n      if (value instanceof Date) {\n        obj[header[i]] = value.toISOString();\n      } else {\n        obj[header[i]] = value ?? null;\n      }\n    }\n    objects.push(obj);\n  }\n  if (options.pretty) {\n    return JSON.stringify(objects, null, 2);\n  }\n  return JSON.stringify(objects);\n}\nfunction writeNDJSON(header, rows) {\n  const lines = [];\n  for (const row of rows) {\n    const obj = {};\n    for (let i = 0; i < header.length; i++) {\n      const value = row[i];\n      if (value instanceof Date) {\n        obj[header[i]] = value.toISOString();\n      } else {\n        obj[header[i]] = value ?? null;\n      }\n    }\n    lines.push(JSON.stringify(obj));\n  }\n  return lines.join(\"\\n\") + \"\\n\";\n}\n\n// src/io/excel/reader.ts\nfunction detectCellDType(value) {\n  if (value === null || value === void 0) return \"f64\" /* Float64 */;\n  if (typeof value === \"number\") return \"f64\" /* Float64 */;\n  if (typeof value === \"boolean\") return \"bool\" /* Boolean */;\n  if (value instanceof Date) return \"date\" /* Date */;\n  if (typeof value === \"string\") return \"utf8\" /* Utf8 */;\n  if (typeof value === \"object\") return \"object\" /* Object */;\n  return \"utf8\" /* Utf8 */;\n}\nfunction parseCellRef(ref) {\n  const match = /^([A-Z]+)(\\d+)$/.exec(ref.toUpperCase());\n  if (!match) throw new IOError(`Invalid cell reference: '${ref}'`);\n  const colStr = match[1];\n  const rowNum = parseInt(match[2], 10);\n  let colNum = 0;\n  for (let i = 0; i < colStr.length; i++) {\n    colNum = colNum * 26 + (colStr.charCodeAt(i) - 64);\n  }\n  return { col: colNum, row: rowNum };\n}\nfunction parseRange(range) {\n  const parts = range.split(\":\");\n  if (parts.length !== 2) throw new IOError(`Invalid range format: '${range}'. Expected format like 'A1:G100'`);\n  const start = parseCellRef(parts[0]);\n  const end = parseCellRef(parts[1]);\n  return { startCol: start.col, startRow: start.row, endCol: end.col, endRow: end.row };\n}\nfunction getWorksheet(workbook, sheet) {\n  if (sheet === void 0 || sheet === 0) {\n    const ws2 = workbook.worksheets[0];\n    if (!ws2) throw new IOError(\"Workbook contains no worksheets\");\n    return ws2;\n  }\n  if (typeof sheet === \"number\") {\n    const ws2 = workbook.worksheets[sheet];\n    if (!ws2) throw new IOError(`Worksheet at index ${String(sheet)} not found`);\n    return ws2;\n  }\n  const ws = workbook.getWorksheet(sheet);\n  if (!ws) throw new IOError(`Worksheet '${sheet}' not found`);\n  return ws;\n}\nfunction normalizeCellValue(value) {\n  if (value === null || value === void 0) return null;\n  if (typeof value === \"object\" && value !== null && !Array.isArray(value) && !(value instanceof Date)) {\n    if (\"richText\" in value) {\n      return value.richText.map((t) => String(t.text)).join(\"\");\n    }\n    if (\"result\" in value) {\n      return value.result;\n    }\n  }\n  return value;\n}\nfunction parseExcelWorksheet(worksheet, options = {}) {\n  const hasHeader = options.hasHeader !== false;\n  const rangeDef = options.range;\n  let startRow;\n  let endRow;\n  let startCol;\n  let endCol;\n  if (rangeDef) {\n    const r = parseRange(rangeDef);\n    startRow = r.startRow;\n    endRow = r.endRow;\n    startCol = r.startCol;\n    endCol = r.endCol;\n  } else {\n    startRow = 1;\n    endRow = worksheet.rowCount;\n    startCol = 1;\n    endCol = worksheet.columnCount;\n  }\n  if (endRow < startRow || endCol < startCol) {\n    return { header: [], columns: {}, inferredTypes: {} };\n  }\n  const rawRows = [];\n  for (let r = startRow; r <= endRow; r++) {\n    const row = worksheet.getRow(r);\n    const rowValues = [];\n    for (let c = startCol; c <= endCol; c++) {\n      const cell = row.getCell(c);\n      rowValues.push(normalizeCellValue(cell.value));\n    }\n    rawRows.push(rowValues);\n  }\n  let header;\n  let dataStartIdx;\n  if (hasHeader && rawRows.length > 0) {\n    header = rawRows[0].map((v, i) => {\n      if (v === null || v === void 0) return `column_${String(i)}`;\n      if (typeof v === \"string\") return v;\n      if (typeof v === \"number\" || typeof v === \"boolean\" || typeof v === \"bigint\") return String(v);\n      if (v instanceof Date) return v.toISOString();\n      return `column_${String(i)}`;\n    });\n    dataStartIdx = 1;\n  } else {\n    const colCount = endCol - startCol + 1;\n    header = Array.from({ length: colCount }, (_, i) => `column_${String(i)}`);\n    dataStartIdx = 0;\n  }\n  const columns = {};\n  for (const name of header) {\n    columns[name] = [];\n  }\n  for (let i = dataStartIdx; i < rawRows.length; i++) {\n    const row = rawRows[i];\n    for (let j = 0; j < header.length; j++) {\n      const colName = header[j];\n      columns[colName].push(j < row.length ? row[j] ?? null : null);\n    }\n  }\n  const inferredTypes = {};\n  for (const name of header) {\n    if (options.dtypes?.[name] !== void 0) {\n      inferredTypes[name] = options.dtypes[name];\n    } else {\n      const colValues = columns[name];\n      let detected = \"f64\" /* Float64 */;\n      for (const v of colValues) {\n        if (v !== null && v !== void 0) {\n          detected = detectCellDType(v);\n          break;\n        }\n      }\n      inferredTypes[name] = detected;\n    }\n  }\n  return { header, columns, inferredTypes };\n}\nasync function readExcelFile(filePath, options = {}) {\n  let ExcelJS;\n  try {\n    ExcelJS = await import(\"exceljs\");\n  } catch {\n    throw new IOError(\n      \"exceljs is required to read Excel files but is not installed. Run: npm install exceljs\"\n    );\n  }\n  try {\n    const workbook = new ExcelJS.Workbook();\n    await workbook.xlsx.readFile(filePath);\n    const worksheet = getWorksheet(workbook, options.sheet);\n    return parseExcelWorksheet(worksheet, options);\n  } catch (err) {\n    if (err instanceof IOError) throw err;\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to read Excel file '${filePath}': ${message}`);\n  }\n}\n\n// src/io/parquet/reader.ts\nfunction arrowTypeToDType(field) {\n  const typeStr = field.type?.toString?.() ?? String(field.type);\n  const lower = typeStr.toLowerCase();\n  if (lower.includes(\"int32\") || lower.includes(\"int16\") || lower.includes(\"int8\")) {\n    return \"i32\" /* Int32 */;\n  }\n  if (lower.includes(\"int64\") || lower.includes(\"int\") || lower.includes(\"uint\")) {\n    return \"f64\" /* Float64 */;\n  }\n  if (lower.includes(\"float\") || lower.includes(\"double\") || lower.includes(\"decimal\")) {\n    return \"f64\" /* Float64 */;\n  }\n  if (lower.includes(\"utf8\") || lower.includes(\"string\") || lower.includes(\"largestring\") || lower.includes(\"largeutf8\")) {\n    return \"utf8\" /* Utf8 */;\n  }\n  if (lower === \"bool\" || lower.includes(\"boolean\")) {\n    return \"bool\" /* Boolean */;\n  }\n  if (lower.includes(\"date\") || lower.includes(\"timestamp\")) {\n    return \"date\" /* Date */;\n  }\n  return \"utf8\" /* Utf8 */;\n}\nfunction extractColumnValues(column, dtype, length) {\n  const values = [];\n  for (let i = 0; i < length; i++) {\n    if (column.isValid(i) === false) {\n      values.push(null);\n      continue;\n    }\n    let val = column.get(i);\n    if (typeof val === \"bigint\") {\n      val = Number(val);\n    }\n    if (dtype === \"date\" /* Date */ && typeof val === \"number\") {\n      val = new Date(val);\n    }\n    values.push(val);\n  }\n  return values;\n}\nasync function readParquetFile(filePath, options = {}) {\n  let parquetWasm;\n  try {\n    const moduleName = \"parquet-wasm\";\n    parquetWasm = await import(moduleName);\n  } catch {\n    throw new IOError(\n      \"parquet-wasm is required to read Parquet files but is not installed. Run: npm install parquet-wasm\"\n    );\n  }\n  try {\n    const fs = await import(\"fs/promises\");\n    const buffer = await fs.readFile(filePath);\n    const uint8 = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    const arrowTable = parquetWasm.readParquet(uint8);\n    const schema = arrowTable.schema;\n    const numFields = schema.numFields ?? schema.fields?.length ?? 0;\n    const numRows = arrowTable.numRows ?? 0;\n    const allFields = [];\n    for (let i = 0; i < numFields; i++) {\n      const field = schema.field(i);\n      const name = String(field.name);\n      const dtype = arrowTypeToDType(field);\n      allFields.push({ name, dtype, index: i });\n    }\n    const selectedFields = options.columns ? allFields.filter((f) => options.columns.includes(f.name)) : allFields;\n    const header = [];\n    const columns = {};\n    const inferredTypes = {};\n    for (const field of selectedFields) {\n      header.push(field.name);\n      inferredTypes[field.name] = field.dtype;\n      const arrowCol = arrowTable.getChildAt(field.index);\n      if (arrowCol) {\n        columns[field.name] = extractColumnValues(arrowCol, field.dtype, numRows);\n      } else {\n        columns[field.name] = new Array(numRows).fill(null);\n      }\n    }\n    return { header, columns, inferredTypes };\n  } catch (err) {\n    if (err instanceof IOError) throw err;\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to read Parquet file '${filePath}': ${message}`);\n  }\n}\n\n// src/io/excel/writer.ts\nfunction parseCellRef2(ref) {\n  const match = /^([A-Z]+)(\\d+)$/.exec(ref.toUpperCase());\n  if (!match) throw new IOError(`Invalid cell reference: '${ref}'`);\n  const colStr = match[1];\n  const rowNum = parseInt(match[2], 10);\n  let colNum = 0;\n  for (let i = 0; i < colStr.length; i++) {\n    colNum = colNum * 26 + (colStr.charCodeAt(i) - 64);\n  }\n  return { col: colNum, row: rowNum };\n}\nfunction columnNumberToLetter(col2) {\n  let result = \"\";\n  let n = col2;\n  while (n > 0) {\n    const remainder = (n - 1) % 26;\n    result = String.fromCharCode(65 + remainder) + result;\n    n = Math.floor((n - 1) / 26);\n  }\n  return result;\n}\nasync function writeExcelFile(filePath, header, rows, options = {}) {\n  let ExcelJS;\n  try {\n    ExcelJS = await import(\"exceljs\");\n  } catch {\n    throw new IOError(\n      \"exceljs is required to write Excel files but is not installed. Run: npm install exceljs\"\n    );\n  }\n  try {\n    const workbook = new ExcelJS.Workbook();\n    const sheetName = options.sheet ?? \"Sheet1\";\n    const worksheet = workbook.addWorksheet(sheetName);\n    const startCell = options.startCell ?? \"A1\";\n    const { col: startCol, row: startRow } = parseCellRef2(startCell);\n    for (let i = 0; i < header.length; i++) {\n      const colLetter = columnNumberToLetter(startCol + i);\n      const cellRef = `${colLetter}${String(startRow)}`;\n      worksheet.getCell(cellRef).value = header[i];\n    }\n    for (let r = 0; r < rows.length; r++) {\n      const row = rows[r];\n      for (let c = 0; c < header.length; c++) {\n        const colLetter = columnNumberToLetter(startCol + c);\n        const cellRef = `${colLetter}${String(startRow + 1 + r)}`;\n        const value = c < row.length ? row[c] : null;\n        worksheet.getCell(cellRef).value = value === null || value === void 0 ? null : value;\n      }\n    }\n    if (options.autoFilter) {\n      const lastColLetter = columnNumberToLetter(startCol + header.length - 1);\n      const lastRow = startRow + rows.length;\n      worksheet.autoFilter = `${columnNumberToLetter(startCol)}${String(startRow)}:${lastColLetter}${String(lastRow)}`;\n    }\n    if (options.freezePanes) {\n      const freezeRow = options.freezePanes.row;\n      const freezeCol = options.freezePanes.col;\n      worksheet.views = [\n        {\n          state: \"frozen\",\n          xSplit: freezeCol,\n          ySplit: startRow - 1 + freezeRow,\n          topLeftCell: `${columnNumberToLetter(startCol + freezeCol)}${String(startRow + freezeRow)}`,\n          activeCell: `${columnNumberToLetter(startCol)}${String(startRow)}`\n        }\n      ];\n    }\n    if (options.columnWidths) {\n      for (let i = 0; i < header.length; i++) {\n        const colName = header[i];\n        const width = options.columnWidths[colName];\n        if (width !== void 0) {\n          const col2 = worksheet.getColumn(startCol + i);\n          col2.width = width;\n        }\n      }\n    }\n    await workbook.xlsx.writeFile(filePath);\n  } catch (err) {\n    if (err instanceof IOError) throw err;\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to write Excel file '${filePath}': ${message}`);\n  }\n}\n\n// src/io/parquet/writer.ts\nfunction dtypeToArrowType(arrow, dtype) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return new arrow.Float64();\n    case \"i32\" /* Int32 */:\n      return new arrow.Int32();\n    case \"utf8\" /* Utf8 */:\n      return new arrow.Utf8();\n    case \"bool\" /* Boolean */:\n      return new arrow.Bool();\n    case \"date\" /* Date */:\n    case \"datetime\" /* DateTime */:\n      return new arrow.DateMillisecond();\n    default:\n      return new arrow.Utf8();\n  }\n}\nfunction coerceValues(values, dtype) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n    case \"i32\" /* Int32 */:\n      return values.map((v) => v === null || v === void 0 ? null : Number(v));\n    case \"utf8\" /* Utf8 */:\n      return values.map((v) => {\n        if (v === null || v === void 0) return null;\n        if (typeof v === \"string\") return v;\n        if (typeof v === \"number\" || typeof v === \"boolean\" || typeof v === \"bigint\") return String(v);\n        return typeof v === \"object\" ? JSON.stringify(v) : String(v);\n      });\n    case \"bool\" /* Boolean */:\n      return values.map((v) => v === null || v === void 0 ? null : Boolean(v));\n    case \"date\" /* Date */:\n    case \"datetime\" /* DateTime */:\n      return values.map((v) => {\n        if (v === null || v === void 0) return null;\n        if (v instanceof Date) return v.getTime();\n        if (typeof v === \"number\") return v;\n        return null;\n      });\n    default:\n      return values.map((v) => {\n        if (v === null || v === void 0) return null;\n        if (typeof v === \"string\") return v;\n        if (typeof v === \"number\" || typeof v === \"boolean\" || typeof v === \"bigint\") {\n          return String(v);\n        }\n        return typeof v === \"object\" ? JSON.stringify(v) : String(v);\n      });\n  }\n}\nfunction resolveCompression(parquetWasm, compression) {\n  const Compression = parquetWasm.Compression;\n  if (!Compression) return compression.toUpperCase();\n  switch (compression) {\n    case \"snappy\":\n      return Compression.SNAPPY;\n    case \"gzip\":\n      return Compression.GZIP;\n    case \"zstd\":\n      return Compression.ZSTD;\n    case \"none\":\n      return Compression.UNCOMPRESSED;\n  }\n}\nasync function writeParquetFile(filePath, header, columns, options = {}) {\n  let parquetWasm;\n  try {\n    const moduleName = \"parquet-wasm\";\n    parquetWasm = await import(moduleName);\n  } catch {\n    throw new IOError(\n      \"parquet-wasm is required to write Parquet files but is not installed. Run: npm install parquet-wasm\"\n    );\n  }\n  let arrow;\n  try {\n    const arrowModule = \"apache-arrow\";\n    arrow = await import(arrowModule);\n  } catch {\n    throw new IOError(\n      \"apache-arrow is required to write Parquet files but is not installed. Run: npm install apache-arrow\"\n    );\n  }\n  try {\n    const fields = [];\n    const arrowColumns = {};\n    for (const name of header) {\n      const col2 = columns[name];\n      const arrowType = dtypeToArrowType(arrow, col2.dtype);\n      fields.push(new arrow.Field(name, arrowType, true));\n      const coerced = coerceValues(col2.values, col2.dtype);\n      arrowColumns[name] = arrow.vectorFromArray(coerced, arrowType);\n    }\n    const schema = new arrow.Schema(fields);\n    const arrowTable = new arrow.Table(schema, arrowColumns);\n    const ipcBytes = arrow.tableToIPC(arrowTable, \"stream\");\n    const wasmTable = parquetWasm.Table.fromIPCStream(ipcBytes);\n    const compression = options.compression ?? \"snappy\";\n    const resolvedCompression = resolveCompression(parquetWasm, compression);\n    let builder = new parquetWasm.WriterPropertiesBuilder();\n    builder = builder.setCompression(resolvedCompression);\n    if (options.rowGroupSize !== void 0) {\n      builder = builder.setMaxRowGroupSize(options.rowGroupSize);\n    }\n    const writerProperties = builder.build();\n    const parquetBytes = parquetWasm.writeParquet(wasmTable, writerProperties);\n    const fs = await import(\"fs/promises\");\n    await fs.writeFile(filePath, parquetBytes);\n  } catch (err) {\n    if (err instanceof IOError) throw err;\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to write Parquet file '${filePath}': ${message}`);\n  }\n}\n\n// src/io/arrow/to-arrow.ts\nfunction dtypeToArrowType2(arrow, dtype) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return new arrow.Float64();\n    case \"i32\" /* Int32 */:\n      return new arrow.Int32();\n    case \"utf8\" /* Utf8 */:\n      return new arrow.Utf8();\n    case \"bool\" /* Boolean */:\n      return new arrow.Bool();\n    case \"date\" /* Date */:\n    case \"datetime\" /* DateTime */:\n      return new arrow.DateMillisecond();\n    default:\n      return new arrow.Utf8();\n  }\n}\nfunction coerceValue(value, dtype) {\n  if (value === null || value === void 0) return null;\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n    case \"i32\" /* Int32 */:\n      return Number(value);\n    case \"bool\" /* Boolean */:\n      return Boolean(value);\n    case \"date\" /* Date */:\n    case \"datetime\" /* DateTime */:\n      if (value instanceof Date) return value.getTime();\n      if (typeof value === \"number\") return value;\n      return new Date(value).getTime();\n    case \"utf8\" /* Utf8 */:\n    default:\n      if (typeof value === \"string\") return value;\n      if (typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"bigint\") return String(value);\n      return typeof value === \"object\" ? JSON.stringify(value) : String(value);\n  }\n}\nasync function toArrowTable(input) {\n  let arrow;\n  try {\n    const moduleName = \"apache-arrow\";\n    arrow = await import(moduleName);\n  } catch {\n    throw new IOError(\n      \"apache-arrow is required for Arrow interop but is not installed. Run: npm install apache-arrow\"\n    );\n  }\n  const { columnOrder, getColumnValues } = input;\n  const tableData = {};\n  for (const name of columnOrder) {\n    const { values, dtype } = getColumnValues(name);\n    const arrowType = dtypeToArrowType2(arrow, dtype);\n    const coerced = values.map((v) => coerceValue(v, dtype));\n    tableData[name] = arrow.vectorFromArray(coerced, arrowType);\n  }\n  return new arrow.Table(tableData);\n}\n\n// src/io/arrow/from-arrow.ts\nfunction arrowTypeToDType2(field) {\n  const typeId = field.type?.typeId;\n  const typeStr = String(field.type ?? \"\");\n  switch (typeId) {\n    case 2:\n      return \"i32\" /* Int32 */;\n    case 3:\n      return \"f64\" /* Float64 */;\n    case 5:\n      return \"utf8\" /* Utf8 */;\n    case 6:\n      return \"bool\" /* Boolean */;\n    case 8:\n    // Date\n    case 10:\n      return \"date\" /* Date */;\n    case -1:\n      if (typeStr.includes(\"Utf8\")) return \"utf8\" /* Utf8 */;\n      return \"utf8\" /* Utf8 */;\n    default:\n      if (typeStr.includes(\"Int\")) return \"i32\" /* Int32 */;\n      if (typeStr.includes(\"Float\")) return \"f64\" /* Float64 */;\n      if (typeStr.includes(\"Utf8\") || typeStr.includes(\"utf8\")) return \"utf8\" /* Utf8 */;\n      if (typeStr.includes(\"Bool\")) return \"bool\" /* Boolean */;\n      if (typeStr.includes(\"Date\") || typeStr.includes(\"Timestamp\")) return \"date\" /* Date */;\n      return \"utf8\" /* Utf8 */;\n  }\n}\nfunction fromArrowTable(table) {\n  if (!table || !table.schema || !table.schema.fields) {\n    throw new IOError(\"Invalid Arrow Table: missing schema or fields\");\n  }\n  const header = [];\n  const columns = {};\n  const inferredTypes = {};\n  const numRows = Number(table.numRows);\n  const fields = table.schema.fields;\n  for (const field of fields) {\n    const name = String(field.name);\n    header.push(name);\n    const dtype = arrowTypeToDType2(field);\n    inferredTypes[name] = dtype;\n    const column = table.getChild(name);\n    const values = [];\n    for (let i = 0; i < numRows; i++) {\n      const val = column.get(i);\n      if (val === null || val === void 0) {\n        values.push(null);\n      } else if (dtype === \"date\" /* Date */ && typeof val === \"number\") {\n        values.push(new Date(val));\n      } else {\n        values.push(val);\n      }\n    }\n    columns[name] = values;\n  }\n  return { header, columns, inferredTypes };\n}\n\n// src/engine/parallelism/parallel-agg.ts\nimport os from \"os\";\n\n// src/engine/parallelism/worker-code.ts\nvar WORKER_CODE = `\n'use strict';\nconst { parentPort } = require('worker_threads');\n\nfunction getNumericValue(data, nullMask, index, dtype) {\n  // Check null mask\n  if (nullMask) {\n    const byteIndex = index >> 3;\n    const bitIndex = index & 7;\n    if (!((nullMask[byteIndex] >> bitIndex) & 1)) {\n      return null; // null value\n    }\n  }\n  if (dtype === 'float64' || dtype === 'int32' || dtype === 'date') {\n    return data[index];\n  }\n  return null;\n}\n\nfunction getStringValue(data, nullMask, index) {\n  if (nullMask) {\n    const byteIndex = index >> 3;\n    const bitIndex = index & 7;\n    if (!((nullMask[byteIndex] >> bitIndex) & 1)) {\n      return null;\n    }\n  }\n  return data[index];\n}\n\nfunction getValue(colData, index) {\n  if (colData.dtype === 'utf8') {\n    return getStringValue(colData.data, colData.nullMaskArr, index);\n  }\n  return getNumericValue(colData.dataArr, colData.nullMaskArr, index, colData.dtype);\n}\n\nfunction computeAgg(colData, indices, aggType) {\n  switch (aggType) {\n    case 'sum': {\n      let total = 0;\n      let hasValue = false;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          total += v;\n          hasValue = true;\n        }\n      }\n      return hasValue ? total : null;\n    }\n    case 'mean': {\n      let total = 0;\n      let count = 0;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          total += v;\n          count++;\n        }\n      }\n      return count > 0 ? total / count : null;\n    }\n    case 'count': {\n      let count = 0;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null) count++;\n      }\n      return count;\n    }\n    case 'count_distinct': {\n      const seen = new Set();\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null) seen.add(v);\n      }\n      return seen.size;\n    }\n    case 'min': {\n      let result = null;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          if (result === null || v < result) result = v;\n        }\n      }\n      return result;\n    }\n    case 'max': {\n      let result = null;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          if (result === null || v > result) result = v;\n        }\n      }\n      return result;\n    }\n    case 'std': {\n      let sum = 0;\n      let sumSq = 0;\n      let count = 0;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          sum += v;\n          sumSq += v * v;\n          count++;\n        }\n      }\n      if (count < 2) return null;\n      const mean = sum / count;\n      const variance = sumSq / count - mean * mean;\n      return Math.sqrt(variance);\n    }\n    case 'first': {\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null) return v;\n      }\n      return null;\n    }\n    case 'last': {\n      for (let i = indices.length - 1; i >= 0; i--) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null) return v;\n      }\n      return null;\n    }\n    default:\n      return null;\n  }\n}\n\nparentPort.on('message', (msg) => {\n  const { columns, groups, aggSpecs, keyColumns } = msg;\n\n  // Pre-process column data for fast access\n  const processedColumns = {};\n  for (const [name, colData] of Object.entries(columns)) {\n    const processed = { ...colData };\n    if (colData.dtype === 'float64' || colData.dtype === 'date') {\n      processed.dataArr = new Float64Array(colData.data);\n    } else if (colData.dtype === 'int32') {\n      processed.dataArr = new Int32Array(colData.data);\n    } else if (colData.dtype === 'boolean') {\n      processed.dataArr = new Uint8Array(colData.data);\n    }\n    // utf8: data is already string[]\n    if (colData.nullMask) {\n      processed.nullMaskArr = new Uint8Array(colData.nullMask);\n    } else {\n      processed.nullMaskArr = null;\n    }\n    processedColumns[name] = processed;\n  }\n\n  const results = [];\n  const aggEntries = Object.entries(aggSpecs);\n\n  for (const [groupIndex, indices] of groups) {\n    // Extract key values from first row\n    const keyValues = [];\n    const firstIndex = indices[0];\n    for (const keyCol of keyColumns) {\n      const colData = processedColumns[keyCol];\n      if (colData) {\n        keyValues.push(getValue(colData, firstIndex));\n      } else {\n        keyValues.push(null);\n      }\n    }\n\n    // Compute aggregations\n    const aggValues = {};\n    for (const [outputName, spec] of aggEntries) {\n      const colData = processedColumns[spec.columnName];\n      if (colData) {\n        aggValues[outputName] = computeAgg(colData, indices, spec.aggType);\n      } else {\n        aggValues[outputName] = null;\n      }\n    }\n\n    results.push({ groupIndex, keyValues, aggValues });\n  }\n\n  parentPort.postMessage({ results });\n});\n`;\n\n// src/engine/parallelism/parallel-agg.ts\nvar DEFAULT_THRESHOLD = 1e6;\nvar defaultWorkerCount = Math.max(1, os.cpus().length - 1);\nvar workerThreadsAvailable = null;\nfunction isWorkerThreadsAvailableSync() {\n  if (workerThreadsAvailable === null) {\n    return true;\n  }\n  return workerThreadsAvailable;\n}\nfunction shouldUseParallel(rowCount, options) {\n  const threshold = options?.threshold ?? DEFAULT_THRESHOLD;\n  if (rowCount < threshold) return false;\n  if (!isWorkerThreadsAvailableSync()) return false;\n  const workerCount = options?.workerCount ?? defaultWorkerCount;\n  return workerCount > 1;\n}\nfunction serializeColumn(name, column) {\n  const len = column.length;\n  let nullMask = null;\n  if (column.nullCount > 0) {\n    const maskBytes = new Uint8Array(Math.ceil(len / 8));\n    for (let i = 0; i < len; i++) {\n      if (column.get(i) !== null) {\n        maskBytes[i >> 3] |= 1 << (i & 7);\n      }\n    }\n    nullMask = maskBytes.buffer;\n  }\n  switch (column.dtype) {\n    case \"f64\" /* Float64 */:\n    case \"date\" /* Date */: {\n      const arr = new Float64Array(len);\n      for (let i = 0; i < len; i++) {\n        const v = column.get(i);\n        if (v === null) {\n          arr[i] = 0;\n        } else if (v instanceof Date) {\n          arr[i] = v.getTime();\n        } else {\n          arr[i] = v;\n        }\n      }\n      return {\n        name,\n        dtype: column.dtype === \"date\" /* Date */ ? \"date\" : \"float64\",\n        data: arr.buffer,\n        nullMask,\n        length: len\n      };\n    }\n    case \"i32\" /* Int32 */: {\n      const arr = new Int32Array(len);\n      for (let i = 0; i < len; i++) {\n        const v = column.get(i);\n        arr[i] = v === null ? 0 : v;\n      }\n      return {\n        name,\n        dtype: \"int32\",\n        data: arr.buffer,\n        nullMask,\n        length: len\n      };\n    }\n    case \"bool\" /* Boolean */: {\n      const arr = new Uint8Array(len);\n      for (let i = 0; i < len; i++) {\n        const v = column.get(i);\n        arr[i] = v === null ? 0 : v ? 1 : 0;\n      }\n      return {\n        name,\n        dtype: \"boolean\",\n        data: arr.buffer,\n        nullMask,\n        length: len\n      };\n    }\n    case \"utf8\" /* Utf8 */:\n    default: {\n      const arr = [];\n      for (let i = 0; i < len; i++) {\n        const v = column.get(i);\n        if (v === null) {\n          arr.push(\"\");\n        } else if (typeof v === \"string\") {\n          arr.push(v);\n        } else if (typeof v === \"number\" || typeof v === \"boolean\") {\n          arr.push(String(v));\n        } else {\n          arr.push(\"\");\n        }\n      }\n      return {\n        name,\n        dtype: \"utf8\",\n        data: arr,\n        nullMask,\n        length: len\n      };\n    }\n  }\n}\nfunction partitionGroups(groupEntries, workerCount) {\n  const partitions = Array.from(\n    { length: workerCount },\n    () => []\n  );\n  for (let i = 0; i < groupEntries.length; i++) {\n    const [, indices] = groupEntries[i];\n    partitions[i % workerCount].push([i, indices]);\n  }\n  return partitions;\n}\nasync function parallelAgg(groupEntries, keyColumnNames, keyColumns, aggSpecs, sourceColumns, options) {\n  const wt = await import(\"worker_threads\");\n  const { Worker } = wt;\n  workerThreadsAvailable = true;\n  const workerCount = Math.min(\n    options?.workerCount ?? defaultWorkerCount,\n    groupEntries.length\n  );\n  const neededColumns = /* @__PURE__ */ new Set();\n  for (const keyName of keyColumnNames) {\n    neededColumns.add(keyName);\n  }\n  for (const spec of Object.values(aggSpecs)) {\n    neededColumns.add(spec.columnName);\n  }\n  const serializedColumns = {};\n  for (const colName of neededColumns) {\n    const column = sourceColumns.get(colName);\n    if (column) {\n      serializedColumns[colName] = serializeColumn(colName, column);\n    }\n  }\n  const partitions = partitionGroups(groupEntries, workerCount);\n  const workerPromises = partitions.map((partition) => {\n    if (partition.length === 0) {\n      return Promise.resolve({ results: [] });\n    }\n    return new Promise((resolve, reject) => {\n      const worker = new Worker(WORKER_CODE, { eval: true });\n      const message = {\n        columns: serializedColumns,\n        groups: partition,\n        aggSpecs,\n        keyColumns: keyColumnNames\n      };\n      worker.on(\"message\", (result) => {\n        void worker.terminate();\n        resolve(result);\n      });\n      worker.on(\"error\", (err) => {\n        void worker.terminate();\n        reject(err);\n      });\n      worker.postMessage(message);\n    });\n  });\n  const results = await Promise.all(workerPromises);\n  const allResults = [];\n  for (const workerResult of results) {\n    allResults.push(...workerResult.results);\n  }\n  allResults.sort((a, b) => a.groupIndex - b.groupIndex);\n  return allResults;\n}\n\n// src/ops/groupby.ts\nvar GroupBy = class {\n  _df;\n  _keys;\n  _groupMap;\n  constructor(df2, keys) {\n    this._df = df2;\n    this._keys = keys;\n    for (const key of keys) {\n      if (!df2.columns.includes(key)) {\n        throw new ColumnNotFoundError(key, df2.columns);\n      }\n    }\n    this._groupMap = /* @__PURE__ */ new Map();\n    const columns = keys.map((k) => df2.col(k).column);\n    if (keys.length === 1) {\n      const col2 = columns[0];\n      if (col2 instanceof Utf8Column && col2.isInterned) {\n        const interned = col2.internedStorage;\n        const internedIndices = interned.indices;\n        const dictLen = interned.dictionary.length;\n        const n = df2.length;\n        const buckets = new Array(dictLen);\n        for (let d = 0; d < dictLen; d++) {\n          buckets[d] = [];\n        }\n        if (col2.allValid) {\n          for (let i = 0; i < n; i++) {\n            buckets[internedIndices[i]].push(i);\n          }\n        } else {\n          const nullMask = col2.nullMask;\n          let nullBucket = null;\n          for (let i = 0; i < n; i++) {\n            if (nullMask.getUnsafe(i)) {\n              buckets[internedIndices[i]].push(i);\n            } else {\n              if (!nullBucket) nullBucket = [];\n              nullBucket.push(i);\n            }\n          }\n          if (nullBucket) {\n            this._groupMap.set(\"\\0null\", nullBucket);\n          }\n        }\n        for (let d = 0; d < dictLen; d++) {\n          const bucket = buckets[d];\n          if (bucket.length > 0) {\n            this._groupMap.set(`\\0string${interned.dictionary[d]}`, bucket);\n          }\n        }\n        return;\n      }\n    }\n    for (let i = 0; i < df2.length; i++) {\n      const keyStr = this._serializeKey(columns, i);\n      const group = this._groupMap.get(keyStr);\n      if (group) {\n        group.push(i);\n      } else {\n        this._groupMap.set(keyStr, [i]);\n      }\n    }\n  }\n  get keys() {\n    return [...this._keys];\n  }\n  get dataframe() {\n    return this._df;\n  }\n  get groupMap() {\n    return this._groupMap;\n  }\n  nGroups() {\n    return this._groupMap.size;\n  }\n  agg(specs, options) {\n    if (options || shouldUseParallel(this._df.length)) {\n      const useParallel = shouldUseParallel(this._df.length, options);\n      if (useParallel) {\n      }\n    }\n    return this._aggSync(specs);\n  }\n  /**\n   * Async aggregation that uses worker threads for large datasets.\n   * Falls back to single-threaded when workers are unavailable or data is small.\n   */\n  async aggAsync(specs, options) {\n    const resolvedSpecs = {};\n    for (const [name, spec] of Object.entries(specs)) {\n      if (typeof spec === \"string\") {\n        resolvedSpecs[name] = this._resolveShorthand(name, spec);\n      } else {\n        resolvedSpecs[name] = spec;\n      }\n    }\n    const useParallel = shouldUseParallel(this._df.length, options);\n    if (!useParallel) {\n      return this._aggSync(specs);\n    }\n    const aggSpecs = {};\n    for (const [name, aggExpr] of Object.entries(resolvedSpecs)) {\n      const aggType = this._aggExprToType(aggExpr);\n      if (!aggType) {\n        return this._aggSync(specs);\n      }\n      aggSpecs[name] = {\n        columnName: aggExpr.dependencies[0],\n        aggType\n      };\n    }\n    const sourceColumns = /* @__PURE__ */ new Map();\n    for (const colName of this._df.columns) {\n      sourceColumns.set(colName, this._df.col(colName).column);\n    }\n    const groupEntries = [...this._groupMap.entries()];\n    const keyCols = this._keys.map((k) => this._df.col(k).column);\n    const results = await parallelAgg(\n      groupEntries,\n      [...this._keys],\n      keyCols,\n      aggSpecs,\n      sourceColumns,\n      options\n    );\n    const nGroups = results.length;\n    const resultColumns = /* @__PURE__ */ new Map();\n    const columnOrder = [];\n    for (let ki = 0; ki < this._keys.length; ki++) {\n      const k = this._keys[ki];\n      const vals = results.map((r) => r.keyValues[ki] ?? null);\n      resultColumns.set(k, this._buildColumnLike(keyCols[ki], vals));\n      columnOrder.push(k);\n    }\n    const aggNames = Object.keys(specs);\n    for (const name of aggNames) {\n      const vals = results.map((r) => r.aggValues[name] ?? null);\n      resultColumns.set(name, this._inferColumn(vals, nGroups));\n      columnOrder.push(name);\n    }\n    const Ctor = this._df.constructor;\n    return new Ctor(resultColumns, columnOrder);\n  }\n  _aggSync(specs) {\n    const groupEntries = [...this._groupMap.entries()];\n    const nGroups = groupEntries.length;\n    const keyColumns = this._keys;\n    const aggNames = Object.keys(specs);\n    const resolvedSpecs = {};\n    for (const [name, spec] of Object.entries(specs)) {\n      if (typeof spec === \"string\") {\n        resolvedSpecs[name] = this._resolveShorthand(name, spec);\n      } else {\n        resolvedSpecs[name] = spec;\n      }\n    }\n    const keyValues = /* @__PURE__ */ new Map();\n    for (const k of keyColumns) {\n      keyValues.set(k, []);\n    }\n    const aggValues = /* @__PURE__ */ new Map();\n    for (const name of aggNames) {\n      aggValues.set(name, []);\n    }\n    const keyCols = keyColumns.map((k) => this._df.col(k).column);\n    if (aggNames.length === 1) {\n      const onlyAggName = aggNames[0];\n      const onlyAgg = resolvedSpecs[onlyAggName];\n      if (onlyAgg instanceof SumAggExpr) {\n        const sourceCol = this._df.col(onlyAgg.dependencies[0]).column;\n        for (const [, indices] of groupEntries) {\n          const firstIndex = indices[0];\n          for (let ki = 0; ki < keyColumns.length; ki++) {\n            keyValues.get(keyColumns[ki]).push(keyCols[ki].get(firstIndex));\n          }\n          let sum = 0;\n          let hasValue = false;\n          for (let ii = 0; ii < indices.length; ii++) {\n            const v = sourceCol.get(indices[ii]);\n            if (typeof v === \"number\") {\n              sum += v;\n              hasValue = true;\n            }\n          }\n          aggValues.get(onlyAggName).push(hasValue ? sum : null);\n        }\n        const resultColumns2 = /* @__PURE__ */ new Map();\n        const columnOrder2 = [];\n        for (let ki = 0; ki < keyColumns.length; ki++) {\n          const k = keyColumns[ki];\n          const vals = keyValues.get(k);\n          resultColumns2.set(k, this._buildColumnLike(keyCols[ki], vals));\n          columnOrder2.push(k);\n        }\n        resultColumns2.set(\n          onlyAggName,\n          Float64Column.from(aggValues.get(onlyAggName))\n        );\n        columnOrder2.push(onlyAggName);\n        const Ctor2 = this._df.constructor;\n        return new Ctor2(resultColumns2, columnOrder2);\n      }\n    }\n    for (const [, indices] of groupEntries) {\n      const firstIndex = indices[0];\n      for (let ki = 0; ki < keyColumns.length; ki++) {\n        keyValues.get(keyColumns[ki]).push(keyCols[ki].get(firstIndex));\n      }\n      const int32Indices = new Int32Array(indices);\n      const subColumns = /* @__PURE__ */ new Map();\n      for (const sourceName of this._df.columns) {\n        subColumns.set(sourceName, this._df.col(sourceName).column.take(int32Indices));\n      }\n      const Ctor2 = this._df.constructor;\n      const subFrame = new Ctor2(subColumns, [...this._df.columns]);\n      for (const name of aggNames) {\n        const aggExpr = resolvedSpecs[name];\n        const result = aggExpr.evaluateFrame(subFrame);\n        aggValues.get(name).push(result);\n      }\n    }\n    const resultColumns = /* @__PURE__ */ new Map();\n    const columnOrder = [];\n    for (let ki = 0; ki < keyColumns.length; ki++) {\n      const k = keyColumns[ki];\n      const sourceCol = keyCols[ki];\n      const vals = keyValues.get(k);\n      resultColumns.set(k, this._buildColumnLike(sourceCol, vals));\n      columnOrder.push(k);\n    }\n    for (const name of aggNames) {\n      const vals = aggValues.get(name);\n      resultColumns.set(name, this._inferColumn(vals, nGroups));\n      columnOrder.push(name);\n    }\n    const Ctor = this._df.constructor;\n    return new Ctor(resultColumns, columnOrder);\n  }\n  _aggExprToType(aggExpr) {\n    const name = aggExpr.constructor.name;\n    const map = {\n      SumAggExpr: \"sum\",\n      MeanAggExpr: \"mean\",\n      CountAggExpr: \"count\",\n      CountDistinctAggExpr: \"count_distinct\",\n      MinAggExpr: \"min\",\n      MaxAggExpr: \"max\",\n      StdAggExpr: \"std\",\n      FirstAggExpr: \"first\",\n      LastAggExpr: \"last\"\n    };\n    return map[name] ?? null;\n  }\n  _resolveShorthand(columnName, method) {\n    const colExpr = col(columnName);\n    switch (method) {\n      case \"sum\":\n        return colExpr.sum();\n      case \"mean\":\n        return colExpr.mean();\n      case \"count\":\n        return colExpr.count();\n      case \"min\":\n        return colExpr.min();\n      case \"max\":\n        return colExpr.max();\n      case \"std\":\n        return colExpr.std();\n      case \"first\":\n        return colExpr.first();\n      case \"last\":\n        return colExpr.last();\n      default:\n        throw new Error(`Unknown aggregation method: ${method}`);\n    }\n  }\n  _buildColumnLike(source, values) {\n    switch (source.dtype) {\n      case \"f64\" /* Float64 */:\n        return Float64Column.from(values);\n      case \"i32\" /* Int32 */:\n        return Float64Column.from(values);\n      case \"utf8\" /* Utf8 */:\n        return Utf8Column.from(values);\n      case \"bool\" /* Boolean */:\n        return BooleanColumn.from(values);\n      case \"date\" /* Date */:\n        return DateColumn.from(values);\n      default:\n        return Float64Column.from(values);\n    }\n  }\n  _inferColumn(values, _length) {\n    let sample = null;\n    for (const v of values) {\n      if (v !== null) {\n        sample = v;\n        break;\n      }\n    }\n    if (sample === null || typeof sample === \"number\") {\n      return Float64Column.from(values);\n    }\n    if (typeof sample === \"string\") {\n      return Utf8Column.from(values);\n    }\n    if (typeof sample === \"boolean\") {\n      return BooleanColumn.from(values);\n    }\n    if (sample instanceof Date) {\n      return DateColumn.from(values);\n    }\n    return Float64Column.from(values);\n  }\n  count() {\n    const groupEntries = [...this._groupMap.entries()];\n    const keyCols = this._keys.map((k) => this._df.col(k).column);\n    const keyValues = /* @__PURE__ */ new Map();\n    for (const k of this._keys) {\n      keyValues.set(k, []);\n    }\n    const counts = [];\n    for (const [, indices] of groupEntries) {\n      const firstIndex = indices[0];\n      for (let ki = 0; ki < this._keys.length; ki++) {\n        keyValues.get(this._keys[ki]).push(keyCols[ki].get(firstIndex));\n      }\n      counts.push(indices.length);\n    }\n    const resultColumns = /* @__PURE__ */ new Map();\n    const columnOrder = [];\n    for (let ki = 0; ki < this._keys.length; ki++) {\n      const k = this._keys[ki];\n      const vals = keyValues.get(k);\n      resultColumns.set(k, this._buildColumnLike(keyCols[ki], vals));\n      columnOrder.push(k);\n    }\n    resultColumns.set(\"count\", Float64Column.from(counts));\n    columnOrder.push(\"count\");\n    const Ctor = this._df.constructor;\n    return new Ctor(resultColumns, columnOrder);\n  }\n  sum(column) {\n    return this.agg({ [column]: col(column).sum() });\n  }\n  mean(column) {\n    return this.agg({ [column]: col(column).mean() });\n  }\n  min(column) {\n    return this.agg({ [column]: col(column).min() });\n  }\n  max(column) {\n    return this.agg({ [column]: col(column).max() });\n  }\n  first() {\n    const nonKeyColumns = this._df.columns.filter((c) => !this._keys.includes(c));\n    const specs = {};\n    for (const c of nonKeyColumns) {\n      specs[c] = col(c).first();\n    }\n    return this.agg(specs);\n  }\n  last() {\n    const nonKeyColumns = this._df.columns.filter((c) => !this._keys.includes(c));\n    const specs = {};\n    for (const c of nonKeyColumns) {\n      specs[c] = col(c).last();\n    }\n    return this.agg(specs);\n  }\n  apply(fn) {\n    const results = [];\n    for (const [, indices] of this._groupMap) {\n      const subFrame = this._buildSubFrame(indices);\n      results.push(fn(subFrame));\n    }\n    if (results.length === 0) {\n      return this._df.slice(0, 0);\n    }\n    const Ctor = this._df.constructor;\n    return Ctor.concat(...results);\n  }\n  groups() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, indices] of this._groupMap) {\n      result.set(key, this._buildSubFrame(indices));\n    }\n    return result;\n  }\n  _serializeKey(columns, index) {\n    if (columns.length === 1) {\n      const v = columns[0].get(index);\n      if (v === null) return \"\\0null\";\n      if (v instanceof Date) return `\\0d${v.getTime()}`;\n      if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n        return `\\0${typeof v}${String(v)}`;\n      }\n      return `\\0obj${JSON.stringify(v)}`;\n    }\n    const parts = [];\n    for (const column of columns) {\n      const v = column.get(index);\n      if (v === null) {\n        parts.push(\"\\0null\");\n      } else if (v instanceof Date) {\n        parts.push(`\\0d${v.getTime()}`);\n      } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n        parts.push(`\\0${typeof v}${String(v)}`);\n      } else {\n        parts.push(`\\0obj${JSON.stringify(v)}`);\n      }\n    }\n    return parts.join(\"\u0001\");\n  }\n  _buildSubFrame(indices) {\n    const int32Indices = new Int32Array(indices);\n    const newColumns = /* @__PURE__ */ new Map();\n    const columnOrder = this._df.columns;\n    for (const name of columnOrder) {\n      newColumns.set(name, this._df.col(name).column.take(int32Indices));\n    }\n    const Ctor = this._df.constructor;\n    return new Ctor(newColumns, columnOrder);\n  }\n};\n\n// src/ops/join.ts\nfunction serializeKey(columns, index) {\n  const parts = [];\n  for (const column of columns) {\n    const v = column.get(index);\n    if (v === null) {\n      return null;\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nfunction normalizeSingleKey(value) {\n  if (value === null) return null;\n  if (value instanceof Date) return `\\0d${value.getTime()}`;\n  if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n    return value;\n  }\n  return `\\0obj${JSON.stringify(value)}`;\n}\nfunction buildColumnFromValues(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction resolveKeys(on) {\n  if (typeof on === \"string\") {\n    return { leftKeys: [on], rightKeys: [on] };\n  }\n  if (Array.isArray(on)) {\n    return { leftKeys: on, rightKeys: on };\n  }\n  const leftKeys = Array.isArray(on.left) ? on.left : [on.left];\n  const rightKeys = Array.isArray(on.right) ? on.right : [on.right];\n  if (leftKeys.length !== rightKeys.length) {\n    throw new Error(\"Left and right key arrays must have the same length\");\n  }\n  return { leftKeys, rightKeys };\n}\nfunction crossJoin(left, right, suffix) {\n  const resultLength = left.length * right.length;\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  const rightColRenames = /* @__PURE__ */ new Map();\n  for (const rc of right.columns) {\n    if (left.columns.includes(rc)) {\n      rightColRenames.set(rc, `${rc}${suffix}`);\n    } else {\n      rightColRenames.set(rc, rc);\n    }\n  }\n  for (const colName of left.columns) {\n    const srcCol = left.col(colName).column;\n    const values = new Array(resultLength);\n    for (let li = 0; li < left.length; li++) {\n      const v = srcCol.get(li);\n      for (let ri = 0; ri < right.length; ri++) {\n        values[li * right.length + ri] = v;\n      }\n    }\n    resultColumns.set(colName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(colName);\n  }\n  for (const colName of right.columns) {\n    const srcCol = right.col(colName).column;\n    const outputName = rightColRenames.get(colName);\n    const values = new Array(resultLength);\n    for (let li = 0; li < left.length; li++) {\n      for (let ri = 0; ri < right.length; ri++) {\n        values[li * right.length + ri] = srcCol.get(ri);\n      }\n    }\n    resultColumns.set(outputName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(outputName);\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\nfunction semiAntiJoin(left, right, on, anti) {\n  const { leftKeys, rightKeys } = resolveKeys(on);\n  for (const key of leftKeys) {\n    if (!left.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, left.columns);\n    }\n  }\n  for (const key of rightKeys) {\n    if (!right.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, right.columns);\n    }\n  }\n  const rightKeyCols = rightKeys.map((k) => right.col(k).column);\n  const leftKeyCols = leftKeys.map((k) => left.col(k).column);\n  const rightKeySet = /* @__PURE__ */ new Set();\n  if (rightKeyCols.length === 1) {\n    const rightKeyCol = rightKeyCols[0];\n    for (let i = 0; i < right.length; i++) {\n      const key = normalizeSingleKey(rightKeyCol.get(i));\n      if (key !== null) rightKeySet.add(key);\n    }\n  } else {\n    for (let i = 0; i < right.length; i++) {\n      const keyStr = serializeKey(rightKeyCols, i);\n      if (keyStr !== null) rightKeySet.add(keyStr);\n    }\n  }\n  const matchedIndices = [];\n  if (leftKeyCols.length === 1) {\n    const leftKeyCol = leftKeyCols[0];\n    for (let i = 0; i < left.length; i++) {\n      const key = normalizeSingleKey(leftKeyCol.get(i));\n      const hasMatch = key !== null && rightKeySet.has(key);\n      if (anti ? !hasMatch : hasMatch) {\n        matchedIndices.push(i);\n      }\n    }\n  } else {\n    for (let i = 0; i < left.length; i++) {\n      const keyStr = serializeKey(leftKeyCols, i);\n      const hasMatch = keyStr !== null && rightKeySet.has(keyStr);\n      if (anti ? !hasMatch : hasMatch) {\n        matchedIndices.push(i);\n      }\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const colName of left.columns) {\n    const srcCol = left.col(colName).column;\n    const values = new Array(matchedIndices.length);\n    for (let i = 0; i < matchedIndices.length; i++) {\n      values[i] = srcCol.get(matchedIndices[i]);\n    }\n    resultColumns.set(colName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(colName);\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\nfunction hashJoin(left, right, on, how = \"inner\", options) {\n  const suffix = options?.suffix ?? \"_right\";\n  if (how === \"cross\") {\n    return crossJoin(left, right, suffix);\n  }\n  if (how === \"semi\") {\n    return semiAntiJoin(left, right, on, false);\n  }\n  if (how === \"anti\") {\n    return semiAntiJoin(left, right, on, true);\n  }\n  const { leftKeys, rightKeys } = resolveKeys(on);\n  for (const key of leftKeys) {\n    if (!left.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, left.columns);\n    }\n  }\n  for (const key of rightKeys) {\n    if (!right.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, right.columns);\n    }\n  }\n  if (how === \"left\" && leftKeys.length === 1 && rightKeys.length === 1) {\n    const leftKeyCol = left.col(leftKeys[0]).column;\n    const rightKeyCol = right.col(rightKeys[0]).column;\n    const rightIndexByKey = /* @__PURE__ */ new Map();\n    let rightKeyUnique = true;\n    for (let i = 0; i < right.length; i++) {\n      const key = normalizeSingleKey(rightKeyCol.get(i));\n      if (key === null) continue;\n      if (rightIndexByKey.has(key)) {\n        rightKeyUnique = false;\n        break;\n      }\n      rightIndexByKey.set(key, i);\n    }\n    if (rightKeyUnique) {\n      const resultColumns2 = /* @__PURE__ */ new Map();\n      const columnOrder2 = [];\n      for (const colName of left.columns) {\n        resultColumns2.set(colName, left.col(colName).column);\n        columnOrder2.push(colName);\n      }\n      const rightNonKeyCols2 = right.columns.filter((c) => c !== rightKeys[0]);\n      const rightColRenames2 = /* @__PURE__ */ new Map();\n      for (const rc of rightNonKeyCols2) {\n        rightColRenames2.set(rc, left.columns.includes(rc) ? `${rc}${suffix}` : rc);\n      }\n      for (const colName of rightNonKeyCols2) {\n        const srcCol = right.col(colName).column;\n        const values = new Array(left.length);\n        for (let li = 0; li < left.length; li++) {\n          const key = normalizeSingleKey(leftKeyCol.get(li));\n          if (key === null) {\n            values[li] = null;\n            continue;\n          }\n          const ri = rightIndexByKey.get(key);\n          values[li] = ri === void 0 ? null : srcCol.get(ri);\n        }\n        const outputName = rightColRenames2.get(colName);\n        resultColumns2.set(outputName, buildColumnFromValues(srcCol.dtype, values));\n        columnOrder2.push(outputName);\n      }\n      const Ctor2 = left.constructor;\n      return new Ctor2(resultColumns2, columnOrder2);\n    }\n  }\n  const rightKeyCols = rightKeys.map((k) => right.col(k).column);\n  const hashTable = /* @__PURE__ */ new Map();\n  if (rightKeyCols.length === 1) {\n    const rightKeyCol = rightKeyCols[0];\n    for (let i = 0; i < right.length; i++) {\n      const key = normalizeSingleKey(rightKeyCol.get(i));\n      if (key === null) continue;\n      const bucket = hashTable.get(key);\n      if (bucket === void 0) {\n        hashTable.set(key, i);\n      } else if (typeof bucket === \"number\") {\n        hashTable.set(key, [bucket, i]);\n      } else {\n        bucket.push(i);\n      }\n    }\n  } else {\n    for (let i = 0; i < right.length; i++) {\n      const keyStr = serializeKey(rightKeyCols, i);\n      if (keyStr === null) continue;\n      const bucket = hashTable.get(keyStr);\n      if (bucket === void 0) {\n        hashTable.set(keyStr, [i]);\n      } else if (typeof bucket === \"number\") {\n        hashTable.set(keyStr, [bucket, i]);\n      } else {\n        bucket.push(i);\n      }\n    }\n  }\n  const leftKeyCols = leftKeys.map((k) => left.col(k).column);\n  const leftIndices = [];\n  const rightIndices = [];\n  const rightMatched = new Uint8Array(right.length);\n  if (leftKeyCols.length === 1) {\n    const leftKeyCol = leftKeyCols[0];\n    for (let i = 0; i < left.length; i++) {\n      const key = normalizeSingleKey(leftKeyCol.get(i));\n      if (key === null) {\n        if (how === \"left\" || how === \"outer\") {\n          leftIndices.push(i);\n          rightIndices.push(null);\n        }\n        continue;\n      }\n      const matches = hashTable.get(key);\n      if (matches !== void 0) {\n        if (typeof matches === \"number\") {\n          leftIndices.push(i);\n          rightIndices.push(matches);\n          if (how === \"right\" || how === \"outer\") {\n            rightMatched[matches] = 1;\n          }\n        } else {\n          for (let mi = 0; mi < matches.length; mi++) {\n            const ri = matches[mi];\n            leftIndices.push(i);\n            rightIndices.push(ri);\n            if (how === \"right\" || how === \"outer\") {\n              rightMatched[ri] = 1;\n            }\n          }\n        }\n      } else if (how === \"left\" || how === \"outer\") {\n        leftIndices.push(i);\n        rightIndices.push(null);\n      }\n    }\n  } else {\n    for (let i = 0; i < left.length; i++) {\n      const keyStr = serializeKey(leftKeyCols, i);\n      if (keyStr === null) {\n        if (how === \"left\" || how === \"outer\") {\n          leftIndices.push(i);\n          rightIndices.push(null);\n        }\n        continue;\n      }\n      const matches = hashTable.get(keyStr);\n      if (matches !== void 0) {\n        if (typeof matches === \"number\") {\n          leftIndices.push(i);\n          rightIndices.push(matches);\n          if (how === \"right\" || how === \"outer\") {\n            rightMatched[matches] = 1;\n          }\n        } else {\n          for (let mi = 0; mi < matches.length; mi++) {\n            const ri = matches[mi];\n            leftIndices.push(i);\n            rightIndices.push(ri);\n            if (how === \"right\" || how === \"outer\") {\n              rightMatched[ri] = 1;\n            }\n          }\n        }\n      } else if (how === \"left\" || how === \"outer\") {\n        leftIndices.push(i);\n        rightIndices.push(null);\n      }\n    }\n  }\n  if (how === \"right\" || how === \"outer\") {\n    for (let i = 0; i < right.length; i++) {\n      if (rightMatched[i] === 0) {\n        leftIndices.push(-1);\n        rightIndices.push(i);\n      }\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  const resultLength = leftIndices.length;\n  const rightNonKeyCols = right.columns.filter((c) => !rightKeys.includes(c));\n  const leftNonKeyCols = left.columns.filter((c) => !leftKeys.includes(c));\n  const rightColRenames = /* @__PURE__ */ new Map();\n  for (const rc of rightNonKeyCols) {\n    if (left.columns.includes(rc)) {\n      rightColRenames.set(rc, `${rc}${suffix}`);\n    } else {\n      rightColRenames.set(rc, rc);\n    }\n  }\n  for (let ki = 0; ki < leftKeys.length; ki++) {\n    const leftKey = leftKeys[ki];\n    const rightKey = rightKeys[ki];\n    const leftCol = left.col(leftKey).column;\n    const rightCol = right.col(rightKey).column;\n    const values = new Array(resultLength);\n    for (let i = 0; i < resultLength; i++) {\n      const li = leftIndices[i];\n      const ri = rightIndices[i];\n      if (li >= 0) {\n        values[i] = leftCol.get(li);\n      } else if (ri !== null) {\n        values[i] = rightCol.get(ri);\n      } else {\n        values[i] = null;\n      }\n    }\n    resultColumns.set(leftKey, buildColumnFromValues(leftCol.dtype, values));\n    columnOrder.push(leftKey);\n  }\n  for (const colName of leftNonKeyCols) {\n    const srcCol = left.col(colName).column;\n    const values = new Array(resultLength);\n    for (let i = 0; i < resultLength; i++) {\n      const li = leftIndices[i];\n      values[i] = li >= 0 ? srcCol.get(li) : null;\n    }\n    resultColumns.set(colName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(colName);\n  }\n  for (const colName of rightNonKeyCols) {\n    const srcCol = right.col(colName).column;\n    const outputName = rightColRenames.get(colName);\n    const values = new Array(resultLength);\n    for (let i = 0; i < resultLength; i++) {\n      const ri = rightIndices[i];\n      if (ri !== null) {\n        values[i] = srcCol.get(ri);\n      } else {\n        values[i] = null;\n      }\n    }\n    resultColumns.set(outputName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(outputName);\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/lookup.ts\nfunction serializeKey2(columns, index) {\n  const parts = [];\n  for (const column of columns) {\n    const v = column.get(index);\n    if (v === null) {\n      return null;\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nfunction buildColumnFromValues2(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return new ObjectColumn(values);\n  }\n}\nfunction lookup(left, right, on, values) {\n  if (!left.columns.includes(on)) {\n    throw new ColumnNotFoundError(on, left.columns);\n  }\n  if (!right.columns.includes(on)) {\n    throw new ColumnNotFoundError(on, right.columns);\n  }\n  const valueCols = values ?? right.columns.filter((c) => c !== on);\n  for (const col2 of valueCols) {\n    if (!right.columns.includes(col2)) {\n      throw new ColumnNotFoundError(col2, right.columns);\n    }\n  }\n  const rightKeyCol = [right.col(on).column];\n  const lookupMap = /* @__PURE__ */ new Map();\n  for (let i = 0; i < right.length; i++) {\n    const keyStr = serializeKey2(rightKeyCol, i);\n    if (keyStr === null) continue;\n    if (!lookupMap.has(keyStr)) {\n      lookupMap.set(keyStr, i);\n    }\n  }\n  const leftKeyCol = [left.col(on).column];\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const colName of left.columns) {\n    resultColumns.set(colName, left.col(colName).column);\n    columnOrder.push(colName);\n  }\n  for (const colName of valueCols) {\n    const srcCol = right.col(colName).column;\n    const vals = new Array(left.length);\n    for (let i = 0; i < left.length; i++) {\n      const keyStr = serializeKey2(leftKeyCol, i);\n      if (keyStr !== null) {\n        const ri = lookupMap.get(keyStr);\n        vals[i] = ri !== void 0 ? srcCol.get(ri) : null;\n      } else {\n        vals[i] = null;\n      }\n    }\n    const outputName = left.columns.includes(colName) ? colName : colName;\n    resultColumns.set(outputName, buildColumnFromValues2(srcCol.dtype, vals));\n    columnOrder.push(outputName);\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/spread.ts\nfunction spread(df2, column, options = {}) {\n  if (!df2.columns.includes(column)) {\n    throw new ColumnNotFoundError(column, df2.columns);\n  }\n  const { limit, name: nameFn, drop = false } = options;\n  const srcCol = df2.col(column).column;\n  const len = df2.length;\n  let isObject = false;\n  let maxArrayLen = 0;\n  const objectKeys = /* @__PURE__ */ new Set();\n  for (let i = 0; i < len; i++) {\n    const val = srcCol.get(i);\n    if (val === null) continue;\n    if (Array.isArray(val)) {\n      maxArrayLen = Math.max(maxArrayLen, val.length);\n    } else if (typeof val === \"object\") {\n      isObject = true;\n      for (const key of Object.keys(val)) {\n        objectKeys.add(key);\n      }\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const colName of df2.columns) {\n    if (drop && colName === column) continue;\n    resultColumns.set(colName, df2.col(colName).column);\n    columnOrder.push(colName);\n  }\n  if (isObject) {\n    const keys = [...objectKeys];\n    const effectiveKeys = limit !== void 0 ? keys.slice(0, limit) : keys;\n    for (const key of effectiveKeys) {\n      const outName = nameFn ? nameFn(column, key) : `${column}_${key}`;\n      const values = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const val = srcCol.get(i);\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n          values[i] = null;\n        } else {\n          const obj = val;\n          values[i] = key in obj ? obj[key] : null;\n        }\n      }\n      resultColumns.set(outName, ObjectColumn.from(values));\n      columnOrder.push(outName);\n    }\n  } else {\n    const width = limit !== void 0 ? Math.min(maxArrayLen, limit) : maxArrayLen;\n    for (let idx = 0; idx < width; idx++) {\n      const outName = nameFn ? nameFn(column, idx) : `${column}_${String(idx)}`;\n      const values = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const val = srcCol.get(i);\n        if (val === null || !Array.isArray(val) || idx >= val.length) {\n          values[i] = null;\n        } else {\n          values[i] = val[idx];\n        }\n      }\n      resultColumns.set(outName, ObjectColumn.from(values));\n      columnOrder.push(outName);\n    }\n  }\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/unroll.ts\nfunction unroll(df2, columns, options = {}) {\n  const cols = Array.isArray(columns) ? columns : [columns];\n  for (const c of cols) {\n    if (!df2.columns.includes(c)) {\n      throw new ColumnNotFoundError(c, df2.columns);\n    }\n  }\n  const len = df2.length;\n  const nonUnrollCols = df2.columns.filter((c) => !cols.includes(c));\n  const rowCounts = new Array(len);\n  for (let i = 0; i < len; i++) {\n    let maxLen = 0;\n    for (const c of cols) {\n      const val = df2.col(c).column.get(i);\n      if (Array.isArray(val)) {\n        maxLen = Math.max(maxLen, val.length);\n      }\n    }\n    rowCounts[i] = maxLen;\n  }\n  const totalRows = rowCounts.reduce((a, b) => a + b, 0);\n  const resultData = {};\n  for (const c of nonUnrollCols) {\n    resultData[c] = new Array(totalRows);\n  }\n  for (const c of cols) {\n    resultData[c] = new Array(totalRows);\n  }\n  let indexData;\n  if (options.index) {\n    indexData = new Array(totalRows);\n  }\n  let outIdx = 0;\n  for (let i = 0; i < len; i++) {\n    const count = rowCounts[i];\n    if (count === 0) continue;\n    for (let j = 0; j < count; j++) {\n      for (const c of nonUnrollCols) {\n        resultData[c][outIdx] = df2.col(c).column.get(i);\n      }\n      for (const c of cols) {\n        const val = df2.col(c).column.get(i);\n        if (Array.isArray(val) && j < val.length) {\n          resultData[c][outIdx] = val[j];\n        } else {\n          resultData[c][outIdx] = null;\n        }\n      }\n      if (indexData) {\n        indexData[outIdx] = j;\n      }\n      outIdx++;\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const c of df2.columns) {\n    resultColumns.set(c, ObjectColumn.from(resultData[c]));\n    columnOrder.push(c);\n  }\n  if (options.index && indexData) {\n    resultColumns.set(options.index, ObjectColumn.from(indexData));\n    columnOrder.push(options.index);\n  }\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/impute.ts\nfunction rowKey(row, keys) {\n  return keys.map((k) => {\n    const value = row[k];\n    if (value === null) return \"__null__\";\n    if (value instanceof Date) return `__date__${String(value.getTime())}`;\n    return `__${typeof value}__${JSON.stringify(value)}`;\n  }).join(\"|\");\n}\nfunction cartesian(values) {\n  if (values.length === 0) return [[]];\n  let out = [[]];\n  for (const set of values) {\n    const next = [];\n    for (const prefix of out) {\n      for (const item of set) {\n        next.push([...prefix, item]);\n      }\n    }\n    out = next;\n  }\n  return out;\n}\nfunction impute(df2, values, options = {}) {\n  for (const colName of Object.keys(values)) {\n    if (!df2.columns.includes(colName)) {\n      throw new ColumnNotFoundError(colName, df2.columns);\n    }\n  }\n  const expandKeys = options.expand ?? [];\n  for (const key of expandKeys) {\n    if (!df2.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, df2.columns);\n    }\n  }\n  const sourceRows = df2.toArray();\n  let workingRows = sourceRows;\n  if (expandKeys.length > 0) {\n    const keyDomains = expandKeys.map((key) => {\n      const seen = /* @__PURE__ */ new Set();\n      const out = [];\n      for (const row of sourceRows) {\n        const raw = row[key];\n        const normalized = raw instanceof Date ? `d:${String(raw.getTime())}` : JSON.stringify(raw);\n        if (!seen.has(normalized)) {\n          seen.add(normalized);\n          out.push(raw ?? null);\n        }\n      }\n      return out;\n    });\n    const combos = cartesian(keyDomains);\n    const existing = /* @__PURE__ */ new Map();\n    for (const row of sourceRows) {\n      existing.set(rowKey(row, expandKeys), row);\n    }\n    workingRows = combos.map((combo) => {\n      const comboRow = {};\n      for (let i = 0; i < expandKeys.length; i++) {\n        comboRow[expandKeys[i]] = combo[i] ?? null;\n      }\n      const existingRow = existing.get(rowKey(comboRow, expandKeys));\n      if (existingRow) {\n        return existingRow;\n      }\n      const generated = {};\n      for (const colName of df2.columns) {\n        generated[colName] = comboRow[colName] ?? null;\n      }\n      return generated;\n    });\n  }\n  const columnData = {};\n  for (const colName of df2.columns) {\n    columnData[colName] = workingRows.map((row) => row[colName] ?? null);\n  }\n  const resolvedValues = {};\n  for (const [colName, spec] of Object.entries(values)) {\n    resolvedValues[colName] = typeof spec === \"function\" ? spec(columnData) : spec;\n  }\n  const resultRows = workingRows.map((row) => {\n    const next = { ...row };\n    for (const [colName, fillValue] of Object.entries(resolvedValues)) {\n      if ((next[colName] ?? null) === null) {\n        next[colName] = fillValue;\n      }\n    }\n    return next;\n  });\n  return df2.constructor.fromRows(resultRows);\n}\n\n// src/ops/pivot.ts\nfunction aggregate(values, aggFunc) {\n  switch (aggFunc) {\n    case \"first\":\n      return values.length > 0 ? values[0] : null;\n    case \"last\":\n      return values.length > 0 ? values[values.length - 1] : null;\n    case \"count\":\n      return values.length;\n    case \"sum\": {\n      let total = 0;\n      for (const v of values) {\n        if (typeof v === \"number\") total += v;\n      }\n      return total;\n    }\n    case \"mean\": {\n      let total = 0;\n      let count = 0;\n      for (const v of values) {\n        if (typeof v === \"number\") {\n          total += v;\n          count++;\n        }\n      }\n      return count > 0 ? total / count : null;\n    }\n  }\n}\nfunction serializeKey3(df2, index, indexCols) {\n  const parts = [];\n  for (const name of indexCols) {\n    const v = df2.col(name).get(index);\n    if (v === null) {\n      parts.push(\"\\0null\");\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nfunction buildColumnFromValues3(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction pivot(df2, options) {\n  const indexCols = Array.isArray(options.index) ? options.index : [options.index];\n  const columnsCol = options.columns;\n  const valuesCol = options.values;\n  const aggFunc = options.aggFunc ?? \"first\";\n  for (const col2 of [...indexCols, columnsCol, valuesCol]) {\n    if (!df2.columns.includes(col2)) {\n      throw new ColumnNotFoundError(col2, df2.columns);\n    }\n  }\n  const indexKeyOrder = [];\n  const indexKeyToRowIndices = /* @__PURE__ */ new Map();\n  for (let i = 0; i < df2.length; i++) {\n    const key = serializeKey3(df2, i, indexCols);\n    if (!indexKeyToRowIndices.has(key)) {\n      indexKeyOrder.push(key);\n      indexKeyToRowIndices.set(key, []);\n    }\n    indexKeyToRowIndices.get(key).push(i);\n  }\n  const pivotColValues = [];\n  const pivotColSet = /* @__PURE__ */ new Set();\n  const pivotColumnSeries = df2.col(columnsCol);\n  for (let i = 0; i < df2.length; i++) {\n    const v = pivotColumnSeries.get(i);\n    let str;\n    if (v === null) {\n      str = \"null\";\n    } else if (typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\") {\n      str = String(v);\n    } else if (v instanceof Date) {\n      str = v.toISOString();\n    } else {\n      str = JSON.stringify(v);\n    }\n    if (!pivotColSet.has(str)) {\n      pivotColSet.add(str);\n      pivotColValues.push(str);\n    }\n  }\n  const cellData = /* @__PURE__ */ new Map();\n  for (let i = 0; i < df2.length; i++) {\n    const indexKey = serializeKey3(df2, i, indexCols);\n    const pivotVal = pivotColumnSeries.get(i);\n    let pivotStr;\n    if (pivotVal === null) {\n      pivotStr = \"null\";\n    } else if (typeof pivotVal === \"string\" || typeof pivotVal === \"number\" || typeof pivotVal === \"boolean\") {\n      pivotStr = String(pivotVal);\n    } else if (pivotVal instanceof Date) {\n      pivotStr = pivotVal.toISOString();\n    } else {\n      pivotStr = JSON.stringify(pivotVal);\n    }\n    const cellKey = indexKey + \"\u0002\" + pivotStr;\n    if (!cellData.has(cellKey)) {\n      cellData.set(cellKey, []);\n    }\n    cellData.get(cellKey).push(df2.col(valuesCol).get(i));\n  }\n  const valuesDtype = df2.col(valuesCol).column.dtype;\n  const resultDtype = aggFunc === \"count\" ? \"f64\" /* Float64 */ : valuesDtype;\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const idxCol of indexCols) {\n    const vals = [];\n    const sourceCol = df2.col(idxCol);\n    for (const key of indexKeyOrder) {\n      const firstRow = indexKeyToRowIndices.get(key)[0];\n      vals.push(sourceCol.get(firstRow));\n    }\n    resultColumns.set(idxCol, buildColumnFromValues3(sourceCol.column.dtype, vals));\n    columnOrder.push(idxCol);\n  }\n  for (const pivotVal of pivotColValues) {\n    const vals = [];\n    for (const indexKey of indexKeyOrder) {\n      const cellKey = indexKey + \"\u0002\" + pivotVal;\n      const cellValues = cellData.get(cellKey);\n      if (cellValues && cellValues.length > 0) {\n        vals.push(aggregate(cellValues, aggFunc));\n      } else {\n        vals.push(null);\n      }\n    }\n    resultColumns.set(pivotVal, buildColumnFromValues3(resultDtype, vals));\n    columnOrder.push(pivotVal);\n  }\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/melt.ts\nfunction buildColumnFromValues4(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction detectDType(values) {\n  for (const v of values) {\n    if (v === null || v === void 0) continue;\n    if (typeof v === \"number\") return Number.isInteger(v) ? \"f64\" /* Float64 */ : \"f64\" /* Float64 */;\n    if (typeof v === \"string\") return \"utf8\" /* Utf8 */;\n    if (typeof v === \"boolean\") return \"bool\" /* Boolean */;\n    if (v instanceof Date) return \"date\" /* Date */;\n  }\n  return \"f64\" /* Float64 */;\n}\nfunction melt(df2, options) {\n  const idVars = Array.isArray(options.idVars) ? options.idVars : [options.idVars];\n  const varName = options.varName ?? \"variable\";\n  const valueName = options.valueName ?? \"value\";\n  for (const col2 of idVars) {\n    if (!df2.columns.includes(col2)) {\n      throw new ColumnNotFoundError(col2, df2.columns);\n    }\n  }\n  let valueVars;\n  if (options.valueVars) {\n    valueVars = Array.isArray(options.valueVars) ? options.valueVars : [options.valueVars];\n    for (const col2 of valueVars) {\n      if (!df2.columns.includes(col2)) {\n        throw new ColumnNotFoundError(col2, df2.columns);\n      }\n    }\n  } else {\n    const idSet = new Set(idVars);\n    valueVars = df2.columns.filter((c) => !idSet.has(c));\n  }\n  const nRows = df2.length;\n  const nValueVars = valueVars.length;\n  const resultLength = nRows * nValueVars;\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const idCol of idVars) {\n    const sourceSeries = df2.col(idCol);\n    const vals = new Array(resultLength);\n    for (let i = 0; i < nRows; i++) {\n      const v = sourceSeries.get(i);\n      for (let j = 0; j < nValueVars; j++) {\n        vals[i * nValueVars + j] = v;\n      }\n    }\n    resultColumns.set(idCol, buildColumnFromValues4(sourceSeries.column.dtype, vals));\n    columnOrder.push(idCol);\n  }\n  const varValues = new Array(resultLength);\n  for (let i = 0; i < nRows; i++) {\n    for (let j = 0; j < nValueVars; j++) {\n      varValues[i * nValueVars + j] = valueVars[j];\n    }\n  }\n  resultColumns.set(varName, Utf8Column.from(varValues));\n  columnOrder.push(varName);\n  const valueValues = new Array(resultLength);\n  for (let i = 0; i < nRows; i++) {\n    for (let j = 0; j < nValueVars; j++) {\n      valueValues[i * nValueVars + j] = df2.col(valueVars[j]).get(i);\n    }\n  }\n  const valueDtype = detectDType(valueValues);\n  resultColumns.set(valueName, buildColumnFromValues4(valueDtype, valueValues));\n  columnOrder.push(valueName);\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/reshape.ts\nfunction detectDType2(values) {\n  for (const v of values) {\n    if (v === null || v === void 0) continue;\n    if (typeof v === \"number\") return \"f64\" /* Float64 */;\n    if (typeof v === \"string\") return \"utf8\" /* Utf8 */;\n    if (typeof v === \"boolean\") return \"bool\" /* Boolean */;\n    if (v instanceof Date) return \"date\" /* Date */;\n  }\n  return \"f64\" /* Float64 */;\n}\nfunction buildColumnFromValues5(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction serializeValue(v) {\n  if (v === null || v === void 0) return \"null\";\n  if (v instanceof Date) return v.toISOString();\n  if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n    return String(v);\n  }\n  return JSON.stringify(v);\n}\nfunction transpose(df2, headerColumn) {\n  const Ctor = df2.constructor;\n  const nRows = df2.length;\n  const cols = df2.columns;\n  if (cols.length === 0 || nRows === 0) {\n    return new Ctor(/* @__PURE__ */ new Map(), []);\n  }\n  let newHeaders;\n  let sourceColumns;\n  if (headerColumn) {\n    const headerSeries = df2.col(headerColumn);\n    newHeaders = [];\n    for (let i = 0; i < nRows; i++) {\n      newHeaders.push(serializeValue(headerSeries.get(i)));\n    }\n    sourceColumns = cols.filter((c) => c !== headerColumn);\n  } else {\n    newHeaders = [];\n    for (let i = 0; i < nRows; i++) {\n      newHeaders.push(String(i));\n    }\n    sourceColumns = cols;\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [\"column\"];\n  resultColumns.set(\"column\", Utf8Column.from(sourceColumns));\n  for (let rowIdx = 0; rowIdx < nRows; rowIdx++) {\n    const header = newHeaders[rowIdx];\n    const values = [];\n    for (const colName of sourceColumns) {\n      values.push(df2.col(colName).get(rowIdx));\n    }\n    const dtype = detectDType2(values);\n    resultColumns.set(header, buildColumnFromValues5(dtype, values));\n    columnOrder.push(header);\n  }\n  return new Ctor(resultColumns, columnOrder);\n}\nfunction concat(...frames) {\n  if (frames.length === 0) {\n    throw new ShapeMismatchError(\"concat requires at least one DataFrame\");\n  }\n  const first = frames[0];\n  const Ctor = first.constructor;\n  if (frames.length === 1) {\n    return first;\n  }\n  const allColumns = [];\n  const columnSet = /* @__PURE__ */ new Set();\n  for (const frame of frames) {\n    for (const col2 of frame.columns) {\n      if (!columnSet.has(col2)) {\n        columnSet.add(col2);\n        allColumns.push(col2);\n      }\n    }\n  }\n  const dtypeMap = /* @__PURE__ */ new Map();\n  for (const frame of frames) {\n    const dtypes = frame.dtypes;\n    for (const col2 of frame.columns) {\n      const existing = dtypeMap.get(col2);\n      const current = dtypes[col2];\n      if (existing !== void 0 && existing !== current) {\n        throw new ShapeMismatchError(\n          `Column '${col2}' has incompatible types: ${existing} vs ${current}`\n        );\n      }\n      dtypeMap.set(col2, current);\n    }\n  }\n  const totalRows = frames.reduce((sum, f) => sum + f.length, 0);\n  const resultColumns = /* @__PURE__ */ new Map();\n  for (const colName of allColumns) {\n    const values = new Array(totalRows);\n    let offset = 0;\n    for (const frame of frames) {\n      const frameLen = frame.length;\n      if (frame.columns.includes(colName)) {\n        const series = frame.col(colName);\n        for (let i = 0; i < frameLen; i++) {\n          values[offset + i] = series.get(i);\n        }\n      } else {\n        for (let i = 0; i < frameLen; i++) {\n          values[offset + i] = null;\n        }\n      }\n      offset += frameLen;\n    }\n    const dtype = dtypeMap.get(colName) ?? detectDType2(values);\n    resultColumns.set(colName, buildColumnFromValues5(dtype, values));\n  }\n  return new Ctor(resultColumns, allColumns);\n}\n\n// src/ops/setops.ts\nfunction serializeRow(df2, index, cols) {\n  const parts = [];\n  for (const name of cols) {\n    const v = df2.col(name).get(index);\n    if (v === null) {\n      parts.push(\"\\0null\");\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nfunction validateMatchingSchemas(left, right) {\n  const leftCols = left.columns;\n  const rightCols = right.columns;\n  if (leftCols.length !== rightCols.length) {\n    throw new ShapeMismatchError(\n      `Schema mismatch: left has ${leftCols.length} columns, right has ${rightCols.length} columns`\n    );\n  }\n  const leftDtypes = left.dtypes;\n  const rightDtypes = right.dtypes;\n  for (const name of leftCols) {\n    if (!(name in rightDtypes)) {\n      throw new ShapeMismatchError(\n        `Schema mismatch: column '${name}' not found in right DataFrame`\n      );\n    }\n    if (leftDtypes[name] !== rightDtypes[name]) {\n      throw new ShapeMismatchError(\n        `Schema mismatch: column '${name}' has dtype '${leftDtypes[name]}' in left but '${rightDtypes[name]}' in right`\n      );\n    }\n  }\n}\nfunction buildColumnFromValues6(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction collectRows(df2, indices) {\n  const cols = df2.columns;\n  const dtypes = df2.dtypes;\n  const resultColumns = /* @__PURE__ */ new Map();\n  for (const name of cols) {\n    const series = df2.col(name);\n    const values = [];\n    for (const idx of indices) {\n      values.push(series.get(idx));\n    }\n    resultColumns.set(name, buildColumnFromValues6(dtypes[name], values));\n  }\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, [...cols]);\n}\nfunction union(left, right) {\n  validateMatchingSchemas(left, right);\n  const cols = left.columns;\n  const dtypes = left.dtypes;\n  const seen = /* @__PURE__ */ new Set();\n  const valueArrays = /* @__PURE__ */ new Map();\n  for (const name of cols) {\n    valueArrays.set(name, []);\n  }\n  for (let i = 0; i < left.length; i++) {\n    const key = serializeRow(left, i, cols);\n    if (!seen.has(key)) {\n      seen.add(key);\n      for (const name of cols) {\n        valueArrays.get(name).push(left.col(name).get(i));\n      }\n    }\n  }\n  for (let i = 0; i < right.length; i++) {\n    const key = serializeRow(right, i, cols);\n    if (!seen.has(key)) {\n      seen.add(key);\n      for (const name of cols) {\n        valueArrays.get(name).push(right.col(name).get(i));\n      }\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  for (const name of cols) {\n    resultColumns.set(name, buildColumnFromValues6(dtypes[name], valueArrays.get(name)));\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, [...cols]);\n}\nfunction intersection(left, right) {\n  validateMatchingSchemas(left, right);\n  const cols = left.columns;\n  const rightKeys = /* @__PURE__ */ new Set();\n  for (let i = 0; i < right.length; i++) {\n    rightKeys.add(serializeRow(right, i, cols));\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const indices = [];\n  for (let i = 0; i < left.length; i++) {\n    const key = serializeRow(left, i, cols);\n    if (rightKeys.has(key) && !seen.has(key)) {\n      seen.add(key);\n      indices.push(i);\n    }\n  }\n  return collectRows(left, indices);\n}\nfunction difference(left, right) {\n  validateMatchingSchemas(left, right);\n  const cols = left.columns;\n  const rightKeys = /* @__PURE__ */ new Set();\n  for (let i = 0; i < right.length; i++) {\n    rightKeys.add(serializeRow(right, i, cols));\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const indices = [];\n  for (let i = 0; i < left.length; i++) {\n    const key = serializeRow(left, i, cols);\n    if (!rightKeys.has(key) && !seen.has(key)) {\n      seen.add(key);\n      indices.push(i);\n    }\n  }\n  return collectRows(left, indices);\n}\n\n// src/io/sql/writer.ts\nfunction escapeIdentifier(name) {\n  return `\"${name.replace(/\"/g, '\"\"')}\"`;\n}\nfunction escapeSQLValue(value) {\n  if (value === null || value === void 0) {\n    return \"NULL\";\n  }\n  if (typeof value === \"boolean\") {\n    return value ? \"TRUE\" : \"FALSE\";\n  }\n  if (typeof value === \"number\") {\n    if (!isFinite(value)) {\n      return \"NULL\";\n    }\n    return String(value);\n  }\n  if (typeof value === \"bigint\") {\n    return String(value);\n  }\n  if (value instanceof Date) {\n    return `'${value.toISOString()}'`;\n  }\n  if (typeof value === \"string\") {\n    return `'${value.replace(/'/g, \"''\")}'`;\n  }\n  const json = JSON.stringify(value);\n  return `'${json.replace(/'/g, \"''\")}'`;\n}\nfunction writeSQL(tableName, header, rows, options = {}) {\n  const batchSize = options.batchSize ?? 1e3;\n  if (header.length === 0 || rows.length === 0) {\n    return \"\";\n  }\n  const columnList = header.map(escapeIdentifier).join(\", \");\n  const statements = [];\n  for (let i = 0; i < rows.length; i += batchSize) {\n    const batch = rows.slice(i, i + batchSize);\n    const valueRows = batch.map((row) => {\n      const values = row.map(escapeSQLValue).join(\", \");\n      return `(${values})`;\n    });\n    statements.push(\n      `INSERT INTO ${escapeIdentifier(tableName)} (${columnList}) VALUES\n${valueRows.join(\",\\n\")};`\n    );\n  }\n  return statements.join(\"\\n\\n\");\n}\n\n// src/engine/lazy/plan.ts\nvar nextNodeId = 0;\nfunction createScanNode() {\n  return { type: \"scan\", id: nextNodeId++ };\n}\nfunction explainPlan(node, indent = 0) {\n  const pad = \"  \".repeat(indent);\n  switch (node.type) {\n    case \"scan\":\n      if (node.projection) {\n        return `${pad}SCAN [id=${node.id}, cols=${node.projection.join(\", \")}]`;\n      }\n      return `${pad}SCAN [id=${node.id}]`;\n    case \"filter\":\n      return `${pad}FILTER [${node.predicate.toString()}]\n${explainPlan(node.input, indent + 1)}`;\n    case \"select\":\n      return `${pad}SELECT [${node.columns.join(\", \")}]\n${explainPlan(node.input, indent + 1)}`;\n    case \"project\": {\n      const exprStrs = node.exprs.map((e) => e.toString()).join(\", \");\n      return `${pad}PROJECT [${exprStrs}]\n${explainPlan(node.input, indent + 1)}`;\n    }\n    case \"groupby\": {\n      const aggStrs = node.aggs.map((a) => a.toString()).join(\", \");\n      return `${pad}GROUPBY [keys: ${node.keys.join(\", \")}; aggs: ${aggStrs}]\n${explainPlan(node.input, indent + 1)}`;\n    }\n    case \"join\":\n      return `${pad}JOIN [${node.how}]\n${pad}  left:\n${explainPlan(node.left, indent + 2)}\n${pad}  right:\n${explainPlan(node.right, indent + 2)}`;\n    case \"sort\":\n      return `${pad}SORT [${node.by} ${node.descending ? \"DESC\" : \"ASC\"}]\n${explainPlan(node.input, indent + 1)}`;\n    case \"limit\":\n      return `${pad}LIMIT [${node.n}]\n${explainPlan(node.input, indent + 1)}`;\n    case \"distinct\":\n      return `${pad}DISTINCT${node.subset ? ` [${node.subset.join(\", \")}]` : \"\"}\n${explainPlan(node.input, indent + 1)}`;\n  }\n}\n\n// src/engine/lazy/executor.ts\nfunction execute(plan, source) {\n  function run(node) {\n    switch (node.type) {\n      case \"scan\":\n        if (node.projection) {\n          return source.select(...node.projection);\n        }\n        return source;\n      case \"filter\": {\n        const input = run(node.input);\n        return input.filter(node.predicate);\n      }\n      case \"select\": {\n        const input = run(node.input);\n        return input.select(...node.columns);\n      }\n      case \"project\": {\n        const input = run(node.input);\n        let result = input;\n        for (const expr of node.exprs) {\n          const series = expr.evaluate(input);\n          result = result.withColumn(series.name, expr);\n        }\n        return result;\n      }\n      case \"groupby\": {\n        const input = run(node.input);\n        const gb = input.groupBy(...node.keys);\n        const specs = {};\n        for (const aggExpr of node.aggs) {\n          const agg = aggExpr;\n          const deps = agg.dependencies;\n          const outputName = deps[0] ?? \"value\";\n          specs[outputName] = agg;\n        }\n        return gb.agg(specs);\n      }\n      case \"sort\": {\n        const input = run(node.input);\n        return input.sortBy(node.by, node.descending ? \"desc\" : \"asc\");\n      }\n      case \"limit\": {\n        const input = run(node.input);\n        return input.head(node.n);\n      }\n      case \"distinct\": {\n        const input = run(node.input);\n        return input.unique(node.subset);\n      }\n      case \"join\": {\n        const left = run(node.left);\n        const right = run(node.right);\n        return left.join(right, node.on, node.how);\n      }\n    }\n  }\n  return run(plan);\n}\n\n// src/engine/lazy/optimizer.ts\nfunction optimize(plan) {\n  const optimized = pushDown(plan);\n  const merged = mergeFilters(optimized);\n  return pushProjectionDown(merged);\n}\nfunction pushDown(node) {\n  switch (node.type) {\n    case \"scan\":\n      return node;\n    case \"filter\": {\n      const input = pushDown(node.input);\n      const filter = { type: \"filter\", input, predicate: node.predicate };\n      return pushFilterDown(filter);\n    }\n    case \"select\":\n      return { type: \"select\", input: pushDown(node.input), columns: node.columns };\n    case \"project\":\n      return { type: \"project\", input: pushDown(node.input), exprs: node.exprs };\n    case \"groupby\":\n      return { type: \"groupby\", input: pushDown(node.input), keys: node.keys, aggs: node.aggs };\n    case \"sort\":\n      return { type: \"sort\", input: pushDown(node.input), by: node.by, descending: node.descending };\n    case \"limit\":\n      return { type: \"limit\", input: pushDown(node.input), n: node.n };\n    case \"distinct\":\n      return { type: \"distinct\", input: pushDown(node.input), subset: node.subset };\n    case \"join\":\n      return { type: \"join\", left: pushDown(node.left), right: pushDown(node.right), on: node.on, how: node.how };\n  }\n}\nfunction pushFilterDown(filter) {\n  const child = filter.input;\n  switch (child.type) {\n    // Safe to push filter below select/project\n    case \"select\":\n      return {\n        type: \"select\",\n        input: pushFilterDown({ type: \"filter\", input: child.input, predicate: filter.predicate }),\n        columns: child.columns\n      };\n    case \"project\":\n      return {\n        type: \"project\",\n        input: pushFilterDown({ type: \"filter\", input: child.input, predicate: filter.predicate }),\n        exprs: child.exprs\n      };\n    // Safe to push filter below sort\n    case \"sort\":\n      return {\n        type: \"sort\",\n        input: pushFilterDown({ type: \"filter\", input: child.input, predicate: filter.predicate }),\n        by: child.by,\n        descending: child.descending\n      };\n    // NOT safe to push below groupby — changes semantics\n    case \"groupby\":\n      return filter;\n    // For all other node types, keep filter in place\n    default:\n      return filter;\n  }\n}\nfunction mergeFilters(node) {\n  switch (node.type) {\n    case \"scan\":\n      return node;\n    case \"filter\": {\n      const input = mergeFilters(node.input);\n      if (input.type === \"filter\") {\n        return {\n          type: \"filter\",\n          input: input.input,\n          predicate: input.predicate.and(node.predicate)\n        };\n      }\n      return { type: \"filter\", input, predicate: node.predicate };\n    }\n    case \"select\":\n      return { type: \"select\", input: mergeFilters(node.input), columns: node.columns };\n    case \"project\":\n      return { type: \"project\", input: mergeFilters(node.input), exprs: node.exprs };\n    case \"groupby\":\n      return { type: \"groupby\", input: mergeFilters(node.input), keys: node.keys, aggs: node.aggs };\n    case \"sort\":\n      return { type: \"sort\", input: mergeFilters(node.input), by: node.by, descending: node.descending };\n    case \"limit\":\n      return { type: \"limit\", input: mergeFilters(node.input), n: node.n };\n    case \"distinct\":\n      return { type: \"distinct\", input: mergeFilters(node.input), subset: node.subset };\n    case \"join\":\n      return { type: \"join\", left: mergeFilters(node.left), right: mergeFilters(node.right), on: node.on, how: node.how };\n  }\n}\nfunction pushProjectionDown(node, needed) {\n  switch (node.type) {\n    case \"scan\": {\n      if (needed && needed.size > 0) {\n        const projection = [...needed].sort();\n        return { type: \"scan\", id: node.id, projection };\n      }\n      return node;\n    }\n    case \"select\": {\n      const childNeeded = new Set(node.columns);\n      return { type: \"select\", input: pushProjectionDown(node.input, childNeeded), columns: node.columns };\n    }\n    case \"filter\": {\n      const childNeeded = new Set(needed);\n      for (const dep of node.predicate.dependencies) {\n        childNeeded.add(dep);\n      }\n      return { type: \"filter\", input: pushProjectionDown(node.input, childNeeded), predicate: node.predicate };\n    }\n    case \"project\": {\n      const childNeeded = /* @__PURE__ */ new Set();\n      for (const expr of node.exprs) {\n        for (const dep of expr.dependencies) {\n          childNeeded.add(dep);\n        }\n      }\n      return { type: \"project\", input: pushProjectionDown(node.input, childNeeded), exprs: node.exprs };\n    }\n    case \"groupby\": {\n      const childNeeded = new Set(node.keys);\n      for (const agg of node.aggs) {\n        for (const dep of agg.dependencies) {\n          childNeeded.add(dep);\n        }\n      }\n      return { type: \"groupby\", input: pushProjectionDown(node.input, childNeeded), keys: node.keys, aggs: node.aggs };\n    }\n    case \"sort\": {\n      const childNeeded = new Set(needed);\n      childNeeded.add(node.by);\n      return { type: \"sort\", input: pushProjectionDown(node.input, childNeeded), by: node.by, descending: node.descending };\n    }\n    case \"limit\":\n      return { type: \"limit\", input: pushProjectionDown(node.input, needed), n: node.n };\n    case \"distinct\": {\n      if (node.subset) {\n        const childNeeded = new Set(needed);\n        for (const col2 of node.subset) {\n          childNeeded.add(col2);\n        }\n        return { type: \"distinct\", input: pushProjectionDown(node.input, childNeeded), subset: node.subset };\n      }\n      return { type: \"distinct\", input: pushProjectionDown(node.input, needed), subset: node.subset };\n    }\n    case \"join\": {\n      const onCols = typeof node.on === \"string\" ? [node.on] : node.on;\n      const leftNeeded = new Set(needed);\n      const rightNeeded = new Set(needed);\n      for (const c of onCols) {\n        leftNeeded.add(c);\n        rightNeeded.add(c);\n      }\n      return { type: \"join\", left: pushProjectionDown(node.left, leftNeeded), right: pushProjectionDown(node.right, rightNeeded), on: node.on, how: node.how };\n    }\n  }\n}\n\n// src/lazy.ts\nvar LazyGroupBy = class {\n  /** @internal */\n  _source;\n  /** @internal */\n  _plan;\n  /** @internal */\n  _keys;\n  constructor(source, plan, keys) {\n    this._source = source;\n    this._plan = plan;\n    this._keys = keys;\n  }\n  agg(...specs) {\n    return new LazyFrame(this._source, {\n      type: \"groupby\",\n      input: this._plan,\n      keys: [...this._keys],\n      aggs: specs\n    });\n  }\n};\nvar LazyFrame = class _LazyFrame {\n  /** @internal */\n  _source;\n  /** @internal */\n  _plan;\n  constructor(source, plan) {\n    this._source = source;\n    this._plan = plan;\n  }\n  filter(predicate) {\n    return new _LazyFrame(this._source, {\n      type: \"filter\",\n      input: this._plan,\n      predicate\n    });\n  }\n  select(...columns) {\n    return new _LazyFrame(this._source, {\n      type: \"select\",\n      input: this._plan,\n      columns\n    });\n  }\n  project(...exprs) {\n    return new _LazyFrame(this._source, {\n      type: \"project\",\n      input: this._plan,\n      exprs\n    });\n  }\n  sort(by, descending = false) {\n    return new _LazyFrame(this._source, {\n      type: \"sort\",\n      input: this._plan,\n      by,\n      descending\n    });\n  }\n  sortBy(by, descending = false) {\n    return this.sort(by, descending);\n  }\n  limit(n) {\n    return new _LazyFrame(this._source, {\n      type: \"limit\",\n      input: this._plan,\n      n\n    });\n  }\n  head(n) {\n    return this.limit(n);\n  }\n  distinct(subset) {\n    return new _LazyFrame(this._source, {\n      type: \"distinct\",\n      input: this._plan,\n      subset\n    });\n  }\n  unique(subset) {\n    return this.distinct(subset);\n  }\n  groupBy(...keys) {\n    return new LazyGroupBy(this._source, this._plan, keys);\n  }\n  explain() {\n    const original = explainPlan(this._plan);\n    const optimizedPlan = optimize(this._plan);\n    const optimized = explainPlan(optimizedPlan);\n    return `ORIGINAL:\n${original}\n\nOPTIMIZED:\n${optimized}`;\n  }\n  collect() {\n    return Promise.resolve(execute(this._plan, this._source));\n  }\n  async sink(filePath) {\n    const df2 = await this.collect();\n    const ext = filePath.toLowerCase();\n    if (ext.endsWith(\".csv\") || ext.endsWith(\".tsv\")) {\n      await df2.toCSV(filePath);\n    } else if (ext.endsWith(\".ndjson\") || ext.endsWith(\".jsonl\")) {\n      await df2.toNDJSON(filePath);\n    } else {\n      throw new Error(`Unsupported sink format for '${filePath}'. Supported: .csv, .tsv, .ndjson, .jsonl`);\n    }\n  }\n};\nfunction createLazyFrame(source) {\n  return new LazyFrame(source, createScanNode());\n}\n\n// src/ops/query.ts\nvar KEYWORDS = /* @__PURE__ */ new Set([\n  \"SELECT\",\n  \"FROM\",\n  \"WHERE\",\n  \"ORDER\",\n  \"BY\",\n  \"LIMIT\",\n  \"GROUP\",\n  \"HAVING\",\n  \"AND\",\n  \"OR\",\n  \"IN\",\n  \"LIKE\",\n  \"IS\",\n  \"NOT\",\n  \"NULL\",\n  \"ASC\",\n  \"DESC\",\n  \"AS\"\n]);\nfunction tokenize(input) {\n  const tokens = [];\n  let i = 0;\n  while (i < input.length) {\n    if (/\\s/.test(input[i])) {\n      i++;\n      continue;\n    }\n    const pos = i;\n    if (input[i] === \"'\") {\n      i++;\n      let value = \"\";\n      while (i < input.length && input[i] !== \"'\") {\n        if (input[i] === \"'\" && input[i + 1] === \"'\") {\n          value += \"'\";\n          i += 2;\n        } else {\n          value += input[i];\n          i++;\n        }\n      }\n      if (i >= input.length) {\n        throw new ParseError(`Unterminated string literal at position ${pos}`);\n      }\n      i++;\n      tokens.push({ type: \"STRING\" /* STRING */, value, position: pos });\n      continue;\n    }\n    if (/\\d/.test(input[i]) || input[i] === \"-\" && i + 1 < input.length && /\\d/.test(input[i + 1])) {\n      let value = \"\";\n      if (input[i] === \"-\") {\n        value += \"-\";\n        i++;\n      }\n      while (i < input.length && /[\\d.]/.test(input[i])) {\n        value += input[i];\n        i++;\n      }\n      tokens.push({ type: \"NUMBER\" /* NUMBER */, value, position: pos });\n      continue;\n    }\n    if (input[i] === \"*\") {\n      tokens.push({ type: \"STAR\" /* STAR */, value: \"*\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \",\") {\n      tokens.push({ type: \"COMMA\" /* COMMA */, value: \",\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \"(\") {\n      tokens.push({ type: \"LPAREN\" /* LPAREN */, value: \"(\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \")\") {\n      tokens.push({ type: \"RPAREN\" /* RPAREN */, value: \")\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \"!\" && input[i + 1] === \"=\") {\n      tokens.push({ type: \"NEQ\" /* NEQ */, value: \"!=\", position: pos });\n      i += 2;\n      continue;\n    }\n    if (input[i] === \"<\" && input[i + 1] === \">\") {\n      tokens.push({ type: \"NEQ\" /* NEQ */, value: \"<>\", position: pos });\n      i += 2;\n      continue;\n    }\n    if (input[i] === \">\" && input[i + 1] === \"=\") {\n      tokens.push({ type: \"GTE\" /* GTE */, value: \">=\", position: pos });\n      i += 2;\n      continue;\n    }\n    if (input[i] === \"<\" && input[i + 1] === \"=\") {\n      tokens.push({ type: \"LTE\" /* LTE */, value: \"<=\", position: pos });\n      i += 2;\n      continue;\n    }\n    if (input[i] === \">\") {\n      tokens.push({ type: \"GT\" /* GT */, value: \">\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \"<\") {\n      tokens.push({ type: \"LT\" /* LT */, value: \"<\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \"=\") {\n      tokens.push({ type: \"EQ\" /* EQ */, value: \"=\", position: pos });\n      i++;\n      continue;\n    }\n    if (/[a-zA-Z_]/.test(input[i])) {\n      let value = \"\";\n      while (i < input.length && /[a-zA-Z0-9_]/.test(input[i])) {\n        value += input[i];\n        i++;\n      }\n      const upper = value.toUpperCase();\n      if (KEYWORDS.has(upper)) {\n        tokens.push({ type: upper, value: upper, position: pos });\n      } else {\n        tokens.push({ type: \"IDENTIFIER\" /* IDENTIFIER */, value, position: pos });\n      }\n      continue;\n    }\n    throw new ParseError(`Unexpected character '${input[i]}' at position ${pos}`);\n  }\n  tokens.push({ type: \"EOF\" /* EOF */, value: \"\", position: i });\n  return tokens;\n}\nvar Parser = class {\n  tokens;\n  pos;\n  _selectItems = [];\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.pos = 0;\n  }\n  current() {\n    return this.tokens[this.pos];\n  }\n  peek() {\n    return this.tokens[this.pos];\n  }\n  advance() {\n    const token = this.tokens[this.pos];\n    this.pos++;\n    return token;\n  }\n  expect(type) {\n    const token = this.current();\n    if (token.type !== type) {\n      throw new ParseError(\n        `Expected ${type} but got '${token.value}' at position ${token.position}`\n      );\n    }\n    return this.advance();\n  }\n  match(type) {\n    if (this.current().type === type) {\n      this.advance();\n      return true;\n    }\n    return false;\n  }\n  parse() {\n    this.expect(\"SELECT\" /* SELECT */);\n    let selectAll = false;\n    const selectItems = [];\n    if (this.current().type === \"STAR\" /* STAR */) {\n      selectAll = true;\n      this.advance();\n    } else {\n      selectItems.push(this.parseSelectItem());\n      while (this.match(\"COMMA\" /* COMMA */)) {\n        selectItems.push(this.parseSelectItem());\n      }\n    }\n    this._selectItems = selectItems;\n    this.expect(\"FROM\" /* FROM */);\n    const fromToken = this.expect(\"IDENTIFIER\" /* IDENTIFIER */);\n    if (fromToken.value !== \"this\") {\n      throw new ParseError(\n        `FROM clause must reference 'this', got '${fromToken.value}' at position ${fromToken.position}`\n      );\n    }\n    let whereExpr;\n    if (this.current().type === \"WHERE\" /* WHERE */) {\n      this.advance();\n      whereExpr = this.parseOrExpr();\n    }\n    const groupByColumns = [];\n    if (this.current().type === \"GROUP\" /* GROUP */) {\n      this.advance();\n      this.expect(\"BY\" /* BY */);\n      groupByColumns.push(this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value);\n      while (this.match(\"COMMA\" /* COMMA */)) {\n        groupByColumns.push(this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value);\n      }\n    }\n    let havingExpr;\n    if (this.current().type === \"HAVING\" /* HAVING */) {\n      this.advance();\n      havingExpr = this.parseOrExpr();\n    }\n    const orderByItems = [];\n    if (this.current().type === \"ORDER\" /* ORDER */) {\n      this.advance();\n      this.expect(\"BY\" /* BY */);\n      orderByItems.push(this.parseOrderByItem());\n      while (this.match(\"COMMA\" /* COMMA */)) {\n        orderByItems.push(this.parseOrderByItem());\n      }\n    }\n    let limit;\n    if (this.current().type === \"LIMIT\" /* LIMIT */) {\n      this.advance();\n      const num = this.expect(\"NUMBER\" /* NUMBER */);\n      limit = parseInt(num.value, 10);\n    }\n    if (this.current().type !== \"EOF\" /* EOF */) {\n      throw new ParseError(\n        `Unexpected token '${this.current().value}' at position ${this.current().position}`\n      );\n    }\n    return { selectItems, selectAll, whereExpr, groupByColumns, havingExpr, orderByItems, limit };\n  }\n  parseSelectItem() {\n    const token = this.current();\n    const upperVal = token.value.toUpperCase();\n    if (token.type === \"IDENTIFIER\" /* IDENTIFIER */ && [\"SUM\", \"AVG\", \"COUNT\", \"MIN\", \"MAX\"].includes(upperVal) && this.tokens[this.pos + 1]?.type === \"LPAREN\" /* LPAREN */) {\n      const aggName = upperVal;\n      this.advance();\n      this.advance();\n      let columnName;\n      if (this.current().type === \"STAR\" /* STAR */) {\n        columnName = \"*\";\n        this.advance();\n      } else {\n        columnName = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n      }\n      this.expect(\"RPAREN\" /* RPAREN */);\n      let alias2;\n      if (this.current().type === \"AS\" /* AS */) {\n        this.advance();\n        alias2 = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n      }\n      return { column: columnName, alias: alias2, aggregate: aggName };\n    }\n    const colName = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    let alias;\n    if (this.current().type === \"AS\" /* AS */) {\n      this.advance();\n      alias = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    }\n    return { column: colName, alias, aggregate: void 0 };\n  }\n  parseOrderByItem() {\n    const column = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    let direction = \"asc\";\n    if (this.current().type === \"ASC\" /* ASC */) {\n      this.advance();\n      direction = \"asc\";\n    } else if (this.current().type === \"DESC\" /* DESC */) {\n      this.advance();\n      direction = \"desc\";\n    }\n    return { column, direction };\n  }\n  // ── Expression parsing (WHERE / HAVING) ──\n  parseOrExpr() {\n    let left = this.parseAndExpr();\n    while (this.current().type === \"OR\" /* OR */) {\n      this.advance();\n      const right = this.parseAndExpr();\n      left = left.or(right);\n    }\n    return left;\n  }\n  parseAndExpr() {\n    let left = this.parseComparison();\n    while (this.current().type === \"AND\" /* AND */) {\n      this.advance();\n      const right = this.parseComparison();\n      left = left.and(right);\n    }\n    return left;\n  }\n  parseComparison() {\n    if (this.current().type === \"LPAREN\" /* LPAREN */) {\n      this.advance();\n      const expr = this.parseOrExpr();\n      this.expect(\"RPAREN\" /* RPAREN */);\n      return expr;\n    }\n    if (this.current().type === \"NOT\" /* NOT */) {\n      this.advance();\n      const expr = this.parseComparison();\n      return expr.not();\n    }\n    const leftToken = this.current();\n    const upperVal = leftToken.value.toUpperCase();\n    if (leftToken.type === \"IDENTIFIER\" /* IDENTIFIER */ && [\"SUM\", \"AVG\", \"COUNT\", \"MIN\", \"MAX\"].includes(upperVal) && this.tokens[this.pos + 1]?.type === \"LPAREN\" /* LPAREN */) {\n      return this.parseAggregateComparison();\n    }\n    const columnName = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    const colExpr = col(columnName);\n    if (this.current().type === \"IS\" /* IS */) {\n      this.advance();\n      if (this.current().type === \"NOT\" /* NOT */) {\n        this.advance();\n        this.expect(\"NULL\" /* NULL */);\n        return new IsNullExpr2(columnName, true);\n      }\n      this.expect(\"NULL\" /* NULL */);\n      return new IsNullExpr2(columnName, false);\n    }\n    if (this.current().type === \"NOT\" /* NOT */) {\n      this.advance();\n      if (this.current().type === \"IN\" /* IN */) {\n        this.advance();\n        const values = this.parseValueList();\n        let inExpr = colExpr.eq(lit(values[0]));\n        for (let i = 1; i < values.length; i++) {\n          inExpr = inExpr.or(colExpr.eq(lit(values[i])));\n        }\n        return inExpr.not();\n      }\n      if (this.current().type === \"LIKE\" /* LIKE */) {\n        this.advance();\n        const pattern = this.expect(\"STRING\" /* STRING */).value;\n        return this.buildLikeExpr(columnName, pattern).not();\n      }\n      throw new ParseError(`Expected IN or LIKE after NOT at position ${this.current().position}`);\n    }\n    if (this.current().type === \"IN\" /* IN */) {\n      this.advance();\n      const values = this.parseValueList();\n      let inExpr = colExpr.eq(lit(values[0]));\n      for (let i = 1; i < values.length; i++) {\n        inExpr = inExpr.or(colExpr.eq(lit(values[i])));\n      }\n      return inExpr;\n    }\n    if (this.current().type === \"LIKE\" /* LIKE */) {\n      this.advance();\n      const pattern = this.expect(\"STRING\" /* STRING */).value;\n      return this.buildLikeExpr(columnName, pattern);\n    }\n    const op = this.current();\n    this.advance();\n    const rightValue = this.parseLiteralValue();\n    switch (op.type) {\n      case \"EQ\" /* EQ */:\n        return colExpr.eq(lit(rightValue));\n      case \"NEQ\" /* NEQ */:\n        return colExpr.neq(lit(rightValue));\n      case \"GT\" /* GT */:\n        return colExpr.gt(lit(rightValue));\n      case \"GTE\" /* GTE */:\n        return colExpr.gte(lit(rightValue));\n      case \"LT\" /* LT */:\n        return colExpr.lt(lit(rightValue));\n      case \"LTE\" /* LTE */:\n        return colExpr.lte(lit(rightValue));\n      default:\n        throw new ParseError(`Expected comparison operator at position ${op.position}, got '${op.value}'`);\n    }\n  }\n  parseAggregateComparison() {\n    const aggName = this.advance().value.toUpperCase();\n    this.expect(\"LPAREN\" /* LPAREN */);\n    let columnName;\n    if (this.current().type === \"STAR\" /* STAR */) {\n      columnName = \"*\";\n      this.advance();\n    } else {\n      columnName = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    }\n    this.expect(\"RPAREN\" /* RPAREN */);\n    const matchingSelect = this._selectItems.find(\n      (item) => item.aggregate === aggName && item.column === columnName\n    );\n    const aggAlias = matchingSelect?.alias ?? (columnName === \"*\" ? `${aggName.toLowerCase()}` : `${aggName.toLowerCase()}_${columnName}`);\n    const aggColExpr = col(aggAlias);\n    const op = this.current();\n    this.advance();\n    const rightValue = this.parseLiteralValue();\n    switch (op.type) {\n      case \"EQ\" /* EQ */:\n        return aggColExpr.eq(lit(rightValue));\n      case \"NEQ\" /* NEQ */:\n        return aggColExpr.neq(lit(rightValue));\n      case \"GT\" /* GT */:\n        return aggColExpr.gt(lit(rightValue));\n      case \"GTE\" /* GTE */:\n        return aggColExpr.gte(lit(rightValue));\n      case \"LT\" /* LT */:\n        return aggColExpr.lt(lit(rightValue));\n      case \"LTE\" /* LTE */:\n        return aggColExpr.lte(lit(rightValue));\n      default:\n        throw new ParseError(`Expected comparison operator at position ${op.position}, got '${op.value}'`);\n    }\n  }\n  parseLiteralValue() {\n    const token = this.current();\n    if (token.type === \"NUMBER\" /* NUMBER */) {\n      this.advance();\n      return parseFloat(token.value);\n    }\n    if (token.type === \"STRING\" /* STRING */) {\n      this.advance();\n      return token.value;\n    }\n    if (token.type === \"NULL\" /* NULL */) {\n      this.advance();\n      return null;\n    }\n    if (token.type === \"IDENTIFIER\" /* IDENTIFIER */) {\n      const upper = token.value.toUpperCase();\n      if (upper === \"TRUE\") {\n        this.advance();\n        return true;\n      }\n      if (upper === \"FALSE\") {\n        this.advance();\n        return false;\n      }\n    }\n    throw new ParseError(`Expected literal value at position ${token.position}, got '${token.value}'`);\n  }\n  parseValueList() {\n    this.expect(\"LPAREN\" /* LPAREN */);\n    const values = [];\n    values.push(this.parseLiteralValue());\n    while (this.match(\"COMMA\" /* COMMA */)) {\n      values.push(this.parseLiteralValue());\n    }\n    this.expect(\"RPAREN\" /* RPAREN */);\n    return values;\n  }\n  buildLikeExpr(columnName, pattern) {\n    const regexStr = \"^\" + pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/%/g, \".*\").replace(/_/g, \".\") + \"$\";\n    return new LikeExpr(columnName, regexStr);\n  }\n};\nvar LikeExpr = class extends Expr {\n  _columnName;\n  _regexStr;\n  constructor(columnName, regexStr) {\n    super();\n    this._columnName = columnName;\n    this._regexStr = regexStr;\n  }\n  get dependencies() {\n    return [this._columnName];\n  }\n  evaluate(df2) {\n    const series = df2.col(this._columnName);\n    const regex = new RegExp(this._regexStr);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.column.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(regex.test(typeof val === \"string\" ? val : `${val}`));\n      }\n    }\n    return new Series(\"like_result\", BooleanColumn.from(results));\n  }\n  toString() {\n    return `LIKE(${this._columnName}, ${this._regexStr})`;\n  }\n};\nvar IsNullExpr2 = class extends Expr {\n  _columnName;\n  _invert;\n  constructor(columnName, invert) {\n    super();\n    this._columnName = columnName;\n    this._invert = invert;\n  }\n  get dependencies() {\n    return [this._columnName];\n  }\n  evaluate(df2) {\n    const series = df2.col(this._columnName);\n    return this._invert ? series.isNotNull() : series.isNull();\n  }\n  toString() {\n    return `${this._columnName} IS ${this._invert ? \"NOT \" : \"\"}NULL`;\n  }\n};\nfunction buildAggSpec(selectItems, groupByColumns) {\n  const specs = {};\n  for (const item of selectItems) {\n    if (groupByColumns.includes(item.column)) continue;\n    if (item.aggregate === void 0) continue;\n    const alias = item.alias ?? (item.column === \"*\" ? `${item.aggregate.toLowerCase()}` : `${item.aggregate.toLowerCase()}_${item.column}`);\n    const sourceCol = item.column === \"*\" ? groupByColumns[0] : item.column;\n    const colRef = col(sourceCol);\n    switch (item.aggregate) {\n      case \"SUM\":\n        specs[alias] = colRef.sum();\n        break;\n      case \"AVG\":\n        specs[alias] = colRef.mean();\n        break;\n      case \"COUNT\":\n        specs[alias] = colRef.count();\n        break;\n      case \"MIN\":\n        specs[alias] = colRef.min();\n        break;\n      case \"MAX\":\n        specs[alias] = colRef.max();\n        break;\n    }\n  }\n  return specs;\n}\nfunction executeQuery(df2, queryStr) {\n  const tokens = tokenize(queryStr);\n  const parser = new Parser(tokens);\n  const query = parser.parse();\n  let result = df2;\n  if (query.whereExpr !== void 0) {\n    result = result.filter(query.whereExpr);\n  }\n  if (query.groupByColumns.length > 0) {\n    const aggSpec = buildAggSpec(query.selectItems, query.groupByColumns);\n    const group = result.groupBy(...query.groupByColumns);\n    result = group.agg(aggSpec);\n    if (query.havingExpr !== void 0) {\n      result = result.filter(query.havingExpr);\n    }\n    if (!query.selectAll) {\n      const selectedCols = [];\n      for (const item of query.selectItems) {\n        if (item.aggregate !== void 0) {\n          const alias = item.alias ?? (item.column === \"*\" ? `${item.aggregate.toLowerCase()}` : `${item.aggregate.toLowerCase()}_${item.column}`);\n          selectedCols.push(alias);\n        } else {\n          selectedCols.push(item.alias ?? item.column);\n        }\n      }\n      result = result.select(...selectedCols);\n    }\n  } else {\n    if (!query.selectAll) {\n      const columnNames = query.selectItems.map((item) => item.column);\n      result = result.select(...columnNames);\n      const renameMap = {};\n      for (const item of query.selectItems) {\n        if (item.alias !== void 0) {\n          renameMap[item.column] = item.alias;\n        }\n      }\n      if (Object.keys(renameMap).length > 0) {\n        result = result.rename(renameMap);\n      }\n    }\n  }\n  if (query.orderByItems.length > 0) {\n    const columns = query.orderByItems.map((item) => item.column);\n    const orders = query.orderByItems.map((item) => item.direction);\n    result = result.sortBy(columns, orders);\n  }\n  if (query.limit !== void 0) {\n    result = result.head(query.limit);\n  }\n  return result;\n}\n\n// src/dataframe.ts\nvar DataFrame = class _DataFrame {\n  static _readers = /* @__PURE__ */ new Map();\n  static _writers = /* @__PURE__ */ new Map();\n  _columns;\n  _columnOrder;\n  constructor(columns, columnOrder) {\n    this._columns = columns;\n    this._columnOrder = columnOrder;\n    for (const col2 of columns.values()) {\n      col2.addRef();\n    }\n  }\n  get shape() {\n    return [this.length, this._columnOrder.length];\n  }\n  get columns() {\n    return [...this._columnOrder];\n  }\n  get dtypes() {\n    const result = {};\n    for (const name of this._columnOrder) {\n      result[name] = this._columns.get(name).dtype;\n    }\n    return result;\n  }\n  get length() {\n    if (this._columnOrder.length === 0) return 0;\n    return this._columns.get(this._columnOrder[0]).length;\n  }\n  col(name) {\n    const column = this._columns.get(name);\n    if (!column) {\n      throw new ColumnNotFoundError(name, this._columnOrder);\n    }\n    return new Series(name, column);\n  }\n  row(index) {\n    if (index < 0 || index >= this.length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Row index ${index} out of bounds for DataFrame with ${this.length} rows`\n      );\n    }\n    const result = {};\n    for (const name of this._columnOrder) {\n      result[name] = this._columns.get(name).get(index);\n    }\n    return result;\n  }\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.length; i++) {\n      yield this.row(i);\n    }\n  }\n  rows() {\n    return this[Symbol.iterator]();\n  }\n  toArray() {\n    const result = [];\n    for (let i = 0; i < this.length; i++) {\n      result.push(this.row(i));\n    }\n    return result;\n  }\n  clone() {\n    const clonedColumns = /* @__PURE__ */ new Map();\n    for (const [name, col2] of this._columns) {\n      clonedColumns.set(name, col2.clone());\n    }\n    return new _DataFrame(clonedColumns, [...this._columnOrder]);\n  }\n  reify() {\n    return this.clone();\n  }\n  lazy() {\n    return createLazyFrame(this);\n  }\n  select(...columns) {\n    for (const name of columns) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of columns) {\n      newColumns.set(name, this._columns.get(name));\n    }\n    return new _DataFrame(newColumns, [...columns]);\n  }\n  drop(...columns) {\n    for (const name of columns) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    const dropSet = new Set(columns);\n    const newColumns = /* @__PURE__ */ new Map();\n    const newOrder = [];\n    for (const name of this._columnOrder) {\n      if (!dropSet.has(name)) {\n        newColumns.set(name, this._columns.get(name));\n        newOrder.push(name);\n      }\n    }\n    return new _DataFrame(newColumns, newOrder);\n  }\n  head(n = 5) {\n    return this.slice(0, Math.min(n, this.length));\n  }\n  tail(n = 5) {\n    const start = Math.max(0, this.length - n);\n    return this.slice(start, this.length);\n  }\n  slice(start, end) {\n    const resolvedEnd = end === void 0 ? this.length : Math.min(end, this.length);\n    const resolvedStart = Math.max(0, start);\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      newColumns.set(name, this._columns.get(name).slice(resolvedStart, resolvedEnd));\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  withColumn(name, valuesOrFnOrExpr) {\n    if (valuesOrFnOrExpr instanceof Expr) {\n      const series = valuesOrFnOrExpr.evaluate(this);\n      const newColumns2 = new Map(this._columns);\n      newColumns2.set(name, series.column);\n      const newOrder2 = this._columnOrder.includes(name) ? [...this._columnOrder] : [...this._columnOrder, name];\n      return new _DataFrame(newColumns2, newOrder2);\n    }\n    let columnValues;\n    if (typeof valuesOrFnOrExpr === \"function\") {\n      const fn = valuesOrFnOrExpr;\n      columnValues = [];\n      for (let i = 0; i < this.length; i++) {\n        columnValues.push(fn(this.row(i)));\n      }\n    } else {\n      columnValues = valuesOrFnOrExpr;\n      if (columnValues.length !== this.length) {\n        throw new ShapeMismatchError(\n          `Column '${name}' has length ${columnValues.length}, expected ${this.length}`\n        );\n      }\n    }\n    const dtype = detectDType3(columnValues);\n    const newCol = buildColumn(dtype, columnValues);\n    const newColumns = new Map(this._columns);\n    newColumns.set(name, newCol);\n    const newOrder = this._columnOrder.includes(name) ? [...this._columnOrder] : [...this._columnOrder, name];\n    return new _DataFrame(newColumns, newOrder);\n  }\n  assign(other) {\n    if (other.length !== this.length && other.columns.length > 0 && this._columnOrder.length > 0) {\n      throw new ShapeMismatchError(\n        `Cannot assign DataFrame with ${other.length} rows to DataFrame with ${this.length} rows`\n      );\n    }\n    const newColumns = new Map(this._columns);\n    const newOrder = [...this._columnOrder];\n    for (const name of other.columns) {\n      newColumns.set(name, other._columns.get(name));\n      if (!this._columnOrder.includes(name)) {\n        newOrder.push(name);\n      }\n    }\n    return new _DataFrame(newColumns, newOrder);\n  }\n  derive(exprs) {\n    let result = this;\n    for (const [name, fn] of Object.entries(exprs)) {\n      if (this.length === 0) {\n        result = result.withColumn(name, []);\n        continue;\n      }\n      const first = fn(this.row(0));\n      if (first instanceof Expr) {\n        result = result.withColumn(name, first.evaluate(this).toArray());\n        continue;\n      }\n      const values = [first];\n      for (let i = 1; i < this.length; i++) {\n        values.push(fn(this.row(i)));\n      }\n      result = result.withColumn(name, values);\n    }\n    return result;\n  }\n  lookup(other, on, values) {\n    return lookup(this, other, on, values);\n  }\n  spread(column, options) {\n    return spread(this, column, options);\n  }\n  unroll(columns, options) {\n    return unroll(this, columns, options);\n  }\n  impute(values, options) {\n    return impute(this, values, options);\n  }\n  relocate(columns, options) {\n    const { before, after } = options;\n    if (before !== void 0 && after !== void 0) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        'Cannot specify both \"before\" and \"after\" in relocate'\n      );\n    }\n    if (before === void 0 && after === void 0) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        'Must specify either \"before\" or \"after\" in relocate'\n      );\n    }\n    for (const col2 of columns) {\n      if (!this._columns.has(col2)) {\n        throw new ColumnNotFoundError(col2, this._columnOrder);\n      }\n    }\n    const anchor = before ?? after;\n    if (!this._columns.has(anchor)) {\n      throw new ColumnNotFoundError(anchor, this._columnOrder);\n    }\n    const remaining = this._columnOrder.filter((c) => !columns.includes(c));\n    const anchorIdx = remaining.indexOf(anchor);\n    const insertIdx = before !== void 0 ? anchorIdx : anchorIdx + 1;\n    const newOrder = [...remaining.slice(0, insertIdx), ...columns, ...remaining.slice(insertIdx)];\n    return new _DataFrame(new Map(this._columns), newOrder);\n  }\n  rename(mapping) {\n    for (const oldName of Object.keys(mapping)) {\n      if (!this._columns.has(oldName)) {\n        throw new ColumnNotFoundError(oldName, this._columnOrder);\n      }\n    }\n    const newColumns = /* @__PURE__ */ new Map();\n    const newOrder = [];\n    for (const name of this._columnOrder) {\n      const newName = mapping[name] ?? name;\n      newColumns.set(newName, this._columns.get(name));\n      newOrder.push(newName);\n    }\n    return new _DataFrame(newColumns, newOrder);\n  }\n  filter(predicateOrExpr) {\n    if (predicateOrExpr instanceof Expr) {\n      const maybeCmp = predicateOrExpr;\n      const cmpAny = maybeCmp;\n      if (cmpAny._op !== void 0 && cmpAny._left instanceof ColumnExpr && cmpAny._right instanceof LiteralExpr) {\n        const columnName = cmpAny._left.dependencies[0];\n        const literal = cmpAny._right._value;\n        const source = this._columns.get(columnName);\n        if (source) {\n          if (source instanceof Utf8Column && source.isInterned && typeof literal === \"string\" && (cmpAny._op === \"eq\" || cmpAny._op === \"neq\")) {\n            const interned = source.internedStorage;\n            const targetIdx = interned.dictionary.indexOf(literal);\n            const isEq = cmpAny._op === \"eq\";\n            if (isEq && targetIdx === -1) {\n              return this.slice(0, 0);\n            }\n            const internedIndices = interned.indices;\n            const n = this.length;\n            if (source.allValid) {\n              let count4 = 0;\n              if (isEq) {\n                for (let i = 0; i < n; i++) {\n                  if (internedIndices[i] === targetIdx) count4++;\n                }\n              } else {\n                if (targetIdx === -1) {\n                  return this;\n                }\n                for (let i = 0; i < n; i++) {\n                  if (internedIndices[i] !== targetIdx) count4++;\n                }\n              }\n              if (count4 === n) return this;\n              if (count4 === 0) return this.slice(0, 0);\n              const indices4 = new Int32Array(count4);\n              let pos4 = 0;\n              if (isEq) {\n                for (let i = 0; i < n; i++) {\n                  if (internedIndices[i] === targetIdx) indices4[pos4++] = i;\n                }\n              } else {\n                for (let i = 0; i < n; i++) {\n                  if (internedIndices[i] !== targetIdx) indices4[pos4++] = i;\n                }\n              }\n              return this._takeByInt32Indices(indices4);\n            } else {\n              const nullMask = source.nullMask;\n              let count4 = 0;\n              if (isEq) {\n                for (let i = 0; i < n; i++) {\n                  if (nullMask.getUnsafe(i) && internedIndices[i] === targetIdx) count4++;\n                }\n              } else {\n                for (let i = 0; i < n; i++) {\n                  if (nullMask.getUnsafe(i) && internedIndices[i] !== targetIdx) count4++;\n                }\n              }\n              if (count4 === n) return this;\n              if (count4 === 0) return this.slice(0, 0);\n              const indices4 = new Int32Array(count4);\n              let pos4 = 0;\n              if (isEq) {\n                for (let i = 0; i < n; i++) {\n                  if (nullMask.getUnsafe(i) && internedIndices[i] === targetIdx) indices4[pos4++] = i;\n                }\n              } else {\n                for (let i = 0; i < n; i++) {\n                  if (nullMask.getUnsafe(i) && internedIndices[i] !== targetIdx) indices4[pos4++] = i;\n                }\n              }\n              return this._takeByInt32Indices(indices4);\n            }\n          }\n          let count3 = 0;\n          for (let i = 0; i < this.length; i++) {\n            const v = source.get(i);\n            if (v === null || literal === null) continue;\n            let keep = false;\n            switch (cmpAny._op) {\n              case \"eq\":\n                keep = v === literal;\n                break;\n              case \"neq\":\n                keep = v !== literal;\n                break;\n              case \"gt\":\n                keep = v > literal;\n                break;\n              case \"gte\":\n                keep = v >= literal;\n                break;\n              case \"lt\":\n                keep = v < literal;\n                break;\n              case \"lte\":\n                keep = v <= literal;\n                break;\n            }\n            if (keep) count3++;\n          }\n          if (count3 === this.length) {\n            return this;\n          }\n          if (count3 === 0) {\n            return this.slice(0, 0);\n          }\n          const indices3 = new Int32Array(count3);\n          let pos3 = 0;\n          for (let i = 0; i < this.length; i++) {\n            const v = source.get(i);\n            if (v === null || literal === null) continue;\n            let keep = false;\n            switch (cmpAny._op) {\n              case \"eq\":\n                keep = v === literal;\n                break;\n              case \"neq\":\n                keep = v !== literal;\n                break;\n              case \"gt\":\n                keep = v > literal;\n                break;\n              case \"gte\":\n                keep = v >= literal;\n                break;\n              case \"lt\":\n                keep = v < literal;\n                break;\n              case \"lte\":\n                keep = v <= literal;\n                break;\n            }\n            if (keep) indices3[pos3++] = i;\n          }\n          return this._takeByInt32Indices(indices3);\n        }\n      }\n      const boolSeries = predicateOrExpr.evaluate(this);\n      let count2 = 0;\n      for (let i = 0; i < this.length; i++) {\n        if (boolSeries.get(i) === true) {\n          count2++;\n        }\n      }\n      if (count2 === this.length) {\n        return this;\n      }\n      if (count2 === 0) {\n        return this.slice(0, 0);\n      }\n      const indices2 = new Int32Array(count2);\n      let pos2 = 0;\n      for (let i = 0; i < this.length; i++) {\n        if (boolSeries.get(i) === true) {\n          indices2[pos2++] = i;\n        }\n      }\n      return this._takeByInt32Indices(indices2);\n    }\n    const predicate = predicateOrExpr;\n    let count = 0;\n    for (let i = 0; i < this.length; i++) {\n      if (predicate(this.row(i))) {\n        count++;\n      }\n    }\n    if (count === this.length) {\n      return this;\n    }\n    if (count === 0) {\n      return this.slice(0, 0);\n    }\n    const indices = new Int32Array(count);\n    let pos = 0;\n    for (let i = 0; i < this.length; i++) {\n      if (predicate(this.row(i))) {\n        indices[pos++] = i;\n      }\n    }\n    return this._takeByInt32Indices(indices);\n  }\n  apply(fn) {\n    if (this.length === 0) {\n      return new _DataFrame(/* @__PURE__ */ new Map(), [...this._columnOrder]);\n    }\n    const rows = [];\n    for (let i = 0; i < this.length; i++) {\n      rows.push(fn(this.row(i)));\n    }\n    return _DataFrame.fromRows(rows);\n  }\n  where(column, op, value) {\n    const colExpr = col(column);\n    const litValue = value;\n    let expr;\n    switch (op) {\n      case \"=\":\n        expr = colExpr.eq(litValue);\n        break;\n      case \"!=\":\n        expr = colExpr.neq(litValue);\n        break;\n      case \">\":\n        expr = colExpr.gt(litValue);\n        break;\n      case \">=\":\n        expr = colExpr.gte(litValue);\n        break;\n      case \"<\":\n        expr = colExpr.lt(litValue);\n        break;\n      case \"<=\":\n        expr = colExpr.lte(litValue);\n        break;\n    }\n    return this.filter(expr);\n  }\n  sortBy(columns, order) {\n    const cols = Array.isArray(columns) ? columns : [columns];\n    const orders = Array.isArray(order) ? order : cols.map(() => order ?? \"asc\");\n    for (const name of cols) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    if (cols.length === 1) {\n      const sortCol = this._columns.get(cols[0]);\n      const desc = orders[0] === \"desc\";\n      if (sortCol instanceof Utf8Column && sortCol.isInterned) {\n        const interned = sortCol.internedStorage;\n        const dictLen = interned.dictionary.length;\n        const sortedDictIndices = Array.from({ length: dictLen }, (_, i) => i);\n        sortedDictIndices.sort((a, b) => {\n          const sa = interned.dictionary[a];\n          const sb = interned.dictionary[b];\n          const cmp = sa < sb ? -1 : sa > sb ? 1 : 0;\n          return desc ? -cmp : cmp;\n        });\n        const rank = new Uint32Array(dictLen);\n        for (let r = 0; r < dictLen; r++) {\n          rank[sortedDictIndices[r]] = r;\n        }\n        const n = this.length;\n        const internedIndices = interned.indices;\n        const indices3 = Array.from({ length: n }, (_, i) => i);\n        if (sortCol.allValid) {\n          indices3.sort((a, b) => rank[internedIndices[a]] - rank[internedIndices[b]]);\n        } else {\n          const nullMask = sortCol.nullMask;\n          indices3.sort((a, b) => {\n            const aValid = nullMask.getUnsafe(a);\n            const bValid = nullMask.getUnsafe(b);\n            if (!aValid && !bValid) return 0;\n            if (!aValid) return 1;\n            if (!bValid) return -1;\n            return rank[internedIndices[a]] - rank[internedIndices[b]];\n          });\n        }\n        const int32Indices3 = new Int32Array(indices3);\n        const newColumns3 = /* @__PURE__ */ new Map();\n        for (const name of this._columnOrder) {\n          newColumns3.set(name, this._columns.get(name).take(int32Indices3));\n        }\n        return new _DataFrame(newColumns3, [...this._columnOrder]);\n      }\n      const vals = new Array(this.length);\n      for (let i = 0; i < this.length; i++) vals[i] = sortCol.get(i);\n      const indices2 = Array.from({ length: this.length }, (_, i) => i);\n      indices2.sort((a, b) => {\n        const va = vals[a];\n        const vb = vals[b];\n        const aIsNull = va === null || va === void 0;\n        const bIsNull = vb === null || vb === void 0;\n        if (aIsNull && bIsNull) return 0;\n        if (aIsNull) return 1;\n        if (bIsNull) return -1;\n        let cmp = 0;\n        if (typeof va === \"number\" && typeof vb === \"number\") {\n          cmp = va - vb;\n        } else if (typeof va === \"string\" && typeof vb === \"string\") {\n          cmp = va < vb ? -1 : va > vb ? 1 : 0;\n        } else if (typeof va === \"boolean\" && typeof vb === \"boolean\") {\n          cmp = (va ? 1 : 0) - (vb ? 1 : 0);\n        } else if (va instanceof Date && vb instanceof Date) {\n          cmp = va.getTime() - vb.getTime();\n        }\n        return desc ? -cmp : cmp;\n      });\n      const int32Indices2 = new Int32Array(indices2);\n      const newColumns2 = /* @__PURE__ */ new Map();\n      for (const name of this._columnOrder) {\n        newColumns2.set(name, this._columns.get(name).take(int32Indices2));\n      }\n      return new _DataFrame(newColumns2, [...this._columnOrder]);\n    }\n    if (cols.length === 2 && this._columns.get(cols[0]).dtype === \"utf8\" /* Utf8 */ && (this._columns.get(cols[1]).dtype === \"f64\" /* Float64 */ || this._columns.get(cols[1]).dtype === \"i32\" /* Int32 */)) {\n      const c0 = this._columns.get(cols[0]);\n      const c1 = this._columns.get(cols[1]);\n      const v0 = new Array(this.length);\n      const v1 = new Array(this.length);\n      for (let i = 0; i < this.length; i++) {\n        v0[i] = c0.get(i);\n        v1[i] = c1.get(i);\n      }\n      const d0 = orders[0] === \"desc\";\n      const d1 = orders[1] === \"desc\";\n      const indices2 = Array.from({ length: this.length }, (_, i) => i);\n      indices2.sort((a, b) => {\n        const a0 = v0[a];\n        const b0 = v0[b];\n        const a0Null = a0 === null;\n        const b0Null = b0 === null;\n        if (!a0Null || !b0Null) {\n          if (a0Null) return 1;\n          if (b0Null) return -1;\n          const cmp0 = a0 < b0 ? -1 : a0 > b0 ? 1 : 0;\n          if (cmp0 !== 0) return d0 ? -cmp0 : cmp0;\n        }\n        const a1 = v1[a];\n        const b1 = v1[b];\n        const a1Null = a1 === null;\n        const b1Null = b1 === null;\n        if (a1Null && b1Null) return 0;\n        if (a1Null) return 1;\n        if (b1Null) return -1;\n        const cmp1 = a1 - b1;\n        return d1 ? -cmp1 : cmp1;\n      });\n      const int32Indices2 = new Int32Array(indices2);\n      return this._takeByInt32Indices(int32Indices2);\n    }\n    const sortValues = cols.map((name) => {\n      const col2 = this._columns.get(name);\n      const vals = new Array(this.length);\n      for (let i = 0; i < this.length; i++) {\n        vals[i] = col2.get(i);\n      }\n      return vals;\n    });\n    const indices = Array.from({ length: this.length }, (_, i) => i);\n    indices.sort((a, b) => {\n      for (let c = 0; c < cols.length; c++) {\n        const va = sortValues[c][a];\n        const vb = sortValues[c][b];\n        const aIsNull = va === null || va === void 0;\n        const bIsNull = vb === null || vb === void 0;\n        if (aIsNull && bIsNull) continue;\n        if (aIsNull) return 1;\n        if (bIsNull) return -1;\n        let cmp = 0;\n        if (va instanceof Date && vb instanceof Date) {\n          cmp = va.getTime() - vb.getTime();\n        } else if (typeof va === \"string\" && typeof vb === \"string\") {\n          cmp = va < vb ? -1 : va > vb ? 1 : 0;\n        } else if (typeof va === \"number\" && typeof vb === \"number\") {\n          cmp = va - vb;\n        } else if (typeof va === \"boolean\" && typeof vb === \"boolean\") {\n          cmp = (va ? 1 : 0) - (vb ? 1 : 0);\n        }\n        if (cmp !== 0) {\n          return orders[c] === \"desc\" ? -cmp : cmp;\n        }\n      }\n      return 0;\n    });\n    const int32Indices = new Int32Array(indices);\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      newColumns.set(name, this._columns.get(name).take(int32Indices));\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  unique(columns, keep = \"first\") {\n    const cols = columns === void 0 ? this._columnOrder : Array.isArray(columns) ? columns : [columns];\n    for (const name of cols) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    const seen = /* @__PURE__ */ new Set();\n    const indices = [];\n    if (keep === \"first\") {\n      for (let i = 0; i < this.length; i++) {\n        const key = this._rowKey(i, cols);\n        if (!seen.has(key)) {\n          seen.add(key);\n          indices.push(i);\n        }\n      }\n    } else {\n      const lastIndex = /* @__PURE__ */ new Map();\n      const order = [];\n      for (let i = 0; i < this.length; i++) {\n        const key = this._rowKey(i, cols);\n        if (!lastIndex.has(key)) {\n          order.push(key);\n        }\n        lastIndex.set(key, i);\n      }\n      for (const key of order) {\n        indices.push(lastIndex.get(key));\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  sample(n, options) {\n    if (this.length === 0) {\n      return this.clone();\n    }\n    let count;\n    if (n >= 1) {\n      count = Math.min(Math.floor(n), this.length);\n    } else if (n > 0 && n < 1) {\n      count = Math.max(1, Math.round(n * this.length));\n    } else {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `sample size must be positive, got ${n}`\n      );\n    }\n    const rng = options?.seed !== void 0 ? seededRandom(options.seed) : Math.random;\n    const indices = Array.from({ length: this.length }, (_, i) => i);\n    for (let i = indices.length - 1; i > 0; i--) {\n      const j = Math.floor(rng() * (i + 1));\n      const tmp = indices[i];\n      indices[i] = indices[j];\n      indices[j] = tmp;\n    }\n    return this._takeByIndices(indices.slice(0, count));\n  }\n  groupBy(...keys) {\n    return new GroupBy(this, keys);\n  }\n  join(other, on, how = \"inner\", options) {\n    return hashJoin(this, other, on, how, options);\n  }\n  pivot(options) {\n    return pivot(this, options);\n  }\n  melt(options) {\n    return melt(this, options);\n  }\n  explode(column) {\n    if (!this._columns.has(column)) {\n      throw new ColumnNotFoundError(column, this._columnOrder);\n    }\n    const explodeCol = this._columns.get(column);\n    const otherColNames = this._columnOrder.filter((n) => n !== column);\n    const resultArrays = {};\n    for (const name of this._columnOrder) {\n      resultArrays[name] = [];\n    }\n    for (let i = 0; i < this.length; i++) {\n      const val = explodeCol.get(i);\n      if (val === null) {\n        resultArrays[column].push(null);\n        for (const name of otherColNames) {\n          resultArrays[name].push(this._columns.get(name).get(i));\n        }\n      } else if (Array.isArray(val)) {\n        if (val.length === 0) {\n          continue;\n        }\n        for (const item of val) {\n          resultArrays[column].push(item === void 0 ? null : item);\n          for (const name of otherColNames) {\n            resultArrays[name].push(this._columns.get(name).get(i));\n          }\n        }\n      } else {\n        resultArrays[column].push(val);\n        for (const name of otherColNames) {\n          resultArrays[name].push(this._columns.get(name).get(i));\n        }\n      }\n    }\n    return _DataFrame.fromColumns(resultArrays);\n  }\n  transpose(headerColumn) {\n    return transpose(this, headerColumn);\n  }\n  static concat(...frames) {\n    return concat(...frames);\n  }\n  _rowKey(index, cols) {\n    const parts = [];\n    for (const name of cols) {\n      const v = this._columns.get(name).get(index);\n      if (v === null) {\n        parts.push(\"\\0null\");\n      } else if (v instanceof Date) {\n        parts.push(`\\0d${v.getTime()}`);\n      } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n        parts.push(`\\0${typeof v}${String(v)}`);\n      } else {\n        parts.push(`\\0obj${JSON.stringify(v)}`);\n      }\n    }\n    return parts.join(\"\u0001\");\n  }\n  _takeByIndices(indices) {\n    const int32Indices = new Int32Array(indices);\n    return this._takeByInt32Indices(int32Indices);\n  }\n  _takeByInt32Indices(int32Indices) {\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      newColumns.set(name, this._columns.get(name).take(int32Indices));\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  dropNull(columns) {\n    const cols = columns === void 0 ? this._columnOrder : Array.isArray(columns) ? columns : [columns];\n    for (const name of cols) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    const indices = [];\n    for (let i = 0; i < this.length; i++) {\n      let hasNull = false;\n      for (const name of cols) {\n        if (this._columns.get(name).get(i) === null) {\n          hasNull = true;\n          break;\n        }\n      }\n      if (!hasNull) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  fillNull(strategy) {\n    if (typeof strategy === \"string\") {\n      return this._fillNullDirectional(strategy);\n    }\n    for (const colName of Object.keys(strategy)) {\n      if (!this._columns.has(colName)) {\n        throw new ColumnNotFoundError(colName, this._columnOrder);\n      }\n    }\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      const col2 = this._columns.get(name);\n      const fillValue = strategy[name];\n      if (fillValue !== void 0) {\n        const values = [];\n        for (let i = 0; i < col2.length; i++) {\n          const v = col2.get(i);\n          values.push(v === null ? fillValue : v);\n        }\n        newColumns.set(name, buildColumn(col2.dtype, values));\n      } else {\n        newColumns.set(name, col2);\n      }\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  _fillNullDirectional(direction) {\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      const col2 = this._columns.get(name);\n      if (col2.nullCount === 0) {\n        newColumns.set(name, col2);\n        continue;\n      }\n      const values = [];\n      for (let i = 0; i < col2.length; i++) {\n        values.push(col2.get(i));\n      }\n      if (direction === \"forward\") {\n        for (let i = 1; i < values.length; i++) {\n          if (values[i] === null && values[i - 1] !== null) {\n            values[i] = values[i - 1];\n          }\n        }\n      } else {\n        for (let i = values.length - 2; i >= 0; i--) {\n          if (values[i] === null && values[i + 1] !== null) {\n            values[i] = values[i + 1];\n          }\n        }\n      }\n      newColumns.set(name, buildColumn(col2.dtype, values));\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  cast(dtypes) {\n    for (const colName of Object.keys(dtypes)) {\n      if (!this._columns.has(colName)) {\n        throw new ColumnNotFoundError(colName, this._columnOrder);\n      }\n    }\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      const targetDType = dtypes[name];\n      if (targetDType) {\n        const series = new Series(name, this._columns.get(name));\n        const casted = series.cast(targetDType);\n        newColumns.set(name, casted.column);\n      } else {\n        newColumns.set(name, this._columns.get(name));\n      }\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  toString(options) {\n    const maxRows = options?.maxRows ?? 10;\n    const maxCols = options?.maxCols ?? 10;\n    const [nRows, nCols] = this.shape;\n    if (nCols === 0 || nRows === 0) {\n      return `Empty DataFrame\n0 rows x ${nCols} columns`;\n    }\n    const allCols = this._columnOrder;\n    let displayCols;\n    if (allCols.length > maxCols) {\n      const half = Math.floor(maxCols / 2);\n      displayCols = [...allCols.slice(0, half), \"...\", ...allCols.slice(allCols.length - half)];\n    } else {\n      displayCols = [...allCols];\n    }\n    let rowIndices;\n    if (nRows > maxRows) {\n      const half = Math.floor(maxRows / 2);\n      rowIndices = [\n        ...Array.from({ length: half }, (_, i) => i),\n        -1,\n        // separator\n        ...Array.from({ length: half }, (_, i) => nRows - half + i)\n      ];\n    } else {\n      rowIndices = Array.from({ length: nRows }, (_, i) => i);\n    }\n    const formatValue = (v) => {\n      if (v === null) return \"null\";\n      if (v instanceof Date) return v.toISOString();\n      if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n        return String(v);\n      }\n      return JSON.stringify(v);\n    };\n    const headerRow = [\"\", ...displayCols];\n    const dataRows = [];\n    for (const idx of rowIndices) {\n      if (idx === -1) {\n        dataRows.push(headerRow.map(() => \"...\"));\n        continue;\n      }\n      const cells = [String(idx)];\n      for (const colName of displayCols) {\n        if (colName === \"...\") {\n          cells.push(\"...\");\n        } else {\n          cells.push(formatValue(this._columns.get(colName).get(idx)));\n        }\n      }\n      dataRows.push(cells);\n    }\n    const colWidths = headerRow.map((h, ci) => {\n      let maxW = h.length;\n      for (const row of dataRows) {\n        maxW = Math.max(maxW, row[ci].length);\n      }\n      return maxW;\n    });\n    const pad = (s, w, ci) => {\n      if (ci === 0) return s.padStart(w);\n      return s.padEnd(w);\n    };\n    const sep = \"\\u2500\";\n    const lines = [];\n    const headerLine = \"\\u2502 \" + headerRow.map((h, ci) => pad(h, colWidths[ci], ci)).join(\" \\u2502 \") + \" \\u2502\";\n    const topBorder = \"\\u250C\\u2500\" + colWidths.map((w) => sep.repeat(w)).join(\"\\u2500\\u252C\\u2500\") + \"\\u2500\\u2510\";\n    const headerSep = \"\\u251C\\u2500\" + colWidths.map((w) => sep.repeat(w)).join(\"\\u2500\\u253C\\u2500\") + \"\\u2500\\u2524\";\n    const bottomBorder = \"\\u2514\\u2500\" + colWidths.map((w) => sep.repeat(w)).join(\"\\u2500\\u2534\\u2500\") + \"\\u2500\\u2518\";\n    lines.push(topBorder);\n    lines.push(headerLine);\n    lines.push(headerSep);\n    for (const row of dataRows) {\n      lines.push(\"\\u2502 \" + row.map((cell, ci) => pad(cell, colWidths[ci], ci)).join(\" \\u2502 \") + \" \\u2502\");\n    }\n    lines.push(bottomBorder);\n    lines.push(`${nRows} rows x ${nCols} columns`);\n    return lines.join(\"\\n\");\n  }\n  print(options) {\n    console.log(this.toString(options));\n  }\n  describe() {\n    const statNames = [\"count\", \"mean\", \"std\", \"min\", \"max\"];\n    const resultColumns = { stat: statNames };\n    for (const name of this._columnOrder) {\n      const colObj = this._columns.get(name);\n      const dtype = colObj.dtype;\n      if (dtype === \"f64\" /* Float64 */ || dtype === \"i32\" /* Int32 */) {\n        const series = new Series(name, colObj);\n        const count = series.length - series.nullCount;\n        const mean = series.mean();\n        const std = series.std();\n        const min = series.min();\n        const max = series.max();\n        resultColumns[name] = [count, mean, std, min, max];\n      }\n    }\n    return _DataFrame.fromColumns(resultColumns);\n  }\n  memoryUsage() {\n    let total = 0;\n    for (const name of this._columnOrder) {\n      total += this._columns.get(name).estimatedMemoryBytes();\n    }\n    return total;\n  }\n  info() {\n    const [nRows, nCols] = this.shape;\n    const lines = [];\n    lines.push(`DataFrame: ${nRows} rows x ${nCols} columns`);\n    lines.push(\"\");\n    const colNameWidth = Math.max(6, ...this._columnOrder.map((n) => n.length));\n    const header = `${\"Column\".padEnd(colNameWidth)}  ${\"DType\".padEnd(10)}  ${\"Null Count\".padEnd(10)}  Memory`;\n    lines.push(header);\n    lines.push(\"\\u2500\".repeat(header.length));\n    let totalMemory = 0;\n    for (const name of this._columnOrder) {\n      const colObj = this._columns.get(name);\n      const dtype = colObj.dtype;\n      const nullCount = colObj.nullCount;\n      const mem = colObj.estimatedMemoryBytes();\n      totalMemory += mem;\n      lines.push(\n        `${name.padEnd(colNameWidth)}  ${dtype.padEnd(10)}  ${String(nullCount).padEnd(10)}  ${formatBytes(mem)}`\n      );\n    }\n    lines.push(\"\\u2500\".repeat(header.length));\n    lines.push(`Total memory: ${formatBytes(totalMemory)}`);\n    console.log(lines.join(\"\\n\"));\n  }\n  static fromColumns(data) {\n    const keys = Object.keys(data);\n    if (keys.length === 0) {\n      return _DataFrame.empty();\n    }\n    const firstKey = keys[0];\n    const rowCount = data[firstKey].length;\n    for (const key of keys) {\n      if (data[key].length !== rowCount) {\n        throw new ShapeMismatchError(\n          `Column '${key}' has length ${data[key].length}, expected ${rowCount}`\n        );\n      }\n    }\n    const columns = /* @__PURE__ */ new Map();\n    for (const key of keys) {\n      const values = data[key];\n      const dtype = detectDType3(values);\n      const col2 = buildColumn(dtype, values);\n      columns.set(key, col2);\n    }\n    return new _DataFrame(columns, keys);\n  }\n  static fromRows(rows) {\n    if (rows.length === 0) {\n      return _DataFrame.empty();\n    }\n    const columnSet = /* @__PURE__ */ new Set();\n    for (const row of rows) {\n      for (const key of Object.keys(row)) {\n        columnSet.add(key);\n      }\n    }\n    const columnNames = [...columnSet];\n    const data = {};\n    for (const name of columnNames) {\n      data[name] = [];\n    }\n    for (const row of rows) {\n      const r = row;\n      for (const name of columnNames) {\n        const value = name in r ? r[name] : null;\n        data[name].push(value === void 0 ? null : value);\n      }\n    }\n    return _DataFrame.fromColumns(data);\n  }\n  static empty() {\n    return new _DataFrame(/* @__PURE__ */ new Map(), []);\n  }\n  static range(name, start, end, step = 1) {\n    if (step === 0) {\n      throw new FrameKitError(\"INVALID_OPERATION\" /* INVALID_OPERATION */, \"step must not be zero\");\n    }\n    if (start >= end) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `start (${start}) must be less than end (${end})`\n      );\n    }\n    const length = Math.ceil((end - start) / step);\n    const data = new Float64Array(length);\n    for (let i = 0; i < length; i++) {\n      data[i] = start + i * step;\n    }\n    const mask = new BitArray(length, true);\n    const col2 = new Float64Column(data, mask);\n    const columns = /* @__PURE__ */ new Map();\n    columns.set(name, col2);\n    return new _DataFrame(columns, [name]);\n  }\n  static linspace(name, start, end, count) {\n    if (count < 2) {\n      throw new FrameKitError(\"INVALID_OPERATION\" /* INVALID_OPERATION */, \"count must be at least 2\");\n    }\n    const data = new Float64Array(count);\n    const step = (end - start) / (count - 1);\n    for (let i = 0; i < count; i++) {\n      data[i] = start + i * step;\n    }\n    const mask = new BitArray(count, true);\n    const col2 = new Float64Column(data, mask);\n    const columns = /* @__PURE__ */ new Map();\n    columns.set(name, col2);\n    return new _DataFrame(columns, [name]);\n  }\n  static async fromCSV(input, options = {}) {\n    let content;\n    if (typeof input !== \"string\") {\n      try {\n        const chunks = [];\n        for await (const chunk of input) {\n          chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n        }\n        content = Buffer.concat(chunks).toString(options.encoding ?? \"utf-8\");\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to read CSV from stream: ${message}`);\n      }\n    } else if (options.parse === \"string\") {\n      content = input;\n    } else if (input.startsWith(\"http://\") || input.startsWith(\"https://\")) {\n      try {\n        const response = await fetch(input);\n        if (!response.ok) {\n          throw new IOError(\n            `Failed to fetch CSV from '${input}': HTTP ${String(response.status)} ${response.statusText}`\n          );\n        }\n        content = await response.text();\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to fetch CSV from '${input}': ${message}`);\n      }\n    } else {\n      try {\n        const fs = await import(\"fs/promises\");\n        content = await fs.readFile(input, options.encoding ?? \"utf-8\");\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to read CSV file '${input}': ${message}`);\n      }\n    }\n    const parsed = parseCSV(content, options);\n    return buildDataFrameFromParsed(parsed.header, parsed.columns, parsed.inferredTypes);\n  }\n  static async *streamCSV(path, options = {}) {\n    for await (const chunk of streamCSVFile(path, options)) {\n      yield buildDataFrameFromParsed(chunk.header, chunk.rawColumns, chunk.inferredTypes);\n    }\n  }\n  static scanCSV(path, options = {}) {\n    const placeholder = _DataFrame.empty();\n    const lazy = createLazyFrame(placeholder);\n    const originalCollect = lazy.collect.bind(lazy);\n    void originalCollect;\n    lazy.collect = async () => {\n      const chunks = [];\n      for await (const chunk of _DataFrame.streamCSV(path, options)) {\n        chunks.push(chunk);\n      }\n      if (chunks.length === 0) return _DataFrame.empty();\n      if (chunks.length === 1) return chunks[0];\n      return concat(...chunks);\n    };\n    return lazy;\n  }\n  static async *streamNDJSON(path, options = {}) {\n    for await (const chunk of streamNDJSONFile(path, options)) {\n      yield _DataFrame.fromRows(chunk);\n    }\n  }\n  static scanNDJSON(path, options = {}) {\n    const placeholder = _DataFrame.empty();\n    const lazy = createLazyFrame(placeholder);\n    const originalCollect = lazy.collect.bind(lazy);\n    void originalCollect;\n    lazy.collect = async () => {\n      const chunks = [];\n      for await (const chunk of _DataFrame.streamNDJSON(path, options)) {\n        chunks.push(chunk);\n      }\n      if (chunks.length === 0) return _DataFrame.empty();\n      if (chunks.length === 1) return chunks[0];\n      return concat(...chunks);\n    };\n    return lazy;\n  }\n  toCSV(filePathOrOptions, maybeOptions) {\n    let filePath;\n    let writable;\n    let options;\n    if (typeof filePathOrOptions === \"string\") {\n      filePath = filePathOrOptions;\n      options = maybeOptions ?? {};\n    } else if (filePathOrOptions != null && typeof filePathOrOptions === \"object\" && \"write\" in filePathOrOptions && typeof filePathOrOptions.write === \"function\") {\n      writable = filePathOrOptions;\n      options = maybeOptions ?? {};\n    } else {\n      options = filePathOrOptions ?? {};\n    }\n    const { header, rows } = this._extractRows();\n    const csvString = writeCSV(header, rows, options);\n    if (writable) {\n      const stream = writable;\n      return new Promise((resolve, reject) => {\n        let settled = false;\n        const fail = (err) => {\n          if (settled) return;\n          settled = true;\n          reject(new IOError(`Failed to write CSV to stream: ${err.message}`));\n        };\n        stream.once(\"error\", fail);\n        stream.write(csvString, \"utf-8\", (err) => {\n          if (err) {\n            fail(err);\n          } else {\n            if (settled) return;\n            settled = true;\n            stream.removeListener(\"error\", fail);\n            resolve();\n          }\n        });\n      });\n    }\n    if (filePath) {\n      return import(\"fs/promises\").then(\n        (fs) => fs.writeFile(filePath, csvString, \"utf-8\").catch((err) => {\n          const message = err instanceof Error ? err.message : String(err);\n          throw new IOError(`Failed to write CSV file '${filePath}': ${message}`);\n        })\n      );\n    }\n    return csvString;\n  }\n  static async fromJSON(input, options = {}) {\n    let content;\n    if (options.parse === \"string\") {\n      content = input;\n    } else {\n      try {\n        const fs = await import(\"fs/promises\");\n        content = await fs.readFile(input, \"utf-8\");\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to read JSON file '${input}': ${message}`);\n      }\n    }\n    let parsed = JSON.parse(content);\n    if (options.path) {\n      const parts = options.path.split(\".\");\n      for (const part of parts) {\n        if (parsed !== null && typeof parsed === \"object\" && !Array.isArray(parsed)) {\n          parsed = parsed[part];\n        } else {\n          throw new IOError(`JSON path '${options.path}' not found: '${part}' is not an object`);\n        }\n      }\n    }\n    if (!Array.isArray(parsed)) {\n      throw new IOError(\"JSON content must be an array of objects\");\n    }\n    return _DataFrame.fromRows(parsed);\n  }\n  toJSON(filePathOrOptions, maybeOptions) {\n    let filePath;\n    let options;\n    if (typeof filePathOrOptions === \"string\") {\n      filePath = filePathOrOptions;\n      options = maybeOptions ?? {};\n    } else {\n      options = filePathOrOptions ?? {};\n    }\n    const { header, rows } = this._extractRows();\n    const jsonString = writeJSON(header, rows, options);\n    if (filePath) {\n      return import(\"fs/promises\").then(\n        (fs) => fs.writeFile(filePath, jsonString, \"utf-8\").catch((err) => {\n          const message = err instanceof Error ? err.message : String(err);\n          throw new IOError(`Failed to write JSON file '${filePath}': ${message}`);\n        })\n      );\n    }\n    return jsonString;\n  }\n  static async fromNDJSON(input, options = {}) {\n    let content;\n    if (options.parse === \"string\") {\n      content = input;\n    } else {\n      try {\n        const fs = await import(\"fs/promises\");\n        content = await fs.readFile(input, \"utf-8\");\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to read NDJSON file '${input}': ${message}`);\n      }\n    }\n    const lines = content.split(\"\\n\").filter((line) => line.trim() !== \"\");\n    const rows = lines.map((line) => JSON.parse(line));\n    return _DataFrame.fromRows(rows);\n  }\n  static async fromExcel(filePath, options = {}) {\n    const parsed = await readExcelFile(filePath, options);\n    if (parsed.header.length === 0) {\n      return _DataFrame.empty();\n    }\n    const columns = /* @__PURE__ */ new Map();\n    for (const name of parsed.header) {\n      const dtype = parsed.inferredTypes[name] ?? \"f64\" /* Float64 */;\n      const values = parsed.columns[name];\n      columns.set(name, buildColumn(dtype, values));\n    }\n    return new _DataFrame(columns, [...parsed.header]);\n  }\n  static async fromParquet(filePath, options = {}) {\n    const parsed = await readParquetFile(filePath, options);\n    if (parsed.header.length === 0) {\n      return _DataFrame.empty();\n    }\n    const columns = /* @__PURE__ */ new Map();\n    for (const name of parsed.header) {\n      const dtype = parsed.inferredTypes[name] ?? \"f64\" /* Float64 */;\n      const values = parsed.columns[name];\n      columns.set(name, buildColumn(dtype, values));\n    }\n    return new _DataFrame(columns, [...parsed.header]);\n  }\n  async toExcel(filePath, options = {}) {\n    const { header, rows } = this._extractRows();\n    await writeExcelFile(filePath, header, rows, options);\n  }\n  async toParquet(filePath, options = {}) {\n    const header = this._columnOrder;\n    const columns = {};\n    for (const name of header) {\n      const col2 = this._columns.get(name);\n      const values = [];\n      for (let i = 0; i < col2.length; i++) {\n        values.push(col2.get(i));\n      }\n      columns[name] = { values, dtype: col2.dtype };\n    }\n    await writeParquetFile(filePath, header, columns, options);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async toArrow() {\n    return toArrowTable({\n      columnOrder: this._columnOrder,\n      getColumnValues: (name) => {\n        const col2 = this._columns.get(name);\n        const values = [];\n        for (let i = 0; i < col2.length; i++) {\n          values.push(col2.get(i));\n        }\n        return { values, dtype: col2.dtype };\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromArrow(table) {\n    const parsed = fromArrowTable(table);\n    if (parsed.header.length === 0) {\n      return _DataFrame.empty();\n    }\n    const columns = /* @__PURE__ */ new Map();\n    for (const name of parsed.header) {\n      const dtype = parsed.inferredTypes[name] ?? \"f64\" /* Float64 */;\n      const values = parsed.columns[name];\n      columns.set(name, buildColumn(dtype, values));\n    }\n    return new _DataFrame(columns, [...parsed.header]);\n  }\n  async toArrowIPC() {\n    let arrow;\n    try {\n      const moduleName = \"apache-arrow\";\n      arrow = await import(moduleName);\n    } catch {\n      throw new IOError(\n        \"apache-arrow is required for Arrow IPC serialization but is not installed. Run: npm install apache-arrow\"\n      );\n    }\n    const table = await this.toArrow();\n    return arrow.tableToIPC(table, \"stream\");\n  }\n  static async fromArrowIPC(buffer) {\n    let arrow;\n    try {\n      const moduleName = \"apache-arrow\";\n      arrow = await import(moduleName);\n    } catch {\n      throw new IOError(\n        \"apache-arrow is required for Arrow IPC deserialization but is not installed. Run: npm install apache-arrow\"\n      );\n    }\n    const table = arrow.tableFromIPC(buffer);\n    return _DataFrame.fromArrow(table);\n  }\n  toNDJSON(filePath) {\n    const { header, rows } = this._extractRows();\n    const ndjsonString = writeNDJSON(header, rows);\n    if (filePath) {\n      return import(\"fs/promises\").then(\n        (fs) => fs.writeFile(filePath, ndjsonString, \"utf-8\").catch((err) => {\n          const message = err instanceof Error ? err.message : String(err);\n          throw new IOError(`Failed to write NDJSON file '${filePath}': ${message}`);\n        })\n      );\n    }\n    return ndjsonString;\n  }\n  toSQL(tableName, options) {\n    const { header, rows } = this._extractRows();\n    return writeSQL(tableName, header, rows, options);\n  }\n  _extractRows() {\n    const header = this._columnOrder;\n    const rows = [];\n    for (let i = 0; i < this.length; i++) {\n      const row = [];\n      for (const name of this._columnOrder) {\n        row.push(this._columns.get(name).get(i));\n      }\n      rows.push(row);\n    }\n    return { header, rows };\n  }\n  union(other) {\n    return union(this, other);\n  }\n  intersection(other) {\n    return intersection(this, other);\n  }\n  difference(other) {\n    return difference(this, other);\n  }\n  query(queryStr) {\n    return executeQuery(this, queryStr);\n  }\n  static registerReader(extension, readerFn) {\n    const ext = extension.startsWith(\".\") ? extension.slice(1) : extension;\n    _DataFrame._readers.set(ext.toLowerCase(), readerFn);\n  }\n  static registerWriter(extension, writerFn) {\n    const ext = extension.startsWith(\".\") ? extension.slice(1) : extension;\n    _DataFrame._writers.set(ext.toLowerCase(), writerFn);\n  }\n  static async fromFile(filePath, options) {\n    const ext = filePath.split(\".\").pop()?.toLowerCase();\n    if (!ext) {\n      throw new IOError(`Cannot determine file extension from path: '${filePath}'`);\n    }\n    const reader = _DataFrame._readers.get(ext);\n    if (!reader) {\n      throw new IOError(\n        `No reader registered for extension '.${ext}'. Use DataFrame.registerReader('${ext}', readerFn) to register one.`\n      );\n    }\n    const fs = await import(\"fs/promises\");\n    let source;\n    try {\n      source = await fs.readFile(filePath);\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err);\n      throw new IOError(`Failed to read file '${filePath}': ${message}`);\n    }\n    return reader(source, options);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async toFile(filePath, options) {\n    const ext = filePath.split(\".\").pop()?.toLowerCase();\n    if (!ext) {\n      throw new IOError(`Cannot determine file extension from path: '${filePath}'`);\n    }\n    const writer = _DataFrame._writers.get(ext);\n    if (!writer) {\n      throw new IOError(\n        `No writer registered for extension '.${ext}'. Use DataFrame.registerWriter('${ext}', writerFn) to register one.`\n      );\n    }\n    await writer(this, filePath, options);\n  }\n};\nfunction seededRandom(seed) {\n  let s = seed | 0;\n  return () => {\n    s = s + 1831565813 | 0;\n    let t = Math.imul(s ^ s >>> 15, 1 | s);\n    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nfunction buildDataFrameFromParsed(header, rawColumns, inferredTypes) {\n  if (header.length === 0) {\n    return DataFrame.empty();\n  }\n  const columns = /* @__PURE__ */ new Map();\n  for (const name of header) {\n    const dtype = inferredTypes[name] ?? \"utf8\" /* Utf8 */;\n    const rawValues = rawColumns[name];\n    const typedValues = convertColumnValues(rawValues, dtype);\n    columns.set(name, buildColumn(dtype, typedValues));\n  }\n  return new DataFrame(columns, [...header]);\n}\nfunction convertColumnValues(values, dtype) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n    case \"i32\" /* Int32 */:\n      return values.map((v) => v === null ? null : Number(v));\n    case \"bool\" /* Boolean */:\n      return values.map((v) => {\n        if (v === null) return null;\n        return v.toLowerCase() === \"true\";\n      });\n    case \"date\" /* Date */:\n      return values.map((v) => v === null ? null : new Date(v));\n    case \"utf8\" /* Utf8 */:\n    default:\n      return values;\n  }\n}\nfunction detectDType3(values) {\n  for (const v of values) {\n    if (v === null || v === void 0) continue;\n    if (typeof v === \"number\") return \"f64\" /* Float64 */;\n    if (typeof v === \"string\") return \"utf8\" /* Utf8 */;\n    if (typeof v === \"boolean\") return \"bool\" /* Boolean */;\n    if (v instanceof Date) return \"date\" /* Date */;\n    if (Array.isArray(v) || typeof v === \"object\") return \"object\" /* Object */;\n  }\n  return \"f64\" /* Float64 */;\n}\nfunction buildColumn(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    case \"object\" /* Object */:\n      return ObjectColumn.from(values);\n    default:\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Unsupported dtype for column construction: ${dtype}`\n      );\n  }\n}\nfunction formatBytes(bytes) {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n}\n_registerDataFrameFactory((columns, columnOrder) => new DataFrame(columns, columnOrder));\n\n// src/expr/conditional-expr.ts\nfunction detectValueDType(value) {\n  if (typeof value === \"number\") return \"f64\" /* Float64 */;\n  if (typeof value === \"string\") return \"utf8\" /* Utf8 */;\n  if (typeof value === \"boolean\") return \"bool\" /* Boolean */;\n  if (value instanceof Date) return \"date\" /* Date */;\n  return \"f64\" /* Float64 */;\n}\nfunction buildColumnForValues2(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nvar WhenExpr = class extends Expr {\n  _clauses;\n  _otherwise;\n  constructor(clauses, otherwise) {\n    super();\n    this._clauses = clauses;\n    this._otherwise = otherwise;\n  }\n  get dependencies() {\n    const deps = /* @__PURE__ */ new Set();\n    for (const clause of this._clauses) {\n      for (const d of clause.condition.dependencies) deps.add(d);\n      for (const d of clause.value.dependencies) deps.add(d);\n    }\n    if (this._otherwise) {\n      for (const d of this._otherwise.dependencies) deps.add(d);\n    }\n    return [...deps];\n  }\n  toString() {\n    const parts = this._clauses.map((c) => `WHEN ${c.condition.toString()} THEN ${c.value.toString()}`);\n    if (this._otherwise) {\n      parts.push(`ELSE ${this._otherwise.toString()}`);\n    }\n    return `CASE ${parts.join(\" \")} END`;\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const conditionResults = this._clauses.map((c) => c.condition.evaluate(df2));\n    const valueResults = this._clauses.map((c) => c.value.evaluate(df2));\n    const otherwiseResult = this._otherwise ? this._otherwise.evaluate(df2) : null;\n    const results = [];\n    let detectedDType = null;\n    for (let i = 0; i < len; i++) {\n      let matched = false;\n      for (let j = 0; j < this._clauses.length; j++) {\n        const cond = conditionResults[j].get(i);\n        if (cond === true) {\n          const val = valueResults[j].get(i);\n          results.push(val);\n          if (detectedDType === null && val !== null) {\n            detectedDType = detectValueDType(val);\n          }\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        if (otherwiseResult) {\n          const val = otherwiseResult.get(i);\n          results.push(val);\n          if (detectedDType === null && val !== null) {\n            detectedDType = detectValueDType(val);\n          }\n        } else {\n          results.push(null);\n        }\n      }\n    }\n    const dtype = detectedDType ?? \"f64\" /* Float64 */;\n    const col2 = buildColumnForValues2(dtype, results);\n    return new Series(\"\", col2);\n  }\n};\nvar WhenBuilder = class {\n  _condition;\n  constructor(condition) {\n    this._condition = condition;\n  }\n  then(value) {\n    const expr = value instanceof Expr ? value : new LiteralExpr(value);\n    return new ThenBuilder([{ condition: this._condition, value: expr }]);\n  }\n};\nvar ThenBuilder = class {\n  _clauses;\n  constructor(clauses) {\n    this._clauses = clauses;\n  }\n  when(condition) {\n    return new ChainedWhenBuilder(this._clauses, condition);\n  }\n  otherwise(value) {\n    const expr = value instanceof Expr ? value : new LiteralExpr(value);\n    return new WhenExpr(this._clauses, expr);\n  }\n};\nvar ChainedWhenBuilder = class {\n  _clauses;\n  _condition;\n  constructor(clauses, condition) {\n    this._clauses = clauses;\n    this._condition = condition;\n  }\n  then(value) {\n    const expr = value instanceof Expr ? value : new LiteralExpr(value);\n    return new ThenBuilder([...this._clauses, { condition: this._condition, value: expr }]);\n  }\n};\nfunction when(condition) {\n  return new WhenBuilder(condition);\n}\n\n// src/expr/string-expr.ts\nvar StringUnaryExpr = class extends Expr {\n  _inner;\n  _op;\n  constructor(inner, op) {\n    super();\n    this._inner = inner;\n    this._op = op;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.${this._op}()`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        switch (this._op) {\n          case \"toLowerCase\":\n            results.push(val.toLowerCase());\n            break;\n          case \"toUpperCase\":\n            results.push(val.toUpperCase());\n            break;\n          case \"trim\":\n            results.push(val.trim());\n            break;\n        }\n      }\n    }\n    return new Series(\"\", Utf8Column.from(results));\n  }\n};\nvar StringContainsExpr = class extends Expr {\n  _inner;\n  _pattern;\n  constructor(inner, pattern) {\n    super();\n    this._inner = inner;\n    this._pattern = pattern;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.contains(\"${this._pattern}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.includes(this._pattern));\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar StringStartsWithExpr = class extends Expr {\n  _inner;\n  _prefix;\n  constructor(inner, prefix) {\n    super();\n    this._inner = inner;\n    this._prefix = prefix;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.startsWith(\"${this._prefix}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.startsWith(this._prefix));\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar StringEndsWithExpr = class extends Expr {\n  _inner;\n  _suffix;\n  constructor(inner, suffix) {\n    super();\n    this._inner = inner;\n    this._suffix = suffix;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.endsWith(\"${this._suffix}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.endsWith(this._suffix));\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar StringReplaceExpr = class extends Expr {\n  _inner;\n  _pattern;\n  _replacement;\n  constructor(inner, pattern, replacement) {\n    super();\n    this._inner = inner;\n    this._pattern = pattern;\n    this._replacement = replacement;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.replace(\"${this._pattern}\", \"${this._replacement}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.replaceAll(this._pattern, this._replacement));\n    }\n    return new Series(\"\", Utf8Column.from(results));\n  }\n};\nvar StringSliceExpr = class extends Expr {\n  _inner;\n  _start;\n  _end;\n  constructor(inner, start, end) {\n    super();\n    this._inner = inner;\n    this._start = start;\n    this._end = end;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.slice(${this._start}${this._end !== void 0 ? `, ${this._end}` : \"\"})`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.slice(this._start, this._end));\n    }\n    return new Series(\"\", Utf8Column.from(results));\n  }\n};\nvar StringLengthExpr = class extends Expr {\n  _inner;\n  constructor(inner) {\n    super();\n    this._inner = inner;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.length()`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.length);\n    }\n    return new Series(\"\", Float64Column.from(results));\n  }\n};\nvar StringConcatExpr = class extends Expr {\n  _parts;\n  constructor(parts) {\n    super();\n    this._parts = parts;\n  }\n  get dependencies() {\n    const deps = /* @__PURE__ */ new Set();\n    for (const part of this._parts) {\n      if (part instanceof Expr) {\n        for (const d of part.dependencies) deps.add(d);\n      }\n    }\n    return [...deps];\n  }\n  toString() {\n    const parts = this._parts.map((p) => p instanceof Expr ? p.toString() : `\"${p}\"`);\n    return `concat(${parts.join(\", \")})`;\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const evaluatedParts = this._parts.map((part) => {\n      if (part instanceof Expr) return part.evaluate(df2);\n      return part;\n    });\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      let hasNull = false;\n      let result = \"\";\n      for (const part of evaluatedParts) {\n        if (typeof part === \"string\") {\n          result += part;\n        } else {\n          const val = part.get(i);\n          if (val === null) {\n            hasNull = true;\n            break;\n          }\n          result += val;\n        }\n      }\n      results.push(hasNull ? null : result);\n    }\n    return new Series(\"\", Utf8Column.from(results));\n  }\n};\nvar StringExprAccessor = class {\n  _expr;\n  constructor(expr) {\n    this._expr = expr;\n  }\n  toLowerCase() {\n    return new StringUnaryExpr(this._expr, \"toLowerCase\");\n  }\n  toUpperCase() {\n    return new StringUnaryExpr(this._expr, \"toUpperCase\");\n  }\n  trim() {\n    return new StringUnaryExpr(this._expr, \"trim\");\n  }\n  contains(pattern) {\n    return new StringContainsExpr(this._expr, pattern);\n  }\n  startsWith(prefix) {\n    return new StringStartsWithExpr(this._expr, prefix);\n  }\n  endsWith(suffix) {\n    return new StringEndsWithExpr(this._expr, suffix);\n  }\n  replace(pattern, replacement) {\n    return new StringReplaceExpr(this._expr, pattern, replacement);\n  }\n  slice(start, end) {\n    return new StringSliceExpr(this._expr, start, end);\n  }\n  length() {\n    return new StringLengthExpr(this._expr);\n  }\n  concat(...parts) {\n    return new StringConcatExpr([this._expr, ...parts]);\n  }\n};\n\n// src/expr/date-expr.ts\nfunction extractDateComponent(date, op) {\n  switch (op) {\n    case \"year\":\n      return date.getFullYear();\n    case \"month\":\n      return date.getMonth() + 1;\n    case \"day\":\n      return date.getDate();\n    case \"hour\":\n      return date.getHours();\n    case \"minute\":\n      return date.getMinutes();\n    case \"second\":\n      return date.getSeconds();\n    case \"dayOfWeek\":\n      return date.getDay();\n    case \"dayOfYear\": {\n      const start = new Date(date.getFullYear(), 0, 0);\n      const diff = date.getTime() - start.getTime();\n      const oneDay = 1e3 * 60 * 60 * 24;\n      return Math.floor(diff / oneDay);\n    }\n    case \"weekNumber\": {\n      const target = new Date(date.getTime());\n      target.setHours(0, 0, 0, 0);\n      target.setDate(target.getDate() + 3 - (target.getDay() + 6) % 7);\n      const jan4 = new Date(target.getFullYear(), 0, 4);\n      const dayDiff = (target.getTime() - jan4.getTime()) / (1e3 * 60 * 60 * 24);\n      return 1 + Math.round((dayDiff - 3 + (jan4.getDay() + 6) % 7) / 7);\n    }\n    case \"quarter\":\n      return Math.floor(date.getMonth() / 3) + 1;\n    case \"timestamp\":\n      return date.getTime();\n  }\n}\nvar DateComponentExpr = class extends Expr {\n  _inner;\n  _op;\n  constructor(inner, op) {\n    super();\n    this._inner = inner;\n    this._op = op;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.dt.${this._op}()`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : extractDateComponent(val, this._op));\n    }\n    return new Series(\"\", Float64Column.from(results));\n  }\n};\nvar DateTruncateExpr = class extends Expr {\n  _inner;\n  _unit;\n  constructor(inner, unit) {\n    super();\n    this._inner = inner;\n    this._unit = unit;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.dt.truncate(\"${this._unit}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(truncateDate2(val, this._unit));\n      }\n    }\n    return new Series(\"\", DateColumn.from(results));\n  }\n};\nvar DateDiffExpr = class extends Expr {\n  _left;\n  _right;\n  _unit;\n  constructor(left, right, unit) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._unit = unit;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._left.dependencies, ...this._right.dependencies])];\n  }\n  toString() {\n    return `dateDiff(${this._left.toString()}, ${this._right.toString()}, \"${this._unit}\")`;\n  }\n  evaluate(df2) {\n    const leftSeries = this._left.evaluate(df2);\n    const rightSeries = this._right.evaluate(df2);\n    const len = leftSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const a = leftSeries.get(i);\n      const b = rightSeries.get(i);\n      if (a === null || b === null) {\n        results.push(null);\n      } else {\n        const diffMs = a.getTime() - b.getTime();\n        results.push(convertMsToDiffUnit(diffMs, this._unit));\n      }\n    }\n    return new Series(\"\", Float64Column.from(results));\n  }\n};\nfunction convertMsToDiffUnit(ms, unit) {\n  switch (unit) {\n    case \"milliseconds\":\n      return ms;\n    case \"seconds\":\n      return ms / 1e3;\n    case \"minutes\":\n      return ms / (1e3 * 60);\n    case \"hours\":\n      return ms / (1e3 * 60 * 60);\n    case \"days\":\n      return ms / (1e3 * 60 * 60 * 24);\n  }\n}\nfunction truncateDate2(date, unit) {\n  switch (unit) {\n    case \"year\":\n      return new Date(date.getFullYear(), 0, 1);\n    case \"month\":\n      return new Date(date.getFullYear(), date.getMonth(), 1);\n    case \"day\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n    case \"hour\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours());\n    case \"minute\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());\n    case \"second\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());\n  }\n}\nvar DateExprAccessor = class {\n  _expr;\n  constructor(expr) {\n    this._expr = expr;\n  }\n  year() {\n    return new DateComponentExpr(this._expr, \"year\");\n  }\n  month() {\n    return new DateComponentExpr(this._expr, \"month\");\n  }\n  day() {\n    return new DateComponentExpr(this._expr, \"day\");\n  }\n  hour() {\n    return new DateComponentExpr(this._expr, \"hour\");\n  }\n  minute() {\n    return new DateComponentExpr(this._expr, \"minute\");\n  }\n  second() {\n    return new DateComponentExpr(this._expr, \"second\");\n  }\n  dayOfWeek() {\n    return new DateComponentExpr(this._expr, \"dayOfWeek\");\n  }\n  dayOfYear() {\n    return new DateComponentExpr(this._expr, \"dayOfYear\");\n  }\n  weekNumber() {\n    return new DateComponentExpr(this._expr, \"weekNumber\");\n  }\n  quarter() {\n    return new DateComponentExpr(this._expr, \"quarter\");\n  }\n  timestamp() {\n    return new DateComponentExpr(this._expr, \"timestamp\");\n  }\n  truncate(unit) {\n    return new DateTruncateExpr(this._expr, unit);\n  }\n  diff(other, unit = \"days\") {\n    return new DateDiffExpr(this._expr, other, unit);\n  }\n};\n\n// src/ops/window.ts\nvar WindowRankingExpr = class extends Expr {\n  _source;\n  _descending;\n  constructor(source, descending = false) {\n    super();\n    this._source = source;\n    this._descending = descending;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n  _sortCompare(a, b) {\n    return this._descending ? -compareValues(a, b) : compareValues(a, b);\n  }\n};\nvar WindowRankExpr = class _WindowRankExpr extends WindowRankingExpr {\n  toString() {\n    return `rank(${this._source.toString()})`;\n  }\n  withDescending(desc) {\n    return new _WindowRankExpr(this._source, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const indexed = [];\n    for (let i = 0; i < len; i++) {\n      indexed.push({ value: series.get(i), idx: i });\n    }\n    indexed.sort((a, b) => this._sortCompare(a.value, b.value));\n    const ranks = new Array(len);\n    let rank = 1;\n    for (let i = 0; i < indexed.length; i++) {\n      if (i > 0 && compareValues(indexed[i].value, indexed[i - 1].value) !== 0) {\n        rank = i + 1;\n      }\n      ranks[indexed[i].idx] = rank;\n    }\n    return new Series(\"rank\", Float64Column.from(ranks));\n  }\n};\nvar WindowDenseRankExpr = class _WindowDenseRankExpr extends WindowRankingExpr {\n  toString() {\n    return `dense_rank(${this._source.toString()})`;\n  }\n  withDescending(desc) {\n    return new _WindowDenseRankExpr(this._source, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const indexed = [];\n    for (let i = 0; i < len; i++) {\n      indexed.push({ value: series.get(i), idx: i });\n    }\n    indexed.sort((a, b) => this._sortCompare(a.value, b.value));\n    const ranks = new Array(len);\n    let rank = 1;\n    for (let i = 0; i < indexed.length; i++) {\n      if (i > 0 && compareValues(indexed[i].value, indexed[i - 1].value) !== 0) {\n        rank++;\n      }\n      ranks[indexed[i].idx] = rank;\n    }\n    return new Series(\"dense_rank\", Float64Column.from(ranks));\n  }\n};\nvar WindowRowNumberExpr = class _WindowRowNumberExpr extends WindowRankingExpr {\n  toString() {\n    return `row_number(${this._source.toString()})`;\n  }\n  withDescending(desc) {\n    return new _WindowRowNumberExpr(this._source, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const values = new Array(len);\n    for (let i = 0; i < len; i++) values[i] = series.get(i);\n    const indexed = Array.from({ length: len }, (_, i) => i);\n    indexed.sort((a, b) => this._sortCompare(values[a], values[b]));\n    const ranks = new Array(len);\n    for (let i = 0; i < indexed.length; i++) {\n      ranks[indexed[i]] = i + 1;\n    }\n    return new Series(\"row_number\", Float64Column.from(ranks));\n  }\n};\nvar WindowPercentRankExpr = class _WindowPercentRankExpr extends WindowRankingExpr {\n  toString() {\n    return `percent_rank(${this._source.toString()})`;\n  }\n  withDescending(desc) {\n    return new _WindowPercentRankExpr(this._source, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    if (len <= 1) {\n      const results = new Array(len).fill(0);\n      return new Series(\"percent_rank\", Float64Column.from(results));\n    }\n    const indexed = [];\n    for (let i = 0; i < len; i++) {\n      indexed.push({ value: series.get(i), idx: i });\n    }\n    indexed.sort((a, b) => this._sortCompare(a.value, b.value));\n    const ranks = new Array(len);\n    let rank = 1;\n    for (let i = 0; i < indexed.length; i++) {\n      if (i > 0 && compareValues(indexed[i].value, indexed[i - 1].value) !== 0) {\n        rank = i + 1;\n      }\n      ranks[indexed[i].idx] = (rank - 1) / (len - 1);\n    }\n    return new Series(\"percent_rank\", Float64Column.from(ranks));\n  }\n};\nvar WindowNtileExpr = class _WindowNtileExpr extends WindowRankingExpr {\n  _n;\n  constructor(source, n, descending = false) {\n    super(source, descending);\n    this._n = n;\n  }\n  toString() {\n    return `ntile(${this._source.toString()}, ${this._n})`;\n  }\n  withDescending(desc) {\n    return new _WindowNtileExpr(this._source, this._n, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const indexed = [];\n    for (let i = 0; i < len; i++) {\n      indexed.push({ value: series.get(i), idx: i });\n    }\n    indexed.sort((a, b) => this._sortCompare(a.value, b.value));\n    const results = new Array(len);\n    for (let i = 0; i < indexed.length; i++) {\n      results[indexed[i].idx] = Math.floor(i * this._n / len) + 1;\n    }\n    return new Series(\"ntile\", Float64Column.from(results));\n  }\n};\nfunction compareValues(a, b) {\n  if (a === null && b === null) return 0;\n  if (a === null) return 1;\n  if (b === null) return -1;\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a - b;\n  }\n  if (typeof a === \"string\" && typeof b === \"string\") {\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() - b.getTime();\n  }\n  const sa = typeof a === \"string\" ? a : typeof a === \"number\" ? `${a}` : typeof a === \"boolean\" ? `${a}` : \"object\";\n  const sb = typeof b === \"string\" ? b : typeof b === \"number\" ? `${b}` : typeof b === \"boolean\" ? `${b}` : \"object\";\n  return sa < sb ? -1 : sa > sb ? 1 : 0;\n}\nvar CumulativeExpr = class extends Expr {\n  _source;\n  constructor(source) {\n    super();\n    this._source = source;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n};\nvar CumSumExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumSum(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let sum = 0;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        sum += v;\n      }\n      results[i] = sum;\n    }\n    return new Series(\"cumSum\", Float64Column.from(results));\n  }\n};\nvar CumMaxExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumMax(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let max = null;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        max = max === null ? v : Math.max(max, v);\n      }\n      results[i] = max;\n    }\n    return new Series(\"cumMax\", Float64Column.from(results));\n  }\n};\nvar CumMinExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumMin(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let min = null;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        min = min === null ? v : Math.min(min, v);\n      }\n      results[i] = min;\n    }\n    return new Series(\"cumMin\", Float64Column.from(results));\n  }\n};\nvar CumProdExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumProd(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let prod = 1;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        prod *= v;\n      }\n      results[i] = prod;\n    }\n    return new Series(\"cumProd\", Float64Column.from(results));\n  }\n};\nvar CumCountExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumCount(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let count = 0;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null) {\n        count++;\n      }\n      results[i] = count;\n    }\n    return new Series(\"cumCount\", Float64Column.from(results));\n  }\n};\nvar OffsetExpr = class extends Expr {\n  _source;\n  _offset;\n  constructor(source, offset) {\n    super();\n    this._source = source;\n    this._offset = offset;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n};\nvar ShiftExpr = class extends OffsetExpr {\n  toString() {\n    return `shift(${this._source.toString()}, ${this._offset})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const srcIdx = i - this._offset;\n      if (srcIdx < 0 || srcIdx >= len) {\n        results[i] = null;\n      } else {\n        const v = series.get(srcIdx);\n        results[i] = v !== null && typeof v === \"number\" ? v : null;\n      }\n    }\n    return new Series(\"shift\", Float64Column.from(results));\n  }\n};\nvar DiffExpr = class extends OffsetExpr {\n  toString() {\n    return `diff(${this._source.toString()}, ${this._offset})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const prevIdx = i - this._offset;\n      if (prevIdx < 0 || prevIdx >= len) {\n        results[i] = null;\n      } else {\n        const curr = series.get(i);\n        const prev = series.get(prevIdx);\n        if (curr !== null && typeof curr === \"number\" && prev !== null && typeof prev === \"number\") {\n          results[i] = curr - prev;\n        } else {\n          results[i] = null;\n        }\n      }\n    }\n    return new Series(\"diff\", Float64Column.from(results));\n  }\n};\nvar PctChangeExpr = class extends OffsetExpr {\n  toString() {\n    return `pctChange(${this._source.toString()}, ${this._offset})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const prevIdx = i - this._offset;\n      if (prevIdx < 0 || prevIdx >= len) {\n        results[i] = null;\n      } else {\n        const curr = series.get(i);\n        const prev = series.get(prevIdx);\n        if (curr !== null && typeof curr === \"number\" && prev !== null && typeof prev === \"number\" && prev !== 0) {\n          results[i] = (curr - prev) / prev;\n        } else {\n          results[i] = null;\n        }\n      }\n    }\n    return new Series(\"pctChange\", Float64Column.from(results));\n  }\n};\nvar RollingExpr = class extends Expr {\n  _source;\n  _windowSize;\n  constructor(source, windowSize) {\n    super();\n    this._source = source;\n    this._windowSize = windowSize;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n  _getNumericValues(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const values = [];\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      values.push(v !== null && typeof v === \"number\" ? v : null);\n    }\n    return values;\n  }\n};\nvar RollingMeanExpr = class extends RollingExpr {\n  toString() {\n    return `rollingMean(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        let sum = 0;\n        let count = 0;\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            sum += v;\n            count++;\n          }\n        }\n        results[i] = count > 0 ? sum / count : null;\n      }\n    }\n    return new Series(\"rollingMean\", Float64Column.from(results));\n  }\n};\nvar RollingSumExpr = class extends RollingExpr {\n  toString() {\n    return `rollingSum(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        let sum = 0;\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            sum += v;\n          }\n        }\n        results[i] = sum;\n      }\n    }\n    return new Series(\"rollingSum\", Float64Column.from(results));\n  }\n};\nvar RollingStdExpr = class extends RollingExpr {\n  toString() {\n    return `rollingStd(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        const windowVals = [];\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            windowVals.push(v);\n          }\n        }\n        if (windowVals.length < 2) {\n          results[i] = null;\n        } else {\n          let sum = 0;\n          for (const v of windowVals) sum += v;\n          const mean = sum / windowVals.length;\n          let sqDiffSum = 0;\n          for (const v of windowVals) sqDiffSum += (v - mean) * (v - mean);\n          results[i] = Math.sqrt(sqDiffSum / (windowVals.length - 1));\n        }\n      }\n    }\n    return new Series(\"rollingStd\", Float64Column.from(results));\n  }\n};\nvar RollingMinExpr = class extends RollingExpr {\n  toString() {\n    return `rollingMin(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        let min = null;\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            min = min === null ? v : Math.min(min, v);\n          }\n        }\n        results[i] = min;\n      }\n    }\n    return new Series(\"rollingMin\", Float64Column.from(results));\n  }\n};\nvar RollingMaxExpr = class extends RollingExpr {\n  toString() {\n    return `rollingMax(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        let max = null;\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            max = max === null ? v : Math.max(max, v);\n          }\n        }\n        results[i] = max;\n      }\n    }\n    return new Series(\"rollingMax\", Float64Column.from(results));\n  }\n};\nvar EwmExpr = class extends Expr {\n  _source;\n  _alpha;\n  constructor(source, alpha) {\n    super();\n    this._source = source;\n    this._alpha = alpha;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n  toString() {\n    return `ewm(${this._source.toString()}, ${this._alpha})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let ewma = null;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        if (ewma === null) {\n          ewma = v;\n        } else {\n          ewma = this._alpha * v + (1 - this._alpha) * ewma;\n        }\n        results[i] = ewma;\n      } else {\n        results[i] = ewma;\n      }\n    }\n    return new Series(\"ewm\", Float64Column.from(results));\n  }\n};\nvar PartitionedWindowExpr = class extends Expr {\n  _inner;\n  _partitionCols;\n  constructor(inner, partitionCols) {\n    super();\n    this._inner = inner;\n    this._partitionCols = partitionCols;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._inner.dependencies, ...this._partitionCols])];\n  }\n  toString() {\n    return `${this._inner.toString()}.over(${this._partitionCols.join(\", \")})`;\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const results = new Array(len);\n    const partitionMap = /* @__PURE__ */ new Map();\n    const partCols = this._partitionCols.map((name) => df2.col(name).column);\n    for (let i = 0; i < len; i++) {\n      const key = serializeKey4(partCols, i);\n      const group = partitionMap.get(key);\n      if (group) {\n        group.push(i);\n      } else {\n        partitionMap.set(key, [i]);\n      }\n    }\n    const columnOrder = df2.columns;\n    for (const indices of partitionMap.values()) {\n      const int32Indices = new Int32Array(indices);\n      const newColumns = /* @__PURE__ */ new Map();\n      for (const name of columnOrder) {\n        newColumns.set(name, df2.col(name).column.take(int32Indices));\n      }\n      const subDf = new DataFrame(newColumns, columnOrder);\n      const subResult = this._inner.evaluate(subDf);\n      for (let i = 0; i < indices.length; i++) {\n        results[indices[i]] = subResult.get(i);\n      }\n    }\n    return new Series(\"over\", Float64Column.from(results));\n  }\n};\nfunction serializeKey4(columns, index) {\n  const parts = [];\n  for (const column of columns) {\n    const v = column.get(index);\n    if (v === null) {\n      parts.push(\"\\0null\");\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nvar OrderedWindowExpr = class extends Expr {\n  _inner;\n  _orderCol;\n  _direction;\n  constructor(inner, orderCol, direction = \"asc\") {\n    super();\n    this._inner = inner;\n    this._orderCol = orderCol;\n    this._direction = direction;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._inner.dependencies, this._orderCol])];\n  }\n  toString() {\n    return `${this._inner.toString()}.orderBy(${this._orderCol}, ${this._direction})`;\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const descending = this._direction === \"desc\";\n    const directedInner = applyRankingDirection(this._inner, descending);\n    const orderCol = df2.col(this._orderCol).column;\n    const indices = [];\n    for (let i = 0; i < len; i++) indices.push(i);\n    const dir = descending ? -1 : 1;\n    indices.sort((a, b) => dir * compareValues(orderCol.get(a), orderCol.get(b)));\n    const int32Indices = new Int32Array(indices);\n    const columnOrder = df2.columns;\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of columnOrder) {\n      newColumns.set(name, df2.col(name).column.take(int32Indices));\n    }\n    const sortedDf = new DataFrame(newColumns, columnOrder);\n    const sortedResult = directedInner.evaluate(sortedDf);\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      results[indices[i]] = sortedResult.get(i);\n    }\n    return new Series(\"orderBy\", Float64Column.from(results));\n  }\n};\nfunction applyRankingDirection(expr, descending) {\n  if (expr instanceof WindowRankingExpr) {\n    return expr.withDescending(descending);\n  }\n  if (expr instanceof PartitionedWindowExpr) {\n    const directedInner = applyRankingDirection(expr._inner, descending);\n    return new PartitionedWindowExpr(directedInner, expr[\"_partitionCols\"]);\n  }\n  return expr;\n}\nExpr.prototype.rank = function() {\n  return new WindowRankExpr(this);\n};\nExpr.prototype.denseRank = function() {\n  return new WindowDenseRankExpr(this);\n};\nExpr.prototype.rowNumber = function() {\n  return new WindowRowNumberExpr(this);\n};\nExpr.prototype.percentRank = function() {\n  return new WindowPercentRankExpr(this);\n};\nExpr.prototype.ntile = function(n) {\n  return new WindowNtileExpr(this, n);\n};\nExpr.prototype.cumSum = function() {\n  return new CumSumExpr(this);\n};\nExpr.prototype.cumMax = function() {\n  return new CumMaxExpr(this);\n};\nExpr.prototype.cumMin = function() {\n  return new CumMinExpr(this);\n};\nExpr.prototype.cumProd = function() {\n  return new CumProdExpr(this);\n};\nExpr.prototype.cumCount = function() {\n  return new CumCountExpr(this);\n};\nExpr.prototype.shift = function(offset) {\n  return new ShiftExpr(this, offset);\n};\nExpr.prototype.diff = function(offset = 1) {\n  return new DiffExpr(this, offset);\n};\nExpr.prototype.pctChange = function(offset = 1) {\n  return new PctChangeExpr(this, offset);\n};\nExpr.prototype.rollingMean = function(windowSize) {\n  return new RollingMeanExpr(this, windowSize);\n};\nExpr.prototype.rollingSum = function(windowSize) {\n  return new RollingSumExpr(this, windowSize);\n};\nExpr.prototype.rollingStd = function(windowSize) {\n  return new RollingStdExpr(this, windowSize);\n};\nExpr.prototype.rollingMin = function(windowSize) {\n  return new RollingMinExpr(this, windowSize);\n};\nExpr.prototype.rollingMax = function(windowSize) {\n  return new RollingMaxExpr(this, windowSize);\n};\nExpr.prototype.ewm = function(alpha) {\n  return new EwmExpr(this, alpha);\n};\nExpr.prototype.over = function(...partitionCols) {\n  return new PartitionedWindowExpr(this, partitionCols);\n};\nExpr.prototype.orderBy = function(column, direction = \"asc\") {\n  return new OrderedWindowExpr(this, column, direction);\n};\n\n// src/browser.ts\nfunction df(rows) {\n  return DataFrame.fromRows(rows);\n}\nexport {\n  AggExpr,\n  BitArray,\n  BooleanColumn,\n  Column,\n  ColumnNotFoundError,\n  CountAggExpr,\n  CountDistinctAggExpr,\n  CumCountExpr,\n  CumMaxExpr,\n  CumMinExpr,\n  CumProdExpr,\n  CumSumExpr,\n  DType,\n  DataFrame,\n  DateAccessor,\n  DateColumn,\n  DateExprAccessor,\n  DiffExpr,\n  ErrorCode,\n  Expr,\n  FirstAggExpr,\n  Float64Column,\n  FrameKitError,\n  GroupBy,\n  IOError,\n  Int32Column,\n  LastAggExpr,\n  LazyFrame,\n  LazyGroupBy,\n  ListAggExpr,\n  MaxAggExpr,\n  MeanAggExpr,\n  MinAggExpr,\n  ModeAggExpr,\n  NamedExpr,\n  ObjectColumn,\n  OrderedWindowExpr,\n  ParseError,\n  PartitionedWindowExpr,\n  PctChangeExpr,\n  Series,\n  ShapeMismatchError,\n  ShiftExpr,\n  StdAggExpr,\n  StringAccessor,\n  StringExprAccessor,\n  SumAggExpr,\n  ThenBuilder,\n  TypeMismatchError,\n  Utf8Column,\n  WhenBuilder,\n  WindowDenseRankExpr,\n  WindowNtileExpr,\n  WindowPercentRankExpr,\n  WindowRankExpr,\n  WindowRowNumberExpr,\n  col,\n  df,\n  execute,\n  lit,\n  optimize,\n  when\n};\n//# sourceMappingURL=browser.js.map"],"names":["cpus","count","platform","arch","tmpdir","EOL","os","DType","DType2","ErrorCode","ErrorCode2","FrameKitError","code","message","ColumnNotFoundError","column","available","TypeMismatchError","ShapeMismatchError","ParseError","IOError","BitArray","_BitArray","length","initialValue","byteCount","index","byteIndex","bitIndex","value","i","other","result","Column","nullMask","Float64Column","_Float64Column","data","start","end","sliced","mask","indices","idx","total","validCount","val","values","hasNull","v","Int32Column","_Int32Column","Utf8Column","_Utf8Column","interned","len","slicedIndices","newIndices","bytes","s","dictMap","dictionary","dictSize","BooleanColumn","_BooleanColumn","DateColumn","_DateColumn","ObjectColumn","_ObjectColumn","StringAccessor","series","prefix","suffix","pattern","replacement","separator","col2","ListColumn","Series","results","fillChar","source","match","fn","_ListColumn","arr","idxArray","DateAccessor","d","diff","oneDay","target","jan4","dayDiff","formatDate","unit","a","b","dateDiff","truncateDate","date","pad2","n","pad4","msA","diffMs","yearDiff","monthDiff","dayFrac","monthFrac","_createDataFrame","_registerDataFrameFactory","factory","_Series","name","m","sumSqDiff","mid","low","high","running","decimals","factor","set","filled","seen","key","counts","order","entry","countValues","valueCol","countCol","columns","dtype","converted","buildColumnFromDType","resultDType","r","predicate","targetDType","Expr","_Expr","NamedExpr","ArithmeticExpr","wrapNum","ComparisonExpr","wrap","LogicalExpr","wrapBool","NotExpr","deps","SumAggExpr","MeanAggExpr","CountAggExpr","CountDistinctAggExpr","MinAggExpr","MaxAggExpr","StdAggExpr","FirstAggExpr","LastAggExpr","ListAggExpr","ModeAggExpr","others","exprs","o","LiteralExpr","CoalesceExpr","valExpr","FillNullExpr","IsNullExpr","IsNotNullExpr","expr","buildColumnForValues","detectLiteralDType","df2","ColumnExpr","ARITH_OP_SYMBOLS","left","right","op","leftSeries","rightSeries","applyArithOp","CMP_OP_SYMBOLS","columnName","literal","len2","results2","applyCmpOp","inner","innerSeries","col","lit","toComparableKey","AggExpr","mean","acc","best","bestCount","e","evaluated","found","fill","fillSeries","DEFAULT_NULL_VALUES","CH_QUOTE","CH_LF","CH_CR","CH_COMMA","CH_SEMI","CH_TAB","CH_PIPE","parseCSV","content","options","comment","hasHeader","nullValues","skipRows","delimiter","detectDelimiterFast","delimCode","delimLen","multiCharDelim","pos","skipped","skipLine","lineStart","c","header","headerResult","parseLineFields","h","_","selectedColumns","activeHeader","colIndices","estimatedRows","maxRows","rowCount","numActiveCols","allColumns","parseRowDirect","parseRowFiltered","inferredTypes","inferColumnTypes","inQuotes","ch","fields","fieldStart","hasEscape","next","c2","numCols","colIdx","skipToEOL","fieldIdx","activeIdx","currentWanted","wanted","candidates","candidateStrs","maxLines","bestDelimiter","bestScore","ci","lineIdx","avg","score","types","parseNumbers","parseDates","sample","isNumericString","isIntegerString","isBooleanString","isDateString","lower","ISO_DATE_RE","writeCSV","rows","quoteStyle","nullValue","includeHeader","bom","lines","quoteField","row","DEFAULT_NULL_VALUES2","streamCSVFile","filePath","chunkSize","fs","createReadStream","stream","err","schema","buffer","pendingLines","linesSkipped","headerConsumed","chunkRows","totalRowsEmitted","nRows","parseLine","line","current","quoted","detectDelimiter","delim","q","inferTypes","opts","isNumericString2","isIntegerString2","isBooleanString2","isDateString2","initChunkRows","cols","addRowToChunk","schema2","raw","parsedHeader","detectedDelimiter","processLine","tempCols","pl","fields2","rawChunk","finalSchema","remaining","ISO_DATE_RE2","streamNDJSONFile","chunk","totalEmitted","writeJSON","objects","obj","writeNDJSON","detectCellDType","parseCellRef","ref","colStr","rowNum","colNum","parseRange","range","parts","getWorksheet","workbook","sheet","ws2","ws","normalizeCellValue","parseExcelWorksheet","worksheet","rangeDef","startRow","endRow","startCol","endCol","rawRows","rowValues","cell","dataStartIdx","colCount","j","colName","colValues","detected","readExcelFile","ExcelJS","arrowTypeToDType","field","extractColumnValues","readParquetFile","parquetWasm","uint8","arrowTable","numFields","numRows","allFields","selectedFields","f","arrowCol","parseCellRef2","columnNumberToLetter","remainder","writeExcelFile","sheetName","startCell","cellRef","lastColLetter","lastRow","freezeRow","freezeCol","width","dtypeToArrowType","arrow","coerceValues","resolveCompression","compression","Compression","writeParquetFile","arrowColumns","arrowType","coerced","ipcBytes","wasmTable","resolvedCompression","builder","writerProperties","parquetBytes","dtypeToArrowType2","coerceValue","toArrowTable","input","columnOrder","getColumnValues","tableData","arrowTypeToDType2","typeId","typeStr","fromArrowTable","table","WORKER_CODE","DEFAULT_THRESHOLD","defaultWorkerCount","workerThreadsAvailable","isWorkerThreadsAvailableSync","shouldUseParallel","threshold","serializeColumn","maskBytes","partitionGroups","groupEntries","workerCount","partitions","parallelAgg","keyColumnNames","keyColumns","aggSpecs","sourceColumns","wt","Worker","neededColumns","keyName","spec","serializedColumns","workerPromises","partition","resolve","reject","worker","allResults","workerResult","GroupBy","keys","k","internedIndices","dictLen","buckets","nullBucket","bucket","keyStr","group","specs","resolvedSpecs","aggExpr","aggType","keyCols","nGroups","resultColumns","ki","vals","aggNames","Ctor","keyValues","aggValues","onlyAggName","onlyAgg","sourceCol","firstIndex","sum","hasValue","ii","resultColumns2","columnOrder2","Ctor2","int32Indices","subColumns","sourceName","subFrame","method","colExpr","_length","nonKeyColumns","newColumns","serializeKey","normalizeSingleKey","buildColumnFromValues","resolveKeys","on","leftKeys","rightKeys","crossJoin","resultLength","rightColRenames","rc","srcCol","li","ri","outputName","semiAntiJoin","anti","rightKeyCols","leftKeyCols","rightKeySet","rightKeyCol","matchedIndices","leftKeyCol","hasMatch","hashJoin","how","rightIndexByKey","rightKeyUnique","rightNonKeyCols2","rightColRenames2","hashTable","leftIndices","rightIndices","rightMatched","matches","mi","rightNonKeyCols","leftNonKeyCols","leftKey","rightKey","leftCol","rightCol","serializeKey2","buildColumnFromValues2","lookup","valueCols","lookupMap","spread","limit","nameFn","drop","isObject","maxArrayLen","objectKeys","effectiveKeys","outName","unroll","nonUnrollCols","rowCounts","maxLen","totalRows","resultData","indexData","outIdx","rowKey","cartesian","out","item","impute","expandKeys","sourceRows","workingRows","keyDomains","normalized","combos","existing","combo","comboRow","existingRow","generated","columnData","resolvedValues","resultRows","fillValue","aggregate","aggFunc","serializeKey3","indexCols","buildColumnFromValues3","pivot","columnsCol","valuesCol","indexKeyOrder","indexKeyToRowIndices","pivotColValues","pivotColSet","pivotColumnSeries","str","cellData","indexKey","pivotVal","pivotStr","cellKey","valuesDtype","resultDtype","idxCol","firstRow","cellValues","buildColumnFromValues4","detectDType","melt","idVars","varName","valueName","valueVars","idSet","nValueVars","idCol","sourceSeries","varValues","valueValues","valueDtype","detectDType2","buildColumnFromValues5","serializeValue","transpose","headerColumn","newHeaders","headerSeries","rowIdx","concat","frames","first","columnSet","frame","dtypeMap","dtypes","offset","frameLen","serializeRow","validateMatchingSchemas","leftCols","rightCols","leftDtypes","rightDtypes","buildColumnFromValues6","collectRows","union","valueArrays","intersection","difference","escapeIdentifier","escapeSQLValue","writeSQL","tableName","batchSize","columnList","statements","valueRows","nextNodeId","createScanNode","explainPlan","node","indent","pad","exprStrs","aggStrs","execute","plan","run","gb","agg","optimize","optimized","pushDown","merged","mergeFilters","pushProjectionDown","filter","pushFilterDown","child","needed","projection","childNeeded","dep","onCols","leftNeeded","rightNeeded","LazyGroupBy","LazyFrame","_LazyFrame","by","descending","subset","original","optimizedPlan","ext","createLazyFrame","KEYWORDS","tokenize","tokens","upper","Parser","token","type","selectAll","selectItems","fromToken","whereExpr","groupByColumns","havingExpr","orderByItems","num","upperVal","aggName","alias2","alias","direction","leftToken","IsNullExpr2","inExpr","rightValue","aggAlias","aggColExpr","regexStr","LikeExpr","regex","invert","buildAggSpec","colRef","executeQuery","queryStr","query","aggSpec","selectedCols","columnNames","renameMap","orders","DataFrame","_DataFrame","clonedColumns","dropSet","newOrder","resolvedEnd","resolvedStart","valuesOrFnOrExpr","newColumns2","newOrder2","columnValues","detectDType3","newCol","buildColumn","before","after","anchor","anchorIdx","insertIdx","mapping","oldName","newName","predicateOrExpr","cmpAny","targetIdx","isEq","count4","indices4","pos4","count3","keep","indices3","pos3","boolSeries","count2","indices2","pos2","litValue","sortCol","desc","sortedDictIndices","sa","sb","cmp","rank","aValid","bValid","int32Indices3","newColumns3","va","vb","aIsNull","bIsNull","int32Indices2","c0","c1","v0","v1","d0","d1","a0","b0","a0Null","b0Null","cmp0","a1","b1","a1Null","b1Null","cmp1","sortValues","lastIndex","rng","seededRandom","tmp","explodeCol","otherColNames","resultArrays","strategy","casted","maxCols","nCols","allCols","displayCols","half","rowIndices","formatValue","headerRow","dataRows","cells","colWidths","maxW","w","sep","headerLine","topBorder","headerSep","bottomBorder","colObj","std","min","max","colNameWidth","totalMemory","nullCount","mem","formatBytes","firstKey","step","chunks","response","parsed","buildDataFrameFromParsed","path","placeholder","lazy","filePathOrOptions","maybeOptions","writable","csvString","settled","fail","part","jsonString","ndjsonString","extension","readerFn","writerFn","reader","writer","seed","t","rawColumns","rawValues","typedValues","convertColumnValues","detectValueDType","buildColumnForValues2","WhenExpr","clauses","otherwise","clause","conditionResults","valueResults","otherwiseResult","detectedDType","matched","WhenBuilder","condition","ThenBuilder","ChainedWhenBuilder","when","StringUnaryExpr","StringContainsExpr","StringStartsWithExpr","StringEndsWithExpr","StringReplaceExpr","StringSliceExpr","StringLengthExpr","StringConcatExpr","p","evaluatedParts","StringExprAccessor","extractDateComponent","DateComponentExpr","DateTruncateExpr","truncateDate2","DateDiffExpr","convertMsToDiffUnit","ms","DateExprAccessor","WindowRankingExpr","compareValues","WindowRankExpr","_WindowRankExpr","indexed","ranks","WindowDenseRankExpr","_WindowDenseRankExpr","WindowRowNumberExpr","_WindowRowNumberExpr","WindowPercentRankExpr","_WindowPercentRankExpr","WindowNtileExpr","_WindowNtileExpr","CumulativeExpr","CumSumExpr","CumMaxExpr","CumMinExpr","CumProdExpr","prod","CumCountExpr","OffsetExpr","ShiftExpr","srcIdx","DiffExpr","prevIdx","curr","prev","PctChangeExpr","RollingExpr","windowSize","RollingMeanExpr","RollingSumExpr","RollingStdExpr","windowVals","sqDiffSum","RollingMinExpr","RollingMaxExpr","EwmExpr","alpha","ewma","PartitionedWindowExpr","partitionCols","partitionMap","partCols","serializeKey4","subDf","subResult","OrderedWindowExpr","orderCol","directedInner","applyRankingDirection","dir","sortedDf","sortedResult","df"],"mappings":"AAGO,SAASA,IAA4B,CAC1C,MAAMC,EACJ,OAAO,UAAc,KAAe,UAAU,oBAC1C,UAAU,oBACV,EACN,OAAO,MAAM,KAAK,CAAE,OAAQA,CAAA,EAAS,KAAO,CAAE,MAAO,SAAA,EAAY,CACnE,CAEO,SAASC,IAAmB,CACjC,MAAO,SACT,CAEO,SAASC,IAAe,CAC7B,MAAO,SACT,CAEO,SAASC,IAAiB,CAC/B,MAAO,MACT,CAEO,MAAMC,GAAM;AAAA,EAEnB,IAAAC,GAAe,CAAE,KAAAN,GAAM,SAAAE,GAAU,KAAAC,GAAM,OAAAC,GAAQ,IAAAC,EAAA,ECxB3CE,IAA0BC,IAC5BA,EAAO,QAAa,MACpBA,EAAO,MAAW,MAClBA,EAAO,MAAW,MAClBA,EAAO,KAAU,OACjBA,EAAO,QAAa,OACpBA,EAAO,KAAU,OACjBA,EAAO,SAAc,WACrBA,EAAO,KAAU,OACjBA,EAAO,OAAY,SACnBA,EAAO,OAAY,SACZA,IACND,IAAS,CAAA,CAAE,EAGVE,IAA8BC,IAChCA,EAAW,iBAAsB,mBACjCA,EAAW,cAAmB,gBAC9BA,EAAW,eAAoB,iBAC/BA,EAAW,YAAiB,cAC5BA,EAAW,SAAc,WACzBA,EAAW,cAAmB,gBAC9BA,EAAW,kBAAuB,oBAC3BA,IACND,IAAa,CAAA,CAAE,EACdE,EAAgB,cAAc,KAAM,CACtC,KACA,YAAYC,EAAMC,EAAS,CACzB,MAAMA,CAAO,EACb,KAAK,KAAO,gBACZ,KAAK,KAAOD,CACd,CACF,EACIE,EAAsB,cAAcH,CAAc,CACpD,YAAYI,EAAQC,EAAW,CAC7B,MACE,mBACA,WAAWD,CAAM,oCAAoCC,EAAU,KAAK,IAAI,CAAC,GAC/E,EACI,KAAK,KAAO,qBACd,CACF,EACIC,GAAoB,cAAcN,CAAc,CAClD,YAAYE,EAAS,CACnB,MAAM,gBAAqCA,CAAO,EAClD,KAAK,KAAO,mBACd,CACF,EACIK,GAAqB,cAAcP,CAAc,CACnD,YAAYE,EAAS,CACnB,MAAM,iBAAuCA,CAAO,EACpD,KAAK,KAAO,oBACd,CACF,EACIM,GAAa,cAAcR,CAAc,CAC3C,YAAYE,EAAS,CACnB,MAAM,cAAiCA,CAAO,EAC9C,KAAK,KAAO,YACd,CACF,EACIO,EAAU,cAAcT,CAAc,CACxC,YAAYE,EAAS,CACnB,MAAM,WAA2BA,CAAO,EACxC,KAAK,KAAO,SACd,CACF,EAGIQ,EAAW,MAAMC,EAAU,CAC7B,QACA,QACA,YAAYC,EAAQC,EAAe,GAAO,CACxC,GAAID,EAAS,EACX,MAAM,IAAIZ,EACR,oBACA,6CAA6CY,CAAM,EAC3D,EAEI,KAAK,QAAUA,EACf,MAAME,EAAY,KAAK,KAAKF,EAAS,CAAC,EACtC,KAAK,QAAU,IAAI,WAAWE,CAAS,EACnCD,GACF,KAAK,QAAQ,KAAK,GAAG,CAEzB,CACA,IAAI,QAAS,CACX,OAAO,KAAK,OACd,CACA,IAAI,YAAa,CACf,OAAO,KAAK,QAAQ,UACtB,CACA,IAAIE,EAAO,CACT,YAAK,aAAaA,CAAK,EAChB,KAAK,UAAUA,CAAK,CAC7B,CACA,UAAUA,EAAO,CACf,MAAMC,EAAYD,GAAS,EACrBE,EAAWF,EAAQ,EACzB,OAAQ,KAAK,QAAQC,CAAS,EAAI,GAAKC,KAAc,CACvD,CACA,IAAIF,EAAOG,EAAO,CAChB,KAAK,aAAaH,CAAK,EACvB,KAAK,UAAUA,EAAOG,CAAK,CAC7B,CACA,UAAUH,EAAOG,EAAO,CACtB,MAAMF,EAAYD,GAAS,EACrBE,EAAWF,EAAQ,EACrBG,EACF,KAAK,QAAQF,CAAS,EAAI,KAAK,QAAQA,CAAS,EAAI,GAAKC,EAEzD,KAAK,QAAQD,CAAS,EAAI,KAAK,QAAQA,CAAS,EAAI,EAAE,GAAKC,EAE/D,CACA,WAAY,CACV,IAAI3B,EAAQ,EACZ,QAAS6B,EAAI,EAAGA,EAAI,KAAK,QAASA,IAC5B,KAAK,IAAIA,CAAC,GACZ7B,IAGJ,OAAOA,CACT,CACA,YAAa,CACX,OAAO,KAAK,QAAU,KAAK,UAAS,CACtC,CACA,IAAI8B,EAAO,CACT,KAAK,aAAaA,CAAK,EACvB,MAAMC,EAAS,IAAIV,GAAU,KAAK,OAAO,EACzC,QAASQ,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCE,EAAO,QAAQF,CAAC,EAAI,KAAK,QAAQA,CAAC,EAAIC,EAAM,QAAQD,CAAC,EAEvD,OAAOE,CACT,CACA,GAAGD,EAAO,CACR,KAAK,aAAaA,CAAK,EACvB,MAAMC,EAAS,IAAIV,GAAU,KAAK,OAAO,EACzC,QAASQ,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCE,EAAO,QAAQF,CAAC,EAAI,KAAK,QAAQA,CAAC,EAAIC,EAAM,QAAQD,CAAC,EAEvD,OAAOE,CACT,CACA,OAAQ,CACN,MAAMA,EAAS,IAAIV,GAAU,KAAK,OAAO,EACzC,OAAAU,EAAO,QAAQ,IAAI,KAAK,OAAO,EACxBA,CACT,CACA,KAAM,CACJ,MAAMA,EAAS,IAAIV,GAAU,KAAK,OAAO,EACzC,QAASQ,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCE,EAAO,QAAQF,CAAC,EAAI,CAAC,KAAK,QAAQA,CAAC,EAAI,IAEzC,OAAOE,CACT,CACA,aAAaN,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,kBAAkBe,CAAK,6BAA6B,KAAK,OAAO,EACxE,CAEE,CACA,aAAaK,EAAO,CAClB,GAAI,KAAK,UAAYA,EAAM,QACzB,MAAM,IAAIpB,EACR,iBACA,6BAA6B,KAAK,OAAO,OAAOoB,EAAM,OAAO,EACrE,CAEE,CACF,EAGIE,GAAS,KAAM,CACjB,UACA,QACA,UAAY,EACZ,YAAYV,EAAQW,EAAU,CAC5B,KAAK,QAAUX,EACf,KAAK,UAAYW,GAAY,IAAIb,EAASE,EAAQ,EAAI,CACxD,CACA,IAAI,QAAS,CACX,OAAO,KAAK,OACd,CACA,IAAI,WAAY,CACd,OAAO,KAAK,UAAU,WAAU,CAClC,CACA,QAAS,CACP,KAAK,WACP,CACA,SAAU,CACJ,KAAK,UAAY,GACnB,KAAK,WAET,CACA,IAAI,UAAW,CACb,OAAO,KAAK,SACd,CACA,IAAI,UAAW,CACb,OAAO,KAAK,UAAY,CAC1B,CACF,EAGIY,EAAgB,MAAMC,WAAuBH,EAAO,CACtD,MAAQ,MACR,MACA,UACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,EACb,KAAK,UAAYH,IAAa,MAChC,CACA,IAAIR,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EACnB,KAAK,UACA,KAAK,MAAMA,CAAK,EAEpB,KAAK,UAAU,UAAUA,CAAK,EAG5B,KAAK,MAAMA,CAAK,EAFd,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,SAASF,EAAOC,CAAG,EAC7C,GAAI,KAAK,UACP,OAAO,IAAIH,GAAeI,CAAM,EAElC,MAAMC,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIM,GAAeI,EAAQC,CAAI,CACxC,CACA,OAAQ,CACN,OAAI,KAAK,UACA,IAAIL,GAAe,IAAI,aAAa,KAAK,KAAK,CAAC,EAEjD,IAAIA,GAAe,IAAI,aAAa,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAChF,CACA,OAAOK,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,aAAaK,EAAQ,MAAM,EACtCD,EAAO,KAAK,UAAY,OAAS,IAAIpB,EAASqB,EAAQ,MAAM,EAClE,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACpBF,GACFA,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CAEnD,CACA,OAAO,IAAIP,GAAeC,EAAMI,CAAI,CACtC,CACA,KAAM,CACJ,IAAIG,EAAQ,EACZ,QAASd,EAAI,EAAGA,EAAI,KAAK,QAASA,IAC5B,KAAK,UAAU,UAAUA,CAAC,IAC5Bc,GAAS,KAAK,MAAMd,CAAC,GAGzB,OAAOc,CACT,CACA,MAAO,CACL,MAAMC,EAAa,KAAK,QAAU,KAAK,UACvC,OAAIA,IAAe,EAAU,KACtB,KAAK,IAAG,EAAKA,CACtB,CACA,KAAM,CACJ,IAAIb,EAAS,KACb,QAASF,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,UAAUA,CAAC,EAAG,CAC/B,MAAMgB,EAAM,KAAK,MAAMhB,CAAC,GACpBE,IAAW,MAAQc,EAAMd,KAC3BA,EAASc,EAEb,CAEF,OAAOd,CACT,CACA,KAAM,CACJ,IAAIA,EAAS,KACb,QAASF,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,UAAUA,CAAC,EAAG,CAC/B,MAAMgB,EAAM,KAAK,MAAMhB,CAAC,GACpBE,IAAW,MAAQc,EAAMd,KAC3BA,EAASc,EAEb,CAEF,OAAOd,CACT,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,EAAI,KAAK,UAAU,UAC3C,CACA,OAAO,KAAKe,EAAQ,CAClB,MAAMV,EAAO,IAAI,aAAaU,EAAO,MAAM,EACrCN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,IAAIC,EAAU,GACd,QAASlB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,MACRZ,EAAKP,CAAC,EAAImB,EACVR,EAAK,UAAUX,EAAG,EAAI,GAEtBkB,EAAU,EAEd,CACA,OAAOA,EAAU,IAAIZ,GAAeC,EAAMI,CAAI,EAAI,IAAIL,GAAeC,CAAI,CAC3E,CACA,aAAaX,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,aAAaK,EAAQ,MAAM,EACtCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIP,GAAeC,EAAMI,CAAI,CACtC,CACF,EACIS,GAAc,MAAMC,WAAqBlB,EAAO,CAClD,MAAQ,MACR,MACA,UACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,EACb,KAAK,UAAYH,IAAa,MAChC,CACA,IAAIR,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EACnB,KAAK,UACA,KAAK,MAAMA,CAAK,EAEpB,KAAK,UAAU,UAAUA,CAAK,EAG5B,KAAK,MAAMA,CAAK,EAFd,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,SAASF,EAAOC,CAAG,EAC7C,GAAI,KAAK,UACP,OAAO,IAAIY,GAAaX,CAAM,EAEhC,MAAMC,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIqB,GAAaX,EAAQC,CAAI,CACtC,CACA,OAAQ,CACN,OAAI,KAAK,UACA,IAAIU,GAAa,IAAI,WAAW,KAAK,KAAK,CAAC,EAE7C,IAAIA,GAAa,IAAI,WAAW,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAC5E,CACA,OAAOV,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,WAAWK,EAAQ,MAAM,EACpCD,EAAO,KAAK,UAAY,OAAS,IAAIpB,EAASqB,EAAQ,MAAM,EAClE,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACpBF,GACFA,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CAEnD,CACA,OAAO,IAAIQ,GAAad,EAAMI,CAAI,CACpC,CACA,KAAM,CACJ,IAAIG,EAAQ,EACZ,QAASd,EAAI,EAAGA,EAAI,KAAK,QAASA,IAC5B,KAAK,UAAU,UAAUA,CAAC,IAC5Bc,GAAS,KAAK,MAAMd,CAAC,GAGzB,OAAOc,CACT,CACA,MAAO,CACL,MAAMC,EAAa,KAAK,QAAU,KAAK,UACvC,OAAIA,IAAe,EAAU,KACtB,KAAK,IAAG,EAAKA,CACtB,CACA,KAAM,CACJ,IAAIb,EAAS,KACb,QAASF,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,UAAUA,CAAC,EAAG,CAC/B,MAAMgB,EAAM,KAAK,MAAMhB,CAAC,GACpBE,IAAW,MAAQc,EAAMd,KAC3BA,EAASc,EAEb,CAEF,OAAOd,CACT,CACA,KAAM,CACJ,IAAIA,EAAS,KACb,QAASF,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,UAAUA,CAAC,EAAG,CAC/B,MAAMgB,EAAM,KAAK,MAAMhB,CAAC,GACpBE,IAAW,MAAQc,EAAMd,KAC3BA,EAASc,EAEb,CAEF,OAAOd,CACT,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,EAAI,KAAK,UAAU,UAC3C,CACA,OAAO,KAAKe,EAAQ,CAClB,MAAMV,EAAO,IAAI,WAAWU,EAAO,MAAM,EACnCN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,IAAIC,EAAU,GACd,QAASlB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,MACRZ,EAAKP,CAAC,EAAImB,EACVR,EAAK,UAAUX,EAAG,EAAI,GAEtBkB,EAAU,EAEd,CACA,OAAOA,EAAU,IAAIG,GAAad,EAAMI,CAAI,EAAI,IAAIU,GAAad,CAAI,CACvE,CACA,aAAaX,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,WAAWK,EAAQ,MAAM,EACpCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIQ,GAAad,EAAMI,CAAI,CACpC,CACF,EAGIW,EAAa,MAAMC,UAAoBpB,EAAO,CAChD,MAAQ,OACR,MACA,UACA,UACA,YAAYI,EAAMH,EAAUoB,EAAU,CACpC,MAAMjB,EAAK,OAAQH,CAAQ,EACvBoB,GACF,KAAK,MAAQ,KACb,KAAK,UAAYA,IAEjB,KAAK,MAAQjB,EACb,KAAK,UAAY,MAEnB,KAAK,UAAYH,IAAa,MAChC,CAEA,IAAI,YAAa,CACf,OAAO,KAAK,YAAc,IAC5B,CAEA,IAAI,iBAAkB,CACpB,OAAO,KAAK,SACd,CAEA,IAAI,UAAW,CACb,OAAO,KAAK,SACd,CAEA,IAAI,UAAW,CACb,OAAO,KAAK,SACd,CAEA,IAAI,SAAU,CACZ,OAAO,KAAK,KACd,CACA,IAAIR,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EACnB,KAAK,UACH,KAAK,UACA,KAAK,UAAU,WAAW,KAAK,UAAU,QAAQA,CAAK,CAAC,EAEzD,KAAK,MAAMA,CAAK,EAEpB,KAAK,UAAU,UAAUA,CAAK,EAG/B,KAAK,UACA,KAAK,UAAU,WAAW,KAAK,UAAU,QAAQA,CAAK,CAAC,EAEzD,KAAK,MAAMA,CAAK,EALd,IAMX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMgB,EAAMhB,EAAMD,EAClB,GAAI,KAAK,UAAW,CAClB,GAAI,KAAK,UAAW,CAClB,MAAMkB,EAAgB,KAAK,UAAU,QAAQ,MAAMlB,EAAOC,CAAG,EAC7D,OAAO,IAAIc,EAAY,IAAI,MAAME,CAAG,EAAG,OAAQ,CAC7C,WAAY,KAAK,UAAU,WAC3B,QAASC,CACnB,CAAS,CACH,CACA,OAAO,IAAIH,EAAY,KAAK,MAAM,MAAMf,EAAOC,CAAG,CAAC,CACrD,CACA,MAAME,EAAO,IAAIpB,EAASkC,CAAG,EAC7B,QAAS,EAAI,EAAG,EAAIA,EAAK,IACvBd,EAAK,UAAU,EAAG,KAAK,UAAU,UAAUH,EAAQ,CAAC,CAAC,EAEvD,GAAI,KAAK,UAAW,CAClB,MAAMkB,EAAgB,KAAK,UAAU,QAAQ,MAAMlB,EAAOC,CAAG,EAC7D,OAAO,IAAIc,EAAY,IAAI,MAAME,CAAG,EAAGd,EAAM,CAC3C,WAAY,KAAK,UAAU,WAC3B,QAASe,CACjB,CAAO,CACH,CACA,MAAMhB,EAAS,KAAK,MAAM,MAAMF,EAAOC,CAAG,EAC1C,OAAO,IAAIc,EAAYb,EAAQC,CAAI,CACrC,CACA,OAAQ,CACN,OAAI,KAAK,UACH,KAAK,UACA,IAAIY,EAAY,IAAI,MAAM,KAAK,OAAO,EAAG,OAAQ,CACtD,WAAY,CAAC,GAAG,KAAK,UAAU,UAAU,EACzC,QAAS,IAAI,YAAY,KAAK,UAAU,OAAO,CACzD,CAAS,EAEI,IAAIA,EAAY,CAAC,GAAG,KAAK,KAAK,CAAC,EAEpC,KAAK,UACA,IAAIA,EAAY,IAAI,MAAM,KAAK,OAAO,EAAG,KAAK,UAAU,QAAS,CACtE,WAAY,CAAC,GAAG,KAAK,UAAU,UAAU,EACzC,QAAS,IAAI,YAAY,KAAK,UAAU,OAAO,CACvD,CAAO,EAEI,IAAIA,EAAY,CAAC,GAAG,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAChE,CACA,OAAOZ,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAMa,EAAMb,EAAQ,OACdD,EAAO,KAAK,UAAY,OAAS,IAAIpB,EAASkC,CAAG,EACvD,GAAI,KAAK,UAAW,CAClB,MAAME,EAAa,IAAI,YAAYF,CAAG,EACtC,QAAS,EAAI,EAAG,EAAIA,EAAK,IAAK,CAC5B,MAAMZ,EAAMD,EAAQ,CAAC,EACrBe,EAAW,CAAC,EAAI,KAAK,UAAU,QAAQd,CAAG,EACtCF,GACFA,EAAK,UAAU,EAAG,KAAK,UAAU,UAAUE,CAAG,CAAC,CAEnD,CACA,OAAO,IAAIU,EAAY,IAAI,MAAME,CAAG,EAAGd,EAAM,CAC3C,WAAY,KAAK,UAAU,WAC3B,QAASgB,CACjB,CAAO,CACH,CACA,MAAMpB,EAAO,IAAI,MAAMkB,CAAG,EAC1B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACpBF,GACFA,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CAEnD,CACA,OAAO,IAAIU,EAAYhB,EAAMI,CAAI,CACnC,CACA,sBAAuB,CACrB,IAAIiB,EAAQ,KAAK,UAAU,WAC3B,GAAI,KAAK,UAAW,CAClB,UAAWC,KAAK,KAAK,UAAU,WAC7BD,GAASC,EAAE,OAAS,EAEtBD,GAAS,KAAK,UAAU,QAAQ,UAClC,KACE,SAAS5B,EAAI,EAAGA,EAAI,KAAK,QAASA,IAC5B,KAAK,UAAU,IAAIA,CAAC,IACtB4B,GAAS,KAAK,MAAM5B,CAAC,EAAE,OAAS,GAItC,OAAO4B,CACT,CAMA,OAAO,KAAKX,EAAQ,CAClB,MAAMQ,EAAMR,EAAO,OACnB,GAAIQ,IAAQ,EACV,OAAO,IAAIF,EAAY,EAAE,EAE3B,MAAMO,EAA0B,IAAI,IAC9BC,EAAa,CAAA,EACbnB,EAAU,IAAI,YAAYa,CAAG,EAC7Bd,EAAO,IAAIpB,EAASkC,CAAG,EAC7B,IAAIP,EAAU,GACVc,EAAW,EACf,QAAShC,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIF,EAAOjB,CAAC,EAClB,GAAImB,GAAM,KAAsB,CAC9BR,EAAK,IAAIX,EAAG,EAAI,EAChB,IAAIa,EAAMiB,EAAQ,IAAIX,CAAC,EACnBN,IAAQ,SACVA,EAAMmB,IACNF,EAAQ,IAAIX,EAAGN,CAAG,EAClBkB,EAAW,KAAKZ,CAAC,GAEnBP,EAAQZ,CAAC,EAAIa,CACf,MACEK,EAAU,EAEd,CACA,GAAIc,EAAW,GAAKA,EAAWP,EAAM,GACnC,OAAOP,EAAU,IAAIK,EAAY,IAAI,MAAME,CAAG,EAAGd,EAAM,CAAE,WAAAoB,EAAY,QAAAnB,CAAO,CAAE,EAAI,IAAIW,EAAY,IAAI,MAAME,CAAG,EAAG,OAAQ,CAAE,WAAAM,EAAY,QAAAnB,EAAS,EAEnJ,MAAML,EAAO,IAAI,MAAMkB,CAAG,EAC1B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBO,EAAKP,CAAC,EAAIiB,EAAOjB,CAAC,GAAK,GAEzB,OAAOkB,EAAU,IAAIK,EAAYhB,EAAMI,CAAI,EAAI,IAAIY,EAAYhB,CAAI,CACrE,CAKA,OAAO,gBAAgBwB,EAAYnB,EAASR,EAAU,CACpD,MAAMqB,EAAMb,EAAQ,OACpB,OAAO,IAAIW,EAAY,IAAI,MAAME,CAAG,EAAGrB,EAAU,CAAE,WAAA2B,EAAY,QAAAnB,EAAS,CAC1E,CACA,aAAahB,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAMa,EAAMb,EAAQ,OACdD,EAAO,IAAIpB,EAASkC,CAAG,EAC7B,GAAI,KAAK,UAAW,CAClB,MAAME,EAAa,IAAI,YAAYF,CAAG,EACtC,QAAS,EAAI,EAAG,EAAIA,EAAK,IAAK,CAC5B,MAAMZ,EAAMD,EAAQ,CAAC,EACrBe,EAAW,CAAC,EAAI,KAAK,UAAU,QAAQd,CAAG,EAC1CF,EAAK,UAAU,EAAG,KAAK,UAAU,UAAUE,CAAG,CAAC,CACjD,CACA,OAAO,IAAIU,EAAY,IAAI,MAAME,CAAG,EAAGd,EAAM,CAC3C,WAAY,KAAK,UAAU,WAC3B,QAASgB,CACjB,CAAO,CACH,CACA,MAAMpB,EAAO,IAAI,MAAMkB,CAAG,EAC1B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIU,EAAYhB,EAAMI,CAAI,CACnC,CACF,EAGIsB,EAAgB,MAAMC,WAAuB/B,EAAO,CACtD,MAAQ,OACR,MACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,CACf,CACA,IAAIX,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EAClB,KAAK,UAAU,UAAUA,CAAK,EAG5B,KAAK,MAAMA,CAAK,IAAM,EAFpB,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,SAASF,EAAOC,CAAG,EACvCE,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIkC,GAAexB,EAAQC,CAAI,CACxC,CACA,OAAQ,CACN,OAAO,IAAIuB,GAAe,IAAI,WAAW,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAC9E,CACA,OAAOvB,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,WAAWK,EAAQ,MAAM,EACpCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIqB,GAAe3B,EAAMI,CAAI,CACtC,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,KAAK,UAAU,UACvC,CACA,OAAO,KAAKM,EAAQ,CAClB,MAAMV,EAAO,IAAI,WAAWU,EAAO,MAAM,EACnCN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,OACRZ,EAAKP,CAAC,EAAImB,EAAI,EAAI,EAClBR,EAAK,UAAUX,EAAG,EAAI,EAE1B,CACA,OAAO,IAAIkC,GAAe3B,EAAMI,CAAI,CACtC,CACA,aAAaf,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,WAAWK,EAAQ,MAAM,EACpCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIqB,GAAe3B,EAAMI,CAAI,CACtC,CACF,EAGIwB,EAAa,MAAMC,WAAoBjC,EAAO,CAChD,MAAQ,OACR,MACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,CACf,CACA,IAAIX,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EAClB,KAAK,UAAU,UAAUA,CAAK,EAG5B,IAAI,KAAK,KAAK,MAAMA,CAAK,CAAC,EAFxB,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,SAASF,EAAOC,CAAG,EACvCE,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIoC,GAAY1B,EAAQC,CAAI,CACrC,CACA,OAAQ,CACN,OAAO,IAAIyB,GAAY,IAAI,aAAa,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAC7E,CACA,OAAOzB,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,aAAaK,EAAQ,MAAM,EACtCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIuB,GAAY7B,EAAMI,CAAI,CACnC,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,EAAI,KAAK,UAAU,UAC3C,CACA,OAAO,KAAKM,EAAQ,CAClB,MAAMV,EAAO,IAAI,aAAaU,EAAO,MAAM,EACrCN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,OACRZ,EAAKP,CAAC,EAAImB,EAAE,QAAO,EACnBR,EAAK,UAAUX,EAAG,EAAI,EAE1B,CACA,OAAO,IAAIoC,GAAY7B,EAAMI,CAAI,CACnC,CACA,aAAaf,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,aAAaK,EAAQ,MAAM,EACtCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIuB,GAAY7B,EAAMI,CAAI,CACnC,CACF,EAGI0B,GAAe,MAAMC,WAAsBnC,EAAO,CACpD,MAAQ,SACR,MACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,CACf,CACA,IAAIX,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EAClB,KAAK,UAAU,UAAUA,CAAK,EAG5B,KAAK,MAAMA,CAAK,EAFd,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,MAAMF,EAAOC,CAAG,EACpCE,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIsC,GAAc5B,EAAQC,CAAI,CACvC,CACA,OAAQ,CACN,OAAO,IAAI2B,GAAc,CAAC,GAAG,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAClE,CACA,OAAO3B,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,MAAMK,EAAQ,MAAM,EAC/BD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIyB,GAAc/B,EAAMI,CAAI,CACrC,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,EAAI,KAAK,UAAU,UAC3C,CACA,OAAO,KAAKM,EAAQ,CAClB,MAAMV,EAAO,IAAI,MAAMU,EAAO,MAAM,EAC9BN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,MACRZ,EAAKP,CAAC,EAAImB,EACVR,EAAK,UAAUX,EAAG,EAAI,GAEtBO,EAAKP,CAAC,EAAI,IAEd,CACA,OAAO,IAAIsC,GAAc/B,EAAMI,CAAI,CACrC,CACA,aAAaf,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,MAAMK,EAAQ,MAAM,EAC/BD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIyB,GAAc/B,EAAMI,CAAI,CACrC,CACF,EAGI4B,GAAiB,KAAM,CACzB,QACA,YAAYC,EAAQ,CAClB,GAAIA,EAAO,QAAU,OACnB,MAAM,IAAIrD,GACR,wDAAwDqD,EAAO,KAAK,GAC5E,EAEI,KAAK,QAAUA,CACjB,CACA,aAAc,CACZ,OAAO,KAAK,WAAYX,GAAMA,EAAE,YAAW,CAAE,CAC/C,CACA,aAAc,CACZ,OAAO,KAAK,WAAYA,GAAMA,EAAE,YAAW,CAAE,CAC/C,CACA,MAAO,CACL,OAAO,KAAK,WAAYA,GAAMA,EAAE,KAAI,CAAE,CACxC,CACA,WAAWY,EAAQ,CACjB,OAAO,KAAK,YAAaZ,GAAMA,EAAE,WAAWY,CAAM,CAAC,CACrD,CACA,SAASC,EAAQ,CACf,OAAO,KAAK,YAAab,GAAMA,EAAE,SAASa,CAAM,CAAC,CACnD,CACA,SAASC,EAAS,CAChB,OAAO,KAAK,YAAad,GAAMA,EAAE,SAASc,CAAO,CAAC,CACpD,CACA,QAAQA,EAASC,EAAa,CAC5B,OAAO,KAAK,WAAYf,GAAMA,EAAE,WAAWc,EAASC,CAAW,CAAC,CAClE,CACA,MAAMC,EAAW,CACf,MAAMtC,EAAO,CAAA,EACPI,EAAO,IAAIpB,EAAS,KAAK,QAAQ,MAAM,EAC7C,QAASS,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVT,EAAK,KAAK,EAAE,GAEZA,EAAK,KAAKS,EAAI,MAAM6B,CAAS,CAAC,EAC9BlC,EAAK,IAAIX,EAAG,EAAI,EAEpB,CACA,MAAM8C,EAAO,IAAIC,GAAWxC,EAAMI,CAAI,EACtC,OAAO,IAAIqC,EAAO,KAAK,QAAQ,KAAMF,CAAI,CAC3C,CACA,MAAMtC,EAAOC,EAAK,CAChB,OAAO,KAAK,WAAYoB,GAAMA,EAAE,MAAMrB,EAAOC,CAAG,CAAC,CACnD,CACA,QAAS,CACP,MAAMwC,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKjC,EAAI,MAAM,CAE3B,CACA,OAAO,IAAIgC,EAAO,KAAK,QAAQ,KAAM3C,EAAc,KAAK4C,CAAO,CAAC,CAClE,CACA,SAASxD,EAAQyD,EAAU,CACzB,OAAO,KAAK,WAAYrB,GAAMA,EAAE,SAASpC,EAAQyD,CAAQ,CAAC,CAC5D,CACA,OAAOzD,EAAQyD,EAAU,CACvB,OAAO,KAAK,WAAYrB,GAAMA,EAAE,OAAOpC,EAAQyD,CAAQ,CAAC,CAC1D,CACA,QAAQP,EAAS,CACf,MAAMQ,EAASR,EAAQ,OACvB,GAAI,CAACQ,EAAO,SAAS,GAAG,GAAKA,EAAO,QAAQ,QAAS,EAAE,EAAE,QAAQ,GAAG,IAAM,GACxE,MAAM,IAAIhE,GACR,2DACR,EAEI,MAAM8D,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC9B,GAAIgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,MACZ,CACL,MAAMG,EAAQpC,EAAI,MAAM2B,CAAO,EAC3BS,GAASA,EAAM,CAAC,IAAM,OACxBH,EAAQ,KAAKG,EAAM,CAAC,CAAC,EAErBH,EAAQ,KAAK,IAAI,CAErB,CACF,CACA,OAAO,IAAID,EAAO,KAAK,QAAQ,KAAM1B,EAAW,KAAK2B,CAAO,CAAC,CAC/D,CACA,WAAWI,EAAI,CACb,MAAMJ,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKI,EAAGrC,CAAG,CAAC,CAExB,CACA,OAAO,IAAIgC,EAAO,KAAK,QAAQ,KAAM1B,EAAW,KAAK2B,CAAO,CAAC,CAC/D,CACA,YAAYI,EAAI,CACd,MAAMJ,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKI,EAAGrC,CAAG,CAAC,CAExB,CACA,OAAO,IAAIgC,EAAO,KAAK,QAAQ,KAAMf,EAAc,KAAKgB,CAAO,CAAC,CAClE,CACF,EACIF,GAAa,MAAMO,WAAoBnD,EAAO,CAChD,MAAQ,OACR,MACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,CACf,CACA,IAAIX,EAAO,CACT,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAI,MAAM,SAASA,CAAK,uCAAuC,KAAK,OAAO,EAAE,EAErF,OAAK,KAAK,UAAU,IAAIA,CAAK,EACtB,KAAK,MAAMA,CAAK,EADgB,IAEzC,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,MAAMF,EAAOC,CAAG,EACpCE,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,IAAIX,EAAG,KAAK,UAAU,IAAIQ,EAAQR,CAAC,CAAC,EAE3C,OAAO,IAAIsD,GAAY5C,EAAQC,CAAI,CACrC,CACA,OAAQ,CACN,OAAO,IAAI2C,GACT,KAAK,MAAM,IAAKC,GAAQ,CAAC,GAAGA,CAAG,CAAC,EAChC,KAAK,UAAU,MAAK,CAC1B,CACE,CACA,OAAO5C,EAAM,CACX,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAAMY,EAAQ,KAAKZ,CAAC,EAE1C,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAM4C,EAAW,CAAA,EACjB,QAASxD,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAClCwD,EAAS,KAAK5C,EAAQZ,CAAC,CAAC,EAE1B,OAAO,KAAK,eAAewD,CAAQ,CACrC,CACA,sBAAuB,CACrB,IAAI5B,EAAQ,KAAK,UAAU,WAC3B,QAAS5B,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,IAAIA,CAAC,EACtB,UAAW6B,KAAK,KAAK,MAAM7B,CAAC,EAC1B4B,GAASC,EAAE,OAAS,EAI1B,OAAOD,CACT,CACA,eAAehB,EAAS,CACtB,MAAML,EAAO,CAAA,EACPI,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAK,KAAK,KAAK,MAAMM,CAAG,CAAC,EACzBF,EAAK,IAAIX,EAAG,KAAK,UAAU,IAAIa,CAAG,CAAC,CACrC,CACA,OAAO,IAAIyC,GAAY/C,EAAMI,CAAI,CACnC,CACF,EAGI8C,GAAe,KAAM,CACvB,QACA,YAAYjB,EAAQ,CAClB,GAAIA,EAAO,QAAU,OACnB,MAAM,IAAIrD,GACR,sDAAsDqD,EAAO,KAAK,GAC1E,EAEI,KAAK,QAAUA,CACjB,CACA,MAAO,CACL,OAAO,KAAK,WAAYkB,GAAMA,EAAE,YAAW,CAAE,CAC/C,CACA,OAAQ,CACN,OAAO,KAAK,WAAYA,GAAMA,EAAE,SAAQ,EAAK,CAAC,CAChD,CACA,KAAM,CACJ,OAAO,KAAK,WAAYA,GAAMA,EAAE,QAAO,CAAE,CAC3C,CACA,MAAO,CACL,OAAO,KAAK,WAAYA,GAAMA,EAAE,SAAQ,CAAE,CAC5C,CACA,QAAS,CACP,OAAO,KAAK,WAAYA,GAAMA,EAAE,WAAU,CAAE,CAC9C,CACA,QAAS,CACP,OAAO,KAAK,WAAYA,GAAMA,EAAE,WAAU,CAAE,CAC9C,CACA,WAAY,CACV,OAAO,KAAK,WAAYA,GAAMA,EAAE,OAAM,CAAE,CAC1C,CACA,WAAY,CACV,OAAO,KAAK,WAAYA,GAAM,CAC5B,MAAMlD,EAAQ,IAAI,KAAKkD,EAAE,YAAW,EAAI,EAAG,CAAC,EACtCC,EAAOD,EAAE,QAAO,EAAKlD,EAAM,QAAO,EAClCoD,EAAS,IAAM,GAAK,GAAK,GAC/B,OAAO,KAAK,MAAMD,EAAOC,CAAM,CACjC,CAAC,CACH,CACA,YAAa,CACX,OAAO,KAAK,WAAYF,GAAM,CAC5B,MAAMG,EAAS,IAAI,KAAKH,EAAE,QAAO,CAAE,EACnCG,EAAO,SAAS,EAAG,EAAG,EAAG,CAAC,EAC1BA,EAAO,QAAQA,EAAO,UAAY,GAAKA,EAAO,OAAM,EAAK,GAAK,CAAC,EAC/D,MAAMC,EAAO,IAAI,KAAKD,EAAO,YAAW,EAAI,EAAG,CAAC,EAC1CE,GAAWF,EAAO,UAAYC,EAAK,QAAO,IAAO,IAAM,GAAK,GAAK,IACvE,MAAO,GAAI,KAAK,OAAOC,EAAU,GAAKD,EAAK,OAAM,EAAK,GAAK,GAAK,CAAC,CACnE,CAAC,CACH,CACA,SAAU,CACR,OAAO,KAAK,WAAYJ,GAAM,KAAK,MAAMA,EAAE,SAAQ,EAAK,CAAC,EAAI,CAAC,CAChE,CACA,WAAY,CACV,OAAO,KAAK,WAAYA,GAAMA,EAAE,QAAO,CAAE,CAC3C,CACA,OAAOf,EAAS,CACd,MAAMM,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKe,GAAWhD,EAAK2B,CAAO,CAAC,CAEzC,CACA,OAAO,IAAIK,EAAO,KAAK,QAAQ,KAAM1B,EAAW,KAAK2B,CAAO,CAAC,CAC/D,CACA,KAAKhD,EAAOgE,EAAM,CAChB,GAAIhE,EAAM,QAAU,OAClB,MAAM,IAAId,GACR,uCAAuCc,EAAM,KAAK,GAC1D,EAEI,GAAIA,EAAM,SAAW,KAAK,QAAQ,OAChC,MAAM,IAAId,GACR,+CAA+C,KAAK,QAAQ,MAAM,QAAQc,EAAM,MAAM,EAC9F,EAEI,MAAMgD,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMkE,EAAI,KAAK,QAAQ,IAAIlE,CAAC,EACtBmE,EAAIlE,EAAM,IAAID,CAAC,EACjBkE,IAAM,MAAQC,IAAM,KACtBlB,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKmB,GAASF,EAAGC,EAAGF,CAAI,CAAC,CAErC,CACA,OAAO,IAAIjB,EAAO,KAAK,QAAQ,KAAM3C,EAAc,KAAK4C,CAAO,CAAC,CAClE,CACA,SAASgB,EAAM,CACb,MAAMhB,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKoB,GAAarD,EAAKiD,CAAI,CAAC,CAExC,CACA,OAAO,IAAIjB,EAAO,KAAK,QAAQ,KAAMb,EAAW,KAAKc,CAAO,CAAC,CAC/D,CACA,WAAWI,EAAI,CACb,MAAMJ,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKI,EAAGrC,CAAG,CAAC,CAExB,CACA,OAAO,IAAIgC,EAAO,KAAK,QAAQ,KAAM3C,EAAc,KAAK4C,CAAO,CAAC,CAClE,CACF,EACA,SAASe,GAAWM,EAAM3B,EAAS,CACjC,MAAM4B,EAAQC,GAAM,OAAOA,CAAC,EAAE,SAAS,EAAG,GAAG,EACvCC,EAAQD,GAAM,OAAOA,CAAC,EAAE,SAAS,EAAG,GAAG,EAC7C,OAAO7B,EAAQ,QAAQ,OAAQ8B,EAAKH,EAAK,YAAW,CAAE,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,SAAQ,EAAK,CAAC,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,QAAO,CAAE,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,SAAQ,CAAE,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,YAAY,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,WAAU,CAAE,CAAC,CACzP,CACA,SAASF,GAASF,EAAGC,EAAGF,EAAM,CAC5B,MAAMS,EAAMR,EAAE,QAAO,EAEfS,EADMR,EAAE,QAAO,EACAO,EACrB,OAAQT,EAAI,CACV,IAAK,SACH,OAAOU,EAAS,IAClB,IAAK,SACH,OAAOA,GAAU,IAAM,IACzB,IAAK,OACH,OAAOA,GAAU,IAAM,GAAK,IAC9B,IAAK,MACH,OAAOA,GAAU,IAAM,GAAK,GAAK,IACnC,IAAK,QAAS,CACZ,MAAMC,EAAWT,EAAE,YAAW,EAAKD,EAAE,YAAW,EAC1CW,EAAYV,EAAE,SAAQ,EAAKD,EAAE,SAAQ,EACrCY,GAAWX,EAAE,QAAO,EAAKD,EAAE,QAAO,GAAM,GAC9C,OAAOU,EAAW,GAAKC,EAAYC,CACrC,CACA,IAAK,OAAQ,CACX,MAAMF,EAAWT,EAAE,YAAW,EAAKD,EAAE,YAAW,EAC1Ca,GAAaZ,EAAE,SAAQ,EAAKD,EAAE,SAAQ,GAAM,GAC5CY,GAAWX,EAAE,QAAO,EAAKD,EAAE,QAAO,GAAM,IAC9C,OAAOU,EAAWG,EAAYD,CAChC,CACJ,CACA,CACA,SAAST,GAAaC,EAAML,EAAM,CAChC,OAAQA,EAAI,CACV,IAAK,OACH,OAAO,IAAI,KAAKK,EAAK,YAAW,EAAI,EAAG,CAAC,EAC1C,IAAK,QACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAI,CAAC,EACxD,IAAK,MACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,SAAS,EACrE,IAAK,OACH,OAAO,IAAI,KACTA,EAAK,YAAW,EAChBA,EAAK,SAAQ,EACbA,EAAK,QAAO,EACZA,EAAK,SAAQ,CACrB,EACI,IAAK,SACH,OAAO,IAAI,KACTA,EAAK,YAAW,EAChBA,EAAK,SAAQ,EACbA,EAAK,QAAO,EACZA,EAAK,SAAQ,EACbA,EAAK,WAAU,CACvB,EACI,IAAK,SACH,OAAO,IAAI,KACTA,EAAK,YAAW,EAChBA,EAAK,SAAQ,EACbA,EAAK,QAAO,EACZA,EAAK,SAAQ,EACbA,EAAK,WAAU,EACfA,EAAK,WAAU,CACvB,CACA,CACA,CAGA,IAAIU,GACJ,SAASC,GAA0BC,EAAS,CAC1CF,GAAmBE,CACrB,CACG,IAAClC,EAAS,MAAMmC,CAAQ,CACzB,MACA,QACA,YAAYC,EAAMnG,EAAQ,CACxB,KAAK,MAAQmG,EACb,KAAK,QAAUnG,CACjB,CACA,IAAI,MAAO,CACT,OAAO,KAAK,KACd,CACA,IAAI,OAAQ,CACV,OAAO,KAAK,QAAQ,KACtB,CACA,IAAI,QAAS,CACX,OAAO,KAAK,QAAQ,MACtB,CACA,IAAI,WAAY,CACd,OAAO,KAAK,QAAQ,SACtB,CACA,IAAI,QAAS,CACX,OAAO,KAAK,OACd,CACA,IAAI,KAAM,CACR,OAAO,IAAIsD,GAAe,IAAI,CAChC,CACA,IAAI,IAAK,CACP,OAAO,IAAIkB,GAAa,IAAI,CAC9B,CACA,IAAI7D,EAAO,CACT,OAAO,KAAK,QAAQ,IAAIA,CAAK,CAC/B,CACA,SAAU,CACR,MAAMM,EAAS,CAAA,EACf,QAASF,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCE,EAAO,KAAK,KAAK,QAAQ,IAAIF,CAAC,CAAC,EAEjC,OAAOE,CACT,CAEA,KAAM,CAEJ,OADa,KAAK,iBAAgB,EACtB,IAAG,CACjB,CACA,MAAO,CAEL,OADa,KAAK,iBAAgB,EACtB,KAAI,CAClB,CACA,KAAM,CAEJ,OADa,KAAK,iBAAgB,EACtB,IAAG,CACjB,CACA,KAAM,CAEJ,OADa,KAAK,iBAAgB,EACtB,IAAG,CACjB,CACA,KAAM,CACJ,MAAM4C,EAAO,KAAK,iBAAgB,EAC5BuC,EAAIvC,EAAK,KAAI,EACnB,GAAIuC,IAAM,KAAM,OAAO,KACvB,MAAMtE,EAAa+B,EAAK,OAASA,EAAK,UACtC,GAAI/B,EAAa,EAAG,OAAO,KAC3B,IAAIuE,EAAY,EAChB,QAAStF,EAAI,EAAGA,EAAI8C,EAAK,OAAQ9C,IAAK,CACpC,MAAMgB,EAAM8B,EAAK,IAAI9C,CAAC,EACtB,GAAIgB,IAAQ,KAAM,CAChB,MAAM2C,EAAO3C,EAAMqE,EACnBC,GAAa3B,EAAOA,CACtB,CACF,CACA,OAAO,KAAK,KAAK2B,GAAavE,EAAa,EAAE,CAC/C,CACA,QAAS,CACP,MAAM+B,EAAO,KAAK,iBAAgB,EAC5B7B,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAI8C,EAAK,OAAQ9C,IAAK,CACpC,MAAMgB,EAAM8B,EAAK,IAAI9C,CAAC,EAClBgB,IAAQ,MACVC,EAAO,KAAKD,CAAG,CAEnB,CACA,GAAIC,EAAO,SAAW,EAAG,OAAO,KAChCA,EAAO,KAAK,CAACiD,EAAGC,IAAMD,EAAIC,CAAC,EAC3B,MAAMoB,EAAM,KAAK,MAAMtE,EAAO,OAAS,CAAC,EACxC,OAAIA,EAAO,OAAS,IAAM,GAChBA,EAAOsE,EAAM,CAAC,EAAItE,EAAOsE,CAAG,GAAK,EAEpCtE,EAAOsE,CAAG,CACnB,CACA,QAAQC,EAAKC,EAAM,CACjB,MAAM3C,EAAO,KAAK,iBAAgB,EAC5BG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI8C,EAAK,OAAQ9C,IAAK,CACpC,MAAMgB,EAAM8B,EAAK,IAAI9C,CAAC,EAClBgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKjC,GAAOwE,GAAOxE,GAAOyE,CAAI,CAE1C,CACA,OAAO,IAAIN,EAAQ,KAAK,MAAOlD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,QAAS,CACP,MAAMH,EAAO,KAAK,iBAAgB,EAC5BG,EAAU,CAAA,EAChB,IAAIyC,EAAU,EACd,QAAS1F,EAAI,EAAGA,EAAI8C,EAAK,OAAQ9C,IAAK,CACpC,MAAMgB,EAAM8B,EAAK,IAAI9C,CAAC,EAClBgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,GAEjByC,GAAW1E,EACXiC,EAAQ,KAAKyC,CAAO,EAExB,CACA,OAAO,IAAIP,EAAQ,KAAK,MAAO9E,EAAc,KAAK4C,CAAO,CAAC,CAC5D,CACA,KAAM,CACJ,MAAMH,EAAO,KAAK,iBAAgB,EAC5BG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI8C,EAAK,OAAQ9C,IAAK,CACpC,MAAMgB,EAAM8B,EAAK,IAAI9C,CAAC,EAClBgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAK,KAAK,IAAIjC,CAAG,CAAC,CAE9B,CACA,OAAO,IAAImE,EAAQ,KAAK,MAAO9E,EAAc,KAAK4C,CAAO,CAAC,CAC5D,CACA,MAAM0C,EAAW,EAAG,CAClB,MAAM7C,EAAO,KAAK,iBAAgB,EAC5B8C,EAAS,KAAK,IAAI,GAAID,CAAQ,EAC9B1C,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI8C,EAAK,OAAQ9C,IAAK,CACpC,MAAMgB,EAAM8B,EAAK,IAAI9C,CAAC,EAClBgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAK,KAAK,MAAMjC,EAAM4E,CAAM,EAAIA,CAAM,CAElD,CACA,OAAO,IAAIT,EAAQ,KAAK,MAAO9E,EAAc,KAAK4C,CAAO,CAAC,CAC5D,CAEA,GAAGlD,EAAO,CACR,OAAO,KAAK,eAAeA,EAAO,CAACmE,EAAGC,IAAMD,IAAMC,CAAC,CACrD,CACA,IAAIpE,EAAO,CACT,OAAO,KAAK,eAAeA,EAAO,CAACmE,EAAGC,IAAMD,IAAMC,CAAC,CACrD,CACA,GAAGpE,EAAO,CACR,OAAO,KAAK,eAAeA,EAAO,CAACmE,EAAGC,IAAMD,EAAIC,CAAC,CACnD,CACA,IAAIpE,EAAO,CACT,OAAO,KAAK,eAAeA,EAAO,CAACmE,EAAGC,IAAMD,GAAKC,CAAC,CACpD,CACA,GAAGpE,EAAO,CACR,OAAO,KAAK,eAAeA,EAAO,CAACmE,EAAGC,IAAMD,EAAIC,CAAC,CACnD,CACA,IAAIpE,EAAO,CACT,OAAO,KAAK,eAAeA,EAAO,CAACmE,EAAGC,IAAMD,GAAKC,CAAC,CACpD,CACA,KAAKlD,EAAQ,CACX,MAAM4E,EAAM,IAAI,IAAI5E,EAAO,IAAKE,GAAM,KAAK,cAAcA,CAAC,CAAC,CAAC,EACtD8B,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAK4C,EAAI,IAAI,KAAK,cAAc7E,CAAG,CAAC,CAAC,CAEjD,CACA,OAAO,IAAImE,EAAQ,KAAK,MAAOlD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,QAAS,CACP,MAAMA,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCiD,EAAQ,KAAK,KAAK,QAAQ,IAAIjD,CAAC,IAAM,IAAI,EAE3C,OAAO,IAAImF,EAAQ,KAAK,MAAOlD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,WAAY,CACV,MAAMA,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCiD,EAAQ,KAAK,KAAK,QAAQ,IAAIjD,CAAC,IAAM,IAAI,EAE3C,OAAO,IAAImF,EAAQ,KAAK,MAAOlD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,SAASlD,EAAO,CAEd,MAAM+F,EADS,KAAK,QAAO,EACL,IAAK3E,GAAMA,IAAM,KAAOpB,EAAQoB,CAAC,EACvD,OAAO,IAAIgE,EAAQ,KAAK,MAAO,KAAK,aAAaW,CAAM,CAAC,CAC1D,CACA,QAAS,CACP,MAAMC,EAAuB,IAAI,IAC3B9E,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EACxBgG,EAAMhF,IAAQ,KAAO,WAAa,OAAO,KAAK,cAAcA,CAAG,CAAC,EACjE+E,EAAK,IAAIC,CAAG,IACfD,EAAK,IAAIC,CAAG,EACZ/E,EAAO,KAAKD,CAAG,EAEnB,CACA,OAAO,IAAImE,EAAQ,KAAK,MAAO,KAAK,aAAalE,CAAM,CAAC,CAC1D,CACA,SAAU,CACR,MAAM8E,EAAuB,IAAI,IACjC,QAAS/F,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EACxBgG,EAAMhF,IAAQ,KAAO,WAAa,OAAO,KAAK,cAAcA,CAAG,CAAC,EACtE+E,EAAK,IAAIC,CAAG,CACd,CACA,OAAOD,EAAK,IACd,CACA,aAAc,CACZ,GAAI,CAACf,GACH,MAAM,IAAInG,EAAc,oBAA6C,kCAAkC,EAEzG,MAAMoH,EAAyB,IAAI,IAC7BC,EAAQ,CAAA,EACd,QAASlG,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EACxBgG,EAAMhF,IAAQ,KAAO,WAAa,OAAO,KAAK,cAAcA,CAAG,CAAC,EAChEmF,EAAQF,EAAO,IAAID,CAAG,EACxBG,EACFA,EAAM,SAENF,EAAO,IAAID,EAAK,CAAE,MAAOhF,EAAK,MAAO,EAAG,EACxCkF,EAAM,KAAKF,CAAG,EAElB,CACAE,EAAM,KAAK,CAAChC,EAAGC,IAAM8B,EAAO,IAAI9B,CAAC,EAAE,MAAQ8B,EAAO,IAAI/B,CAAC,EAAE,KAAK,EAC9D,MAAMjD,EAAS,CAAA,EACTmF,EAAc,CAAA,EACpB,UAAWJ,KAAOE,EAAO,CACvB,MAAMC,EAAQF,EAAO,IAAID,CAAG,EAC5B/E,EAAO,KAAKkF,EAAM,KAAK,EACvBC,EAAY,KAAKD,EAAM,KAAK,CAC9B,CACA,MAAME,EAAW,KAAK,aAAapF,CAAM,EACnCqF,EAAWjG,EAAc,KAAK+F,CAAW,EACzCG,EAA0B,IAAI,IACpC,OAAAA,EAAQ,IAAI,QAASF,CAAQ,EAC7BE,EAAQ,IAAI,QAASD,CAAQ,EACtBtB,GAAiBuB,EAAS,CAAC,QAAS,OAAO,CAAC,CACrD,CACA,KAAKC,EAAO,CAEV,MAAMC,EADS,KAAK,QAAO,EACF,IAAKtF,GACxBA,IAAM,KAAa,KAChB,KAAK,WAAWA,EAAGqF,CAAK,CAChC,EACK1D,EAAO4D,GAAqBF,EAAOC,CAAS,EAClD,OAAO,IAAItB,EAAQ,KAAK,MAAOrC,CAAI,CACrC,CACA,MAAMO,EAAI,CACR,MAAMJ,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCiD,EAAQ,KAAKI,EAAG,KAAK,QAAQ,IAAIrD,CAAC,CAAC,CAAC,EAEtC,IAAI2G,EAAc,MAClB,UAAWC,KAAK3D,EACd,GAAI2D,IAAM,KAAM,CACV,OAAOA,GAAM,SAAUD,EAAc,OAChC,OAAOC,GAAM,UAAWD,EAAc,OACtCC,aAAa,KAAMD,EAAc,OACrCA,EAAc,MACnB,KACF,CAEF,MAAM7D,EAAO4D,GAAqBC,EAAa1D,CAAO,EACtD,OAAO,IAAIkC,EAAQ,KAAK,MAAOrC,CAAI,CACrC,CACA,kBAAmB,CACjB,GAAI,KAAK,mBAAmBzC,EAAe,OAAO,KAAK,QACvD,GAAI,KAAK,mBAAmBe,GAAa,OAAO,KAAK,QACrD,MAAM,IAAIjC,GACR,0DAA0D,KAAK,KAAK,GAC1E,CACE,CACA,eAAeY,EAAO8G,EAAW,CAC/B,MAAM5D,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAK4D,EAAU7F,EAAKjB,CAAK,CAAC,CAEtC,CACA,OAAO,IAAIoF,EAAQ,KAAK,MAAOlD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,cAAclD,EAAO,CACnB,OAAIA,aAAiB,KAAaA,EAAM,QAAO,EACxCA,CACT,CACA,aAAakB,EAAQ,CACnB,OAAQ,KAAK,QAAQ,MAAK,CACxB,IAAK,MACH,OAAOZ,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,IAAK,SACH,OAAOoB,GAAa,KAAKpB,CAAM,EACjC,QACE,MAAM,IAAIpC,EACR,oBACA,sBAAsB,KAAK,QAAQ,KAAK,EAClD,CACA,CACE,CACA,WAAWkB,EAAO+G,EAAa,CAC7B,OAAQA,EAAW,CACjB,IAAK,MACL,IAAK,MACH,OAAI,OAAO/G,GAAU,SAAiBA,EAClC,OAAOA,GAAU,SAAiB,OAAOA,CAAK,EAC9C,OAAOA,GAAU,UAAkBA,EAAQ,EAAI,EAC/CA,aAAiB,KAAaA,EAAM,QAAO,EACxC,OAAOA,CAAK,EACrB,IAAK,OACH,OAAIA,aAAiB,KAAaA,EAAM,YAAW,EAC5C,OAAOA,CAAK,EACrB,IAAK,OACH,MAAO,EAAQA,EACjB,IAAK,OACH,OAAIA,aAAiB,KAAaA,EAC9B,OAAOA,GAAU,SAAiB,IAAI,KAAKA,CAAK,EAChD,OAAOA,GAAU,SAAiB,IAAI,KAAKA,CAAK,EAC7C,IAAI,KAAK,OAAOA,CAAK,CAAC,EAC/B,QACE,MAAM,IAAIZ,GACR,yBAAyB2H,CAAW,GAC9C,CACA,CACE,CACF,EACA,SAASJ,GAAqBF,EAAOvF,EAAQ,CAC3C,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,IAAK,SACH,OAAOoB,GAAa,KAAKpB,CAAM,EACjC,QACE,MAAM,IAAIpC,EACR,oBACA,8CAA8C2H,CAAK,EAC3D,CACA,CACA,CAGG,IAACO,EAAO,MAAMC,EAAM,CACrB,GAAG5B,EAAM,CACP,OAAO,IAAI6B,GAAU,KAAM7B,CAAI,CACjC,CAEA,IAAInF,EAAO,CACT,OAAO,IAAIiH,GAAe,KAAMC,GAAQlH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIiH,GAAe,KAAMC,GAAQlH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIiH,GAAe,KAAMC,GAAQlH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIiH,GAAe,KAAMC,GAAQlH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIiH,GAAe,KAAMC,GAAQlH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIiH,GAAe,KAAMC,GAAQlH,CAAK,EAAG,KAAK,CACvD,CAEA,GAAGA,EAAO,CACR,OAAO,IAAImH,GAAe,KAAMC,GAAKpH,CAAK,EAAG,IAAI,CACnD,CACA,IAAIA,EAAO,CACT,OAAO,IAAImH,GAAe,KAAMC,GAAKpH,CAAK,EAAG,KAAK,CACpD,CACA,GAAGA,EAAO,CACR,OAAO,IAAImH,GAAe,KAAMC,GAAKpH,CAAK,EAAG,IAAI,CACnD,CACA,IAAIA,EAAO,CACT,OAAO,IAAImH,GAAe,KAAMC,GAAKpH,CAAK,EAAG,KAAK,CACpD,CACA,GAAGA,EAAO,CACR,OAAO,IAAImH,GAAe,KAAMC,GAAKpH,CAAK,EAAG,IAAI,CACnD,CACA,IAAIA,EAAO,CACT,OAAO,IAAImH,GAAe,KAAMC,GAAKpH,CAAK,EAAG,KAAK,CACpD,CAEA,IAAIA,EAAO,CACT,OAAO,IAAIqH,GAAY,KAAMC,GAAStH,CAAK,EAAG,KAAK,CACrD,CACA,GAAGA,EAAO,CACR,OAAO,IAAIqH,GAAY,KAAMC,GAAStH,CAAK,EAAG,IAAI,CACpD,CACA,KAAM,CACJ,OAAO,IAAIuH,GAAQ,IAAI,CACzB,CAEA,gBAAiB,CACf,MAAMC,EAAO,KAAK,aAClB,GAAIA,EAAK,SAAW,EAClB,MAAM,IAAI,MAAM,yCAAyC,EAE3D,OAAOA,EAAK,CAAC,CACf,CACA,KAAM,CACJ,OAAO,IAAIC,GAAW,KAAK,gBAAgB,CAC7C,CACA,MAAO,CACL,OAAO,IAAIC,GAAY,KAAK,gBAAgB,CAC9C,CACA,OAAQ,CACN,OAAO,IAAIC,GAAa,KAAK,gBAAgB,CAC/C,CACA,eAAgB,CACd,OAAO,IAAIC,GAAqB,KAAK,gBAAgB,CACvD,CACA,KAAM,CACJ,OAAO,IAAIC,GAAW,KAAK,gBAAgB,CAC7C,CACA,KAAM,CACJ,OAAO,IAAIC,GAAW,KAAK,gBAAgB,CAC7C,CACA,KAAM,CACJ,OAAO,IAAIC,GAAW,KAAK,gBAAgB,CAC7C,CACA,OAAQ,CACN,OAAO,IAAIC,GAAa,KAAK,gBAAgB,CAC/C,CACA,MAAO,CACL,OAAO,IAAIC,GAAY,KAAK,gBAAgB,CAC9C,CACA,MAAO,CACL,OAAO,IAAIC,GAAY,KAAK,gBAAgB,CAC9C,CACA,MAAO,CACL,OAAO,IAAIC,GAAY,KAAK,gBAAgB,CAC9C,CAEA,YAAYC,EAAQ,CAClB,MAAMC,EAAQD,EAAO,IAAKE,GAAMA,aAAavB,GAAQuB,EAAI,IAAIC,GAAYD,CAAC,CAAC,EAC3E,OAAO,IAAIE,GAAa,CAAC,KAAM,GAAGH,CAAK,CAAC,CAC1C,CACA,SAASvI,EAAO,CACd,MAAM2I,EAAU3I,aAAiBiH,GAAQjH,EAAQ,IAAIyI,GAAYzI,CAAK,EACtE,OAAO,IAAI4I,GAAa,KAAMD,CAAO,CACvC,CACA,QAAS,CACP,OAAO,IAAIE,GAAW,IAAI,CAC5B,CACA,WAAY,CACV,OAAO,IAAIC,GAAc,IAAI,CAC/B,CACF,EACI5B,GAAY,KAAM,CACpB,KACA,KACA,YAAY6B,EAAM1D,EAAM,CACtB,KAAK,KAAO0D,EACZ,KAAK,KAAO1D,CACd,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,KAAK,YACnB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,KAAK,SAAQ,CAAE,OAAO,KAAK,IAAI,EAChD,CACF,EACA,SAASiC,GAAKtH,EAAO,CACnB,OAAIA,aAAiBgH,EAAahH,EAC3B,IAAIyI,GAAYzI,CAAK,CAC9B,CACA,SAASoH,GAAQpH,EAAO,CACtB,OAAIA,aAAiBgH,EAAahH,EAC3B,IAAIyI,GAAYzI,CAAK,CAC9B,CACA,SAASwH,GAASxH,EAAO,CACvB,OAAIA,aAAiBgH,EAAahH,EAC3B,IAAIyI,GAAYzI,CAAK,CAC9B,CACA,SAASgJ,GAAqBvC,EAAOvF,EAAQ,CAC3C,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAAS+H,GAAmBjJ,EAAO,CACjC,OAAI,OAAOA,GAAU,SAAiB,MAClC,OAAOA,GAAU,SAAiB,OAClC,OAAOA,GAAU,UAAkB,OACnCA,aAAiB,KAAa,OAC3B,KACT,CACA,IAAIyI,GAAc,cAAczB,CAAK,CACnC,OACA,YAAYhH,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,MAAO,CAAA,CACT,CACA,UAAW,CACT,OAAI,OAAO,KAAK,QAAW,SAAiB,IAAI,KAAK,MAAM,IACvD,KAAK,kBAAkB,KAAa,KAAK,OAAO,YAAW,EACxD,OAAO,KAAK,MAAM,CAC3B,CACA,SAASkJ,EAAK,CACZ,MAAMxH,EAAMwH,EAAI,OACVhI,EAAS,IAAI,MAAMQ,CAAG,EAAE,KAAK,KAAK,MAAM,EACxC+E,EAAQwC,GAAmB,KAAK,MAAM,EACtClG,EAAOiG,GAAqBvC,EAAOvF,CAAM,EAC/C,OAAO,IAAI+B,EAAO,UAAWF,CAAI,CACnC,CACF,EACIoG,GAAa,cAAcnC,CAAK,CAClC,MACA,YAAY3B,EAAM,CAChB,MAAK,EACL,KAAK,MAAQA,CACf,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,KAAK,KAAK,CACpB,CACA,UAAW,CACT,OAAO,KAAK,KACd,CACA,SAAS6D,EAAK,CACZ,OAAOA,EAAI,IAAI,KAAK,KAAK,CAC3B,CACF,EACIE,GAAmB,CACrB,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACP,EACIjC,GAAiB,cAAcH,CAAK,CACtC,MACA,OACA,IACA,YAAYqC,EAAMC,EAAOC,EAAI,CAC3B,MAAK,EACL,KAAK,MAAQF,EACb,KAAK,OAASC,EACd,KAAK,IAAMC,CACb,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,MAAM,aAAc,GAAG,KAAK,OAAO,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,IAAI,KAAK,MAAM,SAAQ,CAAE,IAAIH,GAAiB,KAAK,GAAG,CAAC,IAAI,KAAK,OAAO,SAAQ,CAAE,GAC1F,CACA,SAASF,EAAK,CACZ,MAAMM,EAAa,KAAK,MAAM,SAASN,CAAG,EACpCO,EAAc,KAAK,OAAO,SAASP,CAAG,EACtCxH,EAAM8H,EAAW,OACjBtG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMkE,EAAIqF,EAAW,IAAIvJ,CAAC,EACpBmE,EAAIqF,EAAY,IAAIxJ,CAAC,EACvBkE,IAAM,MAAQC,IAAM,KACtBlB,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKwG,GAAavF,EAAGC,EAAG,KAAK,GAAG,CAAC,CAE7C,CACA,OAAO,IAAInB,EAAO,GAAI3C,EAAc,KAAK4C,CAAO,CAAC,CACnD,CACF,EACA,SAASwG,GAAavF,EAAGC,EAAGmF,EAAI,CAC9B,OAAQA,EAAE,CACR,IAAK,MACH,OAAOpF,EAAIC,EACb,IAAK,MACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAO,KAAK,IAAID,EAAGC,CAAC,CAC1B,CACA,CACA,IAAIuF,GAAiB,CACnB,GAAI,KACJ,IAAK,KACL,GAAI,IACJ,IAAK,KACL,GAAI,IACJ,IAAK,IACP,EACItC,GAAiB,cAAcL,CAAK,CACtC,MACA,OACA,IACA,YAAYqC,EAAMC,EAAOC,EAAI,CAC3B,MAAK,EACL,KAAK,MAAQF,EACb,KAAK,OAASC,EACd,KAAK,IAAMC,CACb,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,MAAM,aAAc,GAAG,KAAK,OAAO,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,IAAI,KAAK,MAAM,SAAQ,CAAE,IAAII,GAAe,KAAK,GAAG,CAAC,IAAI,KAAK,OAAO,SAAQ,CAAE,GACxF,CACA,SAAST,EAAK,CACZ,GAAI,KAAK,iBAAiBC,IAAc,KAAK,kBAAkBV,GAAa,CAC1E,MAAMmB,EAAa,KAAK,MAAM,aAAa,CAAC,EACtCC,EAAU,KAAK,OAAO,OACtBzG,EAAS8F,EAAI,IAAIU,CAAU,EAAE,OAC7BE,EAAO1G,EAAO,OACd2G,EAAW,IAAI,MAAMD,CAAI,EAC/B,QAAS7J,EAAI,EAAGA,EAAI6J,EAAM7J,IAAK,CAC7B,MAAMkE,EAAIf,EAAO,IAAInD,CAAC,EAClBkE,IAAM,MAAQ0F,IAAY,KAC5BE,EAAS9J,CAAC,EAAI,KAEd8J,EAAS9J,CAAC,EAAI+J,GAAW7F,EAAG0F,EAAS,KAAK,GAAG,CAEjD,CACA,OAAO,IAAI5G,EAAO,GAAIf,EAAc,KAAK6H,CAAQ,CAAC,CACpD,CACA,GAAI,KAAK,iBAAiBtB,IAAe,KAAK,kBAAkBU,GAAY,CAC1E,MAAMU,EAAU,KAAK,MAAM,OACrBD,EAAa,KAAK,OAAO,aAAa,CAAC,EACvCxG,EAAS8F,EAAI,IAAIU,CAAU,EAAE,OAC7BE,EAAO1G,EAAO,OACd2G,EAAW,IAAI,MAAMD,CAAI,EAC/B,QAAS7J,EAAI,EAAGA,EAAI6J,EAAM7J,IAAK,CAC7B,MAAMmE,EAAIhB,EAAO,IAAInD,CAAC,EAClB4J,IAAY,MAAQzF,IAAM,KAC5B2F,EAAS9J,CAAC,EAAI,KAEd8J,EAAS9J,CAAC,EAAI+J,GAAWH,EAASzF,EAAG,KAAK,GAAG,CAEjD,CACA,OAAO,IAAInB,EAAO,GAAIf,EAAc,KAAK6H,CAAQ,CAAC,CACpD,CACA,MAAMP,EAAa,KAAK,MAAM,SAASN,CAAG,EACpCO,EAAc,KAAK,OAAO,SAASP,CAAG,EACtCxH,EAAM8H,EAAW,OACjBtG,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMkE,EAAIqF,EAAW,IAAIvJ,CAAC,EACpBmE,EAAIqF,EAAY,IAAIxJ,CAAC,EACvBkE,IAAM,MAAQC,IAAM,KACtBlB,EAAQjD,CAAC,EAAI,KAEbiD,EAAQjD,CAAC,EAAI+J,GAAW7F,EAAGC,EAAG,KAAK,GAAG,CAE1C,CACA,OAAO,IAAInB,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACA,SAAS8G,GAAW7F,EAAGC,EAAGmF,EAAI,CAC5B,OAAQA,EAAE,CACR,IAAK,KACH,OAAOpF,IAAMC,EACf,IAAK,MACH,OAAOD,IAAMC,EACf,IAAK,KACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,GAAKC,EACd,IAAK,KACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,GAAKC,CAClB,CACA,CACA,IAAImD,GAAc,cAAcP,CAAK,CACnC,MACA,OACA,IACA,YAAYqC,EAAMC,EAAOC,EAAI,CAC3B,MAAK,EACL,KAAK,MAAQF,EACb,KAAK,OAASC,EACd,KAAK,IAAMC,CACb,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,MAAM,aAAc,GAAG,KAAK,OAAO,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,IAAI,KAAK,MAAM,SAAQ,CAAE,IAAI,KAAK,IAAI,YAAW,CAAE,IAAI,KAAK,OAAO,SAAQ,CAAE,GACtF,CACA,SAASL,EAAK,CACZ,MAAMM,EAAa,KAAK,MAAM,SAASN,CAAG,EACpCO,EAAc,KAAK,OAAO,SAASP,CAAG,EACtCxH,EAAM8H,EAAW,OACjBtG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMkE,EAAIqF,EAAW,IAAIvJ,CAAC,EACpBmE,EAAIqF,EAAY,IAAIxJ,CAAC,EACvBkE,IAAM,MAAQC,IAAM,KACtBlB,EAAQ,KAAK,IAAI,EACR,KAAK,MAAQ,MACtBA,EAAQ,KAAKiB,GAAKC,CAAC,EAEnBlB,EAAQ,KAAKiB,GAAKC,CAAC,CAEvB,CACA,OAAO,IAAInB,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACIuE,GAAU,cAAcT,CAAK,CAC/B,OACA,YAAYiD,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,OAAO,KAAK,OAAO,SAAQ,CAAE,EACtC,CACA,SAASf,EAAK,CACZ,MAAMgB,EAAc,KAAK,OAAO,SAAShB,CAAG,EACtCxH,EAAMwI,EAAY,OAClBhH,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAI8I,EAAY,IAAIjK,CAAC,EAC3BiD,EAAQ,KAAK9B,IAAM,KAAO,KAAO,CAACA,CAAC,CACrC,CACA,OAAO,IAAI6B,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACA,SAASiH,GAAI9E,EAAM,CACjB,OAAO,IAAI8D,GAAW9D,CAAI,CAC5B,CACA,SAAS+E,EAAIpK,EAAO,CAClB,OAAO,IAAIyI,GAAYzI,CAAK,CAC9B,CACA,SAASqK,GAAgBjJ,EAAG,CAC1B,OAAIA,aAAa,KAAa,SAASA,EAAE,QAAO,CAAE,GAC9C,OAAOA,GAAM,SAAiB,QAAQA,CAAC,GACvC,OAAOA,GAAM,SAAiB,QAAQA,CAAC,GACvC,OAAOA,GAAM,UAAkB,SAASA,CAAC,GACtC,UAAU,OAAOA,CAAC,CAAC,EAC5B,CACG,IAACkJ,GAAU,cAActD,CAAK,CAC/B,YACA,YAAY4C,EAAY,CACtB,MAAK,EACL,KAAK,YAAcA,CACrB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,KAAK,WAAW,CAC1B,CACA,UAAW,CACT,MAAO,GAAG,KAAK,QAAQ,IAAI,KAAK,WAAW,GAC7C,CACA,SAASV,EAAK,CAEZ,MAAMhI,EAAS,CADA,KAAK,cAAcgI,CAAG,CACf,EAChBnG,EAAOzC,EAAc,KAAKY,CAAM,EACtC,OAAO,IAAI+B,EAAO,GAAIF,CAAI,CAC5B,CACA,cAAcmG,EAAK,CACjB,MAAMzG,EAASyG,EAAI,IAAI,KAAK,WAAW,EACvC,OAAO,KAAK,eAAezG,EAAO,MAAM,CAC1C,CACF,EACIkF,GAAa,cAAc2C,EAAQ,CACrC,SAAW,MACX,eAAepL,EAAQ,CACrB,IAAI6B,EAAQ,EACZ,QAASd,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7BL,GAASK,EAEb,CACA,OAAOL,CACT,CACF,EACI6G,GAAc,cAAc0C,EAAQ,CACtC,SAAW,OACX,eAAepL,EAAQ,CACrB,IAAI6B,EAAQ,EACR3C,EAAQ,EACZ,QAAS6B,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7BL,GAASK,EACThD,IAEJ,CACA,OAAOA,IAAU,EAAI,KAAO2C,EAAQ3C,CACtC,CACF,EACIyJ,GAAe,cAAcyC,EAAQ,CACvC,SAAW,QACX,eAAepL,EAAQ,CACrB,IAAId,EAAQ,EACZ,QAAS6B,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAC7Bf,EAAO,IAAIe,CAAC,IAAM,MACpB7B,IAGJ,OAAOA,CACT,CACF,EACI0J,GAAuB,cAAcwC,EAAQ,CAC/C,SAAW,iBACX,eAAepL,EAAQ,CACrB,MAAM8G,EAAuB,IAAI,IACjC,QAAS/F,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MACR4E,EAAK,IAAIqE,GAAgBjJ,CAAC,CAAC,CAE/B,CACA,OAAO4E,EAAK,IACd,CACF,EACI+B,GAAa,cAAcuC,EAAQ,CACrC,SAAW,MACX,eAAepL,EAAQ,CACrB,IAAIiB,EAAS,KACb,QAASF,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WACzBjB,IAAW,MAAQiB,EAAIjB,KACzBA,EAASiB,EAGf,CACA,OAAOjB,CACT,CACF,EACI6H,GAAa,cAAcsC,EAAQ,CACrC,SAAW,MACX,eAAepL,EAAQ,CACrB,IAAIiB,EAAS,KACb,QAASF,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WACzBjB,IAAW,MAAQiB,EAAIjB,KACzBA,EAASiB,EAGf,CACA,OAAOjB,CACT,CACF,EACI8H,GAAa,cAAcqC,EAAQ,CACrC,SAAW,MACX,eAAepL,EAAQ,CACrB,MAAMgC,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,UAC7BF,EAAO,KAAKE,CAAC,CAEjB,CACA,GAAIF,EAAO,OAAS,EAAG,OAAO,KAC9B,MAAMqJ,EAAOrJ,EAAO,OAAO,CAACiD,EAAGC,IAAMD,EAAIC,EAAG,CAAC,EAAIlD,EAAO,OAClDqE,EAAYrE,EAAO,OAAO,CAACsJ,EAAKpJ,IAAMoJ,GAAOpJ,EAAImJ,IAAS,EAAG,CAAC,EACpE,OAAO,KAAK,KAAKhF,GAAarE,EAAO,OAAS,EAAE,CAClD,CACF,EACIgH,GAAe,cAAcoC,EAAQ,CACvC,SAAW,QACX,eAAepL,EAAQ,CACrB,QAASe,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtB,GAAImB,IAAM,KACR,OAAOA,CAEX,CACA,OAAO,IACT,CACF,EACI+G,GAAc,cAAcmC,EAAQ,CACtC,SAAW,OACX,eAAepL,EAAQ,CACrB,QAASe,EAAIf,EAAO,OAAS,EAAGe,GAAK,EAAGA,IAAK,CAC3C,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtB,GAAImB,IAAM,KACR,OAAOA,CAEX,CACA,OAAO,IACT,CACF,EACIgH,GAAc,cAAckC,EAAQ,CACtC,SAAW,OACX,eAAepL,EAAQ,CACrB,MAAMiB,EAAS,CAAA,EACf,QAASF,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MACRjB,EAAO,KAAKiB,CAAC,CAEjB,CACA,OAAOjB,CACT,CACF,EACIkI,GAAc,cAAciC,EAAQ,CACtC,SAAW,OACX,eAAepL,EAAQ,CACrB,MAAMgH,EAAyB,IAAI,IACnC,QAASjG,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtB,GAAImB,IAAM,KAAM,CACd,MAAM6E,EAAMoE,GAAgBjJ,CAAC,EACvBgF,EAAQF,EAAO,IAAID,CAAG,EACxBG,EACFA,EAAM,QAENF,EAAO,IAAID,EAAK,CAAE,MAAO7E,EAAG,MAAO,EAAG,CAE1C,CACF,CACA,IAAIqJ,EAAO,KACPC,EAAY,EAChB,UAAWtE,KAASF,EAAO,SACrBE,EAAM,MAAQsE,IAChBD,EAAOrE,EAAM,MACbsE,EAAYtE,EAAM,OAGtB,OAAOqE,CACT,CACF,EACI/B,GAAe,cAAc1B,CAAK,CACpC,OACA,YAAYuB,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,MAAMb,EAAuB,IAAI,IACjC,UAAWiD,KAAK,KAAK,OACnB,UAAWhH,KAAKgH,EAAE,aAChBjD,EAAK,IAAI/D,CAAC,EAGd,MAAO,CAAC,GAAG+D,CAAI,CACjB,CACA,UAAW,CACT,MAAO,YAAY,KAAK,OAAO,IAAK,GAAM,EAAE,SAAQ,CAAE,EAAE,KAAK,IAAI,CAAC,GACpE,CACA,SAASwB,EAAK,CACZ,MAAM0B,EAAY,KAAK,OAAO,IAAKD,GAAMA,EAAE,SAASzB,CAAG,CAAC,EAClDxH,EAAMkJ,EAAU,CAAC,EAAE,OACnB1H,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,IAAI4K,EAAQ,KACZ,UAAW/I,KAAK8I,EAAW,CACzB,MAAMxJ,EAAIU,EAAE,IAAI7B,CAAC,EACjB,GAAImB,IAAM,KAAM,CACdyJ,EAAQzJ,EACR,KACF,CACF,CACA8B,EAAQ,KAAK2H,CAAK,CACpB,CAEA,MAAMpE,EADcmE,EAAU,CAAC,EACL,OAAO,MAC3B7H,EAAOiG,GAAqBvC,EAAOvD,CAAO,EAChD,OAAO,IAAID,EAAO,GAAIF,CAAI,CAC5B,CACF,EACI6F,GAAe,cAAc5B,CAAK,CACpC,OACA,MACA,YAAYiD,EAAOa,EAAM,CACvB,MAAK,EACL,KAAK,OAASb,EACd,KAAK,MAAQa,CACf,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,aAAc,GAAG,KAAK,MAAM,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,YAAY,KAAK,OAAO,SAAQ,CAAE,KAAK,KAAK,MAAM,SAAQ,CAAE,GACrE,CACA,SAAS5B,EAAK,CACZ,MAAMgB,EAAc,KAAK,OAAO,SAAShB,CAAG,EACtC6B,EAAa,KAAK,MAAM,SAAS7B,CAAG,EACpCxH,EAAMwI,EAAY,OAClBhH,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAI8I,EAAY,IAAIjK,CAAC,EAC3BiD,EAAQ,KAAK9B,IAAM,KAAOA,EAAI2J,EAAW,IAAI9K,CAAC,CAAC,CACjD,CACA,MAAMwG,EAAQyD,EAAY,OAAO,MAC3BnH,EAAOiG,GAAqBvC,EAAOvD,CAAO,EAChD,OAAO,IAAID,EAAO,GAAIF,CAAI,CAC5B,CACF,EACI8F,GAAa,cAAc7B,CAAK,CAClC,OACA,YAAYiD,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,UAClC,CACA,SAASf,EAAK,CACZ,MAAMgB,EAAc,KAAK,OAAO,SAAShB,CAAG,EACtCxH,EAAMwI,EAAY,OAClBhH,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBiD,EAAQ,KAAKgH,EAAY,IAAIjK,CAAC,IAAM,IAAI,EAE1C,OAAO,IAAIgD,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACI4F,GAAgB,cAAc9B,CAAK,CACrC,OACA,YAAYiD,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,cAClC,CACA,SAASf,EAAK,CACZ,MAAMgB,EAAc,KAAK,OAAO,SAAShB,CAAG,EACtCxH,EAAMwI,EAAY,OAClBhH,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBiD,EAAQ,KAAKgH,EAAY,IAAIjK,CAAC,IAAM,IAAI,EAE1C,OAAO,IAAIgD,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EAGI8H,GAAsB,CAAC,GAAI,OAAQ,OAAQ,KAAM,MAAO,MAAO,MAAO,OAAQ,MAAM,EACpFC,EAAW,GACXC,EAAQ,GACRC,EAAQ,GACRC,GAAW,GACXC,GAAU,GACVC,GAAS,EACTC,GAAU,IACd,SAASC,GAASC,EAASC,EAAU,GAAI,CACvC,GAAID,EAAQ,SAAW,EACrB,MAAO,CAAE,OAAQ,CAAA,EAAI,QAAS,CAAA,EAAI,cAAe,EAAE,EAErD,MAAME,EAAUD,EAAQ,QAClBE,EAAYF,EAAQ,YAAc,GAClCG,EAAa,IAAI,IAAIH,EAAQ,YAAcV,EAAmB,EAC9Dc,EAAWJ,EAAQ,UAAY,EAC/BK,EAAYL,EAAQ,WAAaM,GAAoBP,CAAO,EAC5DQ,EAAYF,EAAU,WAAW,CAAC,EAClCG,EAAWH,EAAU,OACrBI,EAAiBD,EAAW,EAClC,IAAIE,EAAM,EACNC,EAAU,EACd,KAAOA,EAAUP,GAAYM,EAAMX,EAAQ,QACzCW,EAAME,GAASb,EAASW,CAAG,EAC3BC,IAEF,GAAIV,EACF,KAAOS,EAAMX,EAAQ,QAAQ,CAC3B,IAAIc,EAAYH,EAChB,KAAOG,EAAYd,EAAQ,QAAQ,CACjC,MAAMe,EAAIf,EAAQ,WAAWc,CAAS,EACtC,GAAIC,IAAM,IAAMA,IAAMlB,GAAQ,MAC9BiB,GACF,CACA,GAAIA,EAAYd,EAAQ,QAAUA,EAAQ,WAAWE,EAASY,CAAS,EACrEH,EAAME,GAASb,EAASW,CAAG,MAE3B,MAEJ,CAEF,IAAIK,EACJ,GAAIf,EAAQ,OACVe,EAASf,EAAQ,OACbE,IACFQ,EAAME,GAASb,EAASW,CAAG,WAEpBR,EAAW,CACpB,MAAMc,EAAeC,GAAgBlB,EAASW,EAAKH,EAAWC,EAAUC,EAAgBJ,CAAS,EACjGU,EAASC,EAAa,OAAO,IAAKE,GAAMA,EAAE,MAAM,EAChDR,EAAMM,EAAa,OACrB,MAEED,EADaE,GAAgBlB,EAASW,EAAKH,EAAWC,EAAUC,EAAgBJ,CAAS,EAC3E,OAAO,IAAI,CAACc,EAAG5M,IAAM,UAAUA,CAAC,EAAE,EAElD,GAAIwM,EAAO,SAAW,EACpB,MAAO,CAAE,OAAQ,CAAA,EAAI,QAAS,CAAA,EAAI,cAAe,EAAE,EAErD,MAAMK,EAAkBpB,EAAQ,QAAU,IAAI,IAAIA,EAAQ,OAAO,EAAI,KAC/DqB,EAAe,CAAA,EACfC,EAAa,CAAA,EACnB,QAAS/M,EAAI,EAAGA,EAAIwM,EAAO,OAAQxM,IAAK,CACtC,MAAMoF,EAAOoH,EAAOxM,CAAC,EACjB6M,GAAmB,CAACA,EAAgB,IAAIzH,CAAI,IAChD0H,EAAa,KAAK1H,CAAI,EACtB2H,EAAW,KAAK/M,CAAC,EACnB,CACA,MAAMgN,EAAgB,KAAK,IAAI,EAAG,KAAK,MAAMxB,EAAQ,OAAS,EAAE,CAAC,EAC3DjF,EAAU,CAAA,EAChB,UAAWnB,KAAQ0H,EAAc,CAC/B,MAAMvJ,EAAM,CAAA,EACRyJ,EAAgB,MAClBzJ,EAAI,OAASyJ,EACbzJ,EAAI,OAAS,GAEfgD,EAAQnB,CAAI,EAAI7B,CAClB,CACA,MAAM0J,EAAUxB,EAAQ,OAAS,IACjC,IAAIyB,EAAW,EACf,MAAMC,EAAgBL,EAAa,OAC7BM,EAAaD,IAAkBX,EAAO,OAC5C,KAAOL,EAAMX,EAAQ,QAAU0B,EAAWD,GAAS,CACjD,GAAIvB,EAAS,CACX,IAAIY,EAAYH,EAChB,KAAOG,EAAYd,EAAQ,QAAQ,CACjC,MAAMe,EAAIf,EAAQ,WAAWc,CAAS,EACtC,GAAIC,IAAM,IAAMA,IAAMlB,GAAQ,MAC9BiB,GACF,CACA,GAAIA,EAAYd,EAAQ,QAAUA,EAAQ,WAAWE,EAASY,CAAS,EAAG,CACxEH,EAAME,GAASb,EAASW,CAAG,EAC3B,QACF,CACF,CACA,GAAIX,EAAQ,WAAWW,CAAG,IAAMlB,GAASO,EAAQ,WAAWW,CAAG,IAAMjB,EAAO,CAC1EiB,EAAME,GAASb,EAASW,CAAG,EAC3B,QACF,CACIiB,EACFjB,EAAMkB,GAAe7B,EAASW,EAAKH,EAAWC,EAAUC,EAAgBJ,EAAWvF,EAASuG,EAAcK,EAAevB,CAAU,EAEnIO,EAAMmB,GAAiB9B,EAASW,EAAKH,EAAWC,EAAUC,EAAgBJ,EAAWvF,EAASuG,EAAcC,EAAYI,EAAevB,CAAU,EAEnJsB,GACF,CACA,MAAMK,EAAgBC,GAAiBjH,EAASuG,EAAcrB,CAAO,EACrE,MAAO,CAAE,OAAQqB,EAAc,QAAAvG,EAAS,cAAAgH,CAAa,CACvD,CACA,SAASlB,GAASb,EAASW,EAAK,CAC9B,IAAIsB,EAAW,GACf,KAAOtB,EAAMX,EAAQ,QAAQ,CAC3B,MAAMkC,EAAKlC,EAAQ,WAAWW,CAAG,EACjC,GAAIuB,IAAO1C,EACTyC,EAAW,CAACA,UACH,CAACA,EAAU,CACpB,GAAIC,IAAOxC,EACT,OAAAiB,IACIA,EAAMX,EAAQ,QAAUA,EAAQ,WAAWW,CAAG,IAAMlB,GAAOkB,IACxDA,EAET,GAAIuB,IAAOzC,EACT,OAAOkB,EAAM,CAEjB,CACAA,GACF,CACA,OAAOA,CACT,CACA,SAASO,GAAgBlB,EAASW,EAAKH,EAAWC,EAAUC,EAAgBJ,EAAW,CACrF,MAAM6B,EAAS,CAAA,EACTlM,EAAM+J,EAAQ,OACpB,KAAOW,GAAO1K,GAAK,CACjB,GAAI0K,GAAO1K,EAAK,CACdkM,EAAO,KAAK,EAAE,EACd,KACF,CACA,MAAMD,EAAKlC,EAAQ,WAAWW,CAAG,EACjC,GAAIuB,IAAOxC,GAASwC,IAAOzC,EACzB,OAAA0C,EAAO,KAAK,EAAE,EACVD,IAAOxC,GAASiB,EAAM,EAAI1K,GAAO+J,EAAQ,WAAWW,EAAM,CAAC,IAAMlB,EACnEkB,GAAO,EAEPA,GAAO,EAEF,CAAE,OAAAwB,EAAQ,QAASxB,CAAG,EAE/B,GAAIuB,IAAO1C,EAAU,CACnBmB,IACA,MAAMyB,EAAazB,EACnB,IAAI0B,EAAY,GAChB,KAAO1B,EAAM1K,GAEX,GADU+J,EAAQ,WAAWW,CAAG,IACtBnB,EACR,GAAImB,EAAM,EAAI1K,GAAO+J,EAAQ,WAAWW,EAAM,CAAC,IAAMnB,EACnD6C,EAAY,GACZ1B,GAAO,MAEP,YAGFA,IAGJ,IAAIpM,EAQJ,GAPI8N,EACF9N,EAAQyL,EAAQ,UAAUoC,EAAYzB,CAAG,EAAE,QAAQ,MAAO,GAAG,EAE7DpM,EAAQyL,EAAQ,UAAUoC,EAAYzB,CAAG,EAE3CwB,EAAO,KAAK5N,CAAK,EACboM,EAAM1K,GAAK0K,IACXA,EAAM1K,EAAK,CACb,MAAMqM,EAAOtC,EAAQ,WAAWW,CAAG,EACnC,GAAI2B,IAAS5C,GAAS4C,IAAS7C,EAC7B,OAAI6C,IAAS5C,GAASiB,EAAM,EAAI1K,GAAO+J,EAAQ,WAAWW,EAAM,CAAC,IAAMlB,EACrEkB,GAAO,EAEPA,GAAO,EAEF,CAAE,OAAAwB,EAAQ,QAASxB,CAAG,GAE3BD,EAAiBV,EAAQ,WAAWM,EAAWK,CAAG,EAAI2B,IAAS9B,KACjEG,GAAOF,EAEX,CACF,KAAO,CACL,MAAM2B,EAAazB,EACnB,KAAOA,EAAM1K,GAAK,CAChB,MAAMsM,EAAKvC,EAAQ,WAAWW,CAAG,EAEjC,GADI4B,IAAO7C,GAAS6C,IAAO9C,IACvBiB,EAAiBV,EAAQ,WAAWM,EAAWK,CAAG,EAAI4B,IAAO/B,GAAW,MAC5EG,GACF,CAEA,GADAwB,EAAO,KAAKnC,EAAQ,UAAUoC,EAAYzB,CAAG,CAAC,EAC1CA,GAAO1K,EACT,MAAO,CAAE,OAAAkM,EAAQ,QAASxB,CAAG,EAE/B,MAAMI,EAAIf,EAAQ,WAAWW,CAAG,EAChC,GAAII,IAAMrB,GAASqB,IAAMtB,EACvB,OAAIsB,IAAMrB,GAASiB,EAAM,EAAI1K,GAAO+J,EAAQ,WAAWW,EAAM,CAAC,IAAMlB,EAClEkB,GAAO,EAEPA,GAAO,EAEF,CAAE,OAAAwB,EAAQ,QAASxB,CAAG,EAE/BA,GAAOF,CACT,CACF,CACA,MAAO,CAAE,OAAA0B,EAAQ,QAASxB,CAAG,CAC/B,CACA,SAASkB,GAAe7B,EAASW,EAAKH,EAAWC,EAAUC,EAAgBJ,EAAWvF,EAASuG,EAAckB,EAASpC,EAAY,CAChI,MAAMnK,EAAM+J,EAAQ,OACpB,IAAIyC,EAAS,EACb,KAAO9B,EAAM1K,GAAOwM,GAAUD,GAAS,CACrC,MAAMN,EAAKlC,EAAQ,WAAWW,CAAG,EACjC,GAAIuB,IAAOxC,GAASwC,IAAOzC,EAAO,CAChC,KAAOgD,EAASD,GACdzH,EAAQuG,EAAamB,CAAM,CAAC,EAAE,KAAK,IAAI,EACvCA,IAEF,OAAIP,IAAOxC,GAASiB,EAAM,EAAI1K,GAAO+J,EAAQ,WAAWW,EAAM,CAAC,IAAMlB,EAC5DkB,EAAM,EAERA,EAAM,CACf,CACA,GAAI8B,GAAUD,EACZ,OAAOE,GAAU1C,EAASW,CAAG,EAE/B,GAAIuB,IAAO1C,EAAU,CACnBmB,IACA,MAAMyB,EAAazB,EACnB,IAAI0B,EAAY,GAChB,KAAO1B,EAAM1K,GAEX,GADU+J,EAAQ,WAAWW,CAAG,IACtBnB,EACR,GAAImB,EAAM,EAAI1K,GAAO+J,EAAQ,WAAWW,EAAM,CAAC,IAAMnB,EACnD6C,EAAY,GACZ1B,GAAO,MAEP,YAGFA,IAGJ,IAAIpM,EAUJ,GATI8N,EACF9N,EAAQyL,EAAQ,UAAUoC,EAAYzB,CAAG,EAAE,QAAQ,MAAO,GAAG,EAE7DpM,EAAQyL,EAAQ,UAAUoC,EAAYzB,CAAG,EAEvCA,EAAM1K,GAAK0K,IACA5F,EAAQuG,EAAamB,CAAM,CAAC,EACpC,KAAKrC,EAAW,IAAI7L,CAAK,EAAI,KAAOA,CAAK,EAChDkO,IACI9B,EAAM1K,EAAK,CACb,MAAMqM,EAAOtC,EAAQ,WAAWW,CAAG,EACnC,GAAI2B,IAAS5C,GAAS4C,IAAS7C,EAAO,UAClCiB,EAAiBV,EAAQ,WAAWM,EAAWK,CAAG,EAAI2B,IAAS9B,KACjEG,GAAOF,EAEX,CACF,KAAO,CACL,MAAM2B,EAAazB,EACnB,KAAOA,EAAM1K,GAAK,CAChB,MAAMsM,EAAKvC,EAAQ,WAAWW,CAAG,EAEjC,GADI4B,IAAO7C,GAAS6C,IAAO9C,IACvBiB,EAAiBV,EAAQ,WAAWM,EAAWK,CAAG,EAAI4B,IAAO/B,GAAW,MAC5EG,GACF,CACA,MAAMpM,EAAQyL,EAAQ,UAAUoC,EAAYzB,CAAG,EAI/C,GAHe5F,EAAQuG,EAAamB,CAAM,CAAC,EACpC,KAAKrC,EAAW,IAAI7L,CAAK,EAAI,KAAOA,CAAK,EAChDkO,IACI9B,GAAO1K,EAAK,MAChB,MAAM8K,EAAIf,EAAQ,WAAWW,CAAG,EAChC,GAAII,IAAMrB,GAASqB,IAAMtB,EAAO,SAChCkB,GAAOF,CACT,CACF,CACA,KAAOgC,EAASD,GACdzH,EAAQuG,EAAamB,CAAM,CAAC,EAAE,KAAK,IAAI,EACvCA,IAEF,OAAO9B,CACT,CACA,SAASmB,GAAiB9B,EAASW,EAAKH,EAAWC,EAAUC,EAAgBJ,EAAWvF,EAASuG,EAAcC,EAAYI,EAAevB,EAAY,CACpJ,MAAMnK,EAAM+J,EAAQ,OACpB,IAAI2C,EAAW,EACXC,EAAY,EAEZC,EADetB,EAAW,CAAC,GAAK,GAEpC,KAAOZ,EAAM1K,GAAK,CAChB,MAAMiM,EAAKlC,EAAQ,WAAWW,CAAG,EACjC,GAAIuB,IAAOxC,GAASwC,IAAOzC,EAAO,CAChC,KAAOmD,EAAYjB,GACjB5G,EAAQuG,EAAasB,CAAS,CAAC,EAAE,KAAK,IAAI,EAC1CA,IAEF,OAAIV,IAAOxC,GAASiB,EAAM,EAAI1K,GAAO+J,EAAQ,WAAWW,EAAM,CAAC,IAAMlB,EAC5DkB,EAAM,EAERA,EAAM,CACf,CACA,MAAMmC,EAASH,IAAaE,EAC5B,GAAIX,IAAO1C,EAET,GADAmB,IACImC,EAAQ,CACV,MAAMV,EAAazB,EACnB,IAAI0B,EAAY,GAChB,KAAO1B,EAAM1K,GAEX,GADW+J,EAAQ,WAAWW,CAAG,IACtBnB,EACT,GAAImB,EAAM,EAAI1K,GAAO+J,EAAQ,WAAWW,EAAM,CAAC,IAAMnB,EACnD6C,EAAY,GACZ1B,GAAO,MAEP,YAGFA,IAGJ,IAAIpM,EACA8N,EACF9N,EAAQyL,EAAQ,UAAUoC,EAAYzB,CAAG,EAAE,QAAQ,MAAO,GAAG,EAE7DpM,EAAQyL,EAAQ,UAAUoC,EAAYzB,CAAG,EAEvCA,EAAM1K,GAAK0K,IACf5F,EAAQuG,EAAasB,CAAS,CAAC,EAAE,KAAKxC,EAAW,IAAI7L,CAAK,EAAI,KAAOA,CAAK,EAC1EqO,IACAC,EAAgBD,EAAYjB,EAAgBJ,EAAWqB,CAAS,EAAI,EACtE,KACE,MAAOjC,EAAM1K,GAEX,GADW+J,EAAQ,WAAWW,CAAG,IACtBnB,EACT,GAAImB,EAAM,EAAI1K,GAAO+J,EAAQ,WAAWW,EAAM,CAAC,IAAMnB,EACnDmB,GAAO,MACF,CACLA,IACA,KACF,MAEAA,QAID,CACL,MAAMyB,EAAazB,EACnB,KAAOA,EAAM1K,GAAK,CAChB,MAAMsM,EAAKvC,EAAQ,WAAWW,CAAG,EAEjC,GADI4B,IAAO7C,GAAS6C,IAAO9C,IACvBiB,EAAiBV,EAAQ,WAAWM,EAAWK,CAAG,EAAI4B,IAAO/B,GAAW,MAC5EG,GACF,CACA,GAAImC,EAAQ,CACV,MAAMvO,EAAQyL,EAAQ,UAAUoC,EAAYzB,CAAG,EAC/C5F,EAAQuG,EAAasB,CAAS,CAAC,EAAE,KAAKxC,EAAW,IAAI7L,CAAK,EAAI,KAAOA,CAAK,EAC1EqO,IACAC,EAAgBD,EAAYjB,EAAgBJ,EAAWqB,CAAS,EAAI,EACtE,CACF,CAEA,GADAD,IACIhC,GAAO1K,EAAK,MAChB,MAAM8K,EAAIf,EAAQ,WAAWW,CAAG,EAC5BI,IAAMrB,GAASqB,IAAMtB,IACrBiB,EAAiBV,EAAQ,WAAWM,EAAWK,CAAG,EAAII,IAAMP,KAC9DG,GAAOF,EAEX,CACA,KAAOmC,EAAYjB,GACjB5G,EAAQuG,EAAasB,CAAS,CAAC,EAAE,KAAK,IAAI,EAC1CA,IAEF,OAAOjC,CACT,CACA,SAAS+B,GAAU1C,EAASW,EAAK,CAC/B,IAAIsB,EAAW,GACf,MAAMhM,EAAM+J,EAAQ,OACpB,KAAOW,EAAM1K,GAAK,CAChB,MAAMiM,EAAKlC,EAAQ,WAAWW,CAAG,EACjC,GAAIuB,IAAO1C,EACTyC,EAAW,CAACA,UACH,CAACA,EAAU,CACpB,GAAIC,IAAOxC,EACT,OAAAiB,IACIA,EAAM1K,GAAO+J,EAAQ,WAAWW,CAAG,IAAMlB,GAAOkB,IAC7CA,EAET,GAAIuB,IAAOzC,EACT,OAAOkB,EAAM,CAEjB,CACAA,GACF,CACA,OAAOA,CACT,CACA,SAASJ,GAAoBP,EAAS,CACpC,MAAM+C,EAAa,CAACpD,GAAUC,GAASC,GAAQC,EAAO,EAChDkD,EAAgB,CAAC,IAAK,IAAK,IAAK,GAAG,EACnCC,EAAW,GACjB,IAAIC,EAAgB,IAChBC,EAAY,GAChB,QAASC,EAAK,EAAGA,EAAKL,EAAW,OAAQK,IAAM,CAC7C,MAAM5C,EAAYuC,EAAWK,CAAE,EACzB3I,EAAS,CAAA,EACf,IAAIkG,EAAM,EACN0C,EAAU,EACd,KAAO1C,EAAMX,EAAQ,QAAUqD,EAAUJ,GAAU,CACjD,IAAItQ,EAAQ,EACRsP,EAAW,GACf,KAAOtB,EAAMX,EAAQ,QAAQ,CAC3B,MAAMkC,EAAKlC,EAAQ,WAAWW,CAAG,EACjC,GAAIuB,IAAO1C,EACTyC,EAAW,CAACA,UACH,CAACA,IACNC,IAAO1B,GAAW7N,IAClBuP,IAAOxC,GAASwC,IAAOzC,GAAO,CAC5ByC,IAAOxC,GAASiB,EAAM,EAAIX,EAAQ,QAAUA,EAAQ,WAAWW,EAAM,CAAC,IAAMlB,GAC9EkB,IAEFA,IACA,KACF,CAEFA,GACF,CACAlG,EAAO,KAAK9H,CAAK,EACjB0Q,GACF,CACA,GAAI5I,EAAO,SAAW,EAAG,SACzB,MAAM6I,EAAM7I,EAAO,OAAO,CAAC/B,EAAGC,IAAMD,EAAIC,EAAG,CAAC,EAAI8B,EAAO,OACvD,GAAI6I,IAAQ,EAAG,SAEf,MAAMC,EADU9I,EAAO,MAAOsG,GAAMA,IAAMtG,EAAO,CAAC,CAAC,EAC3B6I,EAAM,EAAIA,EAC9BC,EAAQJ,IACVA,EAAYI,EACZL,EAAgBF,EAAcI,CAAE,EAEpC,CACA,OAAOF,CACT,CACA,SAASlB,GAAiBjH,EAASiG,EAAQf,EAAS,CAClD,MAAMuD,EAAQ,CAAA,EACRC,EAAexD,EAAQ,eAAiB,GACxCyD,EAAazD,EAAQ,aAAe,GAC1C,UAAWrG,KAAQoH,EAAQ,CACzB,GAAIf,EAAQ,QAAUrG,KAAQqG,EAAQ,OAAQ,CAC5CuD,EAAM5J,CAAI,EAAIqG,EAAQ,OAAOrG,CAAI,EACjC,QACF,CAEA,MAAM+J,EADS5I,EAAQnB,CAAI,EACL,MAAM,EAAG,GAAG,EAAE,OAAQjE,GAAMA,IAAM,IAAI,EAC5D,GAAIgO,EAAO,SAAW,EAAG,CACvBH,EAAM5J,CAAI,EAAI,OACd,QACF,CACA,GAAI6J,GAAgBE,EAAO,MAAMC,EAAe,EAAG,CACjDJ,EAAM5J,CAAI,EAAI+J,EAAO,MAAME,EAAe,EAAI,MAAoB,MAClE,QACF,CACA,GAAIF,EAAO,MAAMG,EAAe,EAAG,CACjCN,EAAM5J,CAAI,EAAI,OACd,QACF,CACA,GAAI8J,GAAcC,EAAO,MAAMI,EAAY,EAAG,CAC5CP,EAAM5J,CAAI,EAAI,OACd,QACF,CACA4J,EAAM5J,CAAI,EAAI,MAChB,CACA,OAAO4J,CACT,CACA,SAASI,GAAgBvN,EAAG,CAC1B,GAAIA,EAAE,SAAW,EAAG,MAAO,GAC3B,MAAM2C,EAAI,OAAO3C,CAAC,EAClB,MAAO,CAAC,OAAO,MAAM2C,CAAC,GAAK3C,EAAE,KAAI,EAAG,OAAS,CAC/C,CACA,SAASwN,GAAgBxN,EAAG,CAC1B,GAAI,CAACuN,GAAgBvN,CAAC,EAAG,MAAO,GAChC,MAAM2C,EAAI,OAAO3C,CAAC,EAClB,OAAO,OAAO,UAAU2C,CAAC,GAAK,CAAC3C,EAAE,SAAS,GAAG,GAAK,CAACA,EAAE,SAAS,GAAG,GAAK,CAACA,EAAE,SAAS,GAAG,CACvF,CACA,SAASyN,GAAgBzN,EAAG,CAC1B,MAAM2N,EAAQ3N,EAAE,YAAW,EAC3B,OAAO2N,IAAU,QAAUA,IAAU,OACvC,CACA,IAAIC,GAAc,2EAClB,SAASF,GAAa1N,EAAG,CACvB,GAAI,CAAC4N,GAAY,KAAK5N,CAAC,EAAG,MAAO,GACjC,MAAM6B,EAAI,IAAI,KAAK7B,CAAC,EACpB,MAAO,CAAC,OAAO,MAAM6B,EAAE,QAAO,CAAE,CAClC,CAGA,SAASgM,GAASlD,EAAQmD,EAAMlE,EAAU,CAAA,EAAI,CAC5C,MAAMK,EAAYL,EAAQ,WAAa,IACjCmE,EAAanE,EAAQ,YAAc,YACnCoE,EAAYpE,EAAQ,WAAa,GACjCqE,EAAgBrE,EAAQ,SAAW,GACnCsE,EAAMtE,EAAQ,MAAQ,GACtBuE,EAAQ,CAAA,EACVD,GACFC,EAAM,KAAK,QAAQ,EAEjBF,GACFE,EAAM,KAAKxD,EAAO,IAAKG,GAAMsD,GAAWtD,EAAGb,EAAW8D,CAAU,CAAC,EAAE,KAAK9D,CAAS,CAAC,EAEpF,UAAWoE,KAAOP,EAAM,CACtB,MAAMhC,EAASuC,EAAI,IAAKnQ,GAClBA,GAAU,KACLkQ,GAAWJ,EAAW/D,EAAW8D,CAAU,EAEhD7P,aAAiB,KACZkQ,GAAWlQ,EAAM,YAAW,EAAI+L,EAAW8D,CAAU,EAGrDK,GADL,OAAOlQ,GAAU,UAAY,OAAOA,GAAU,UAAY,OAAOA,GAAU,UAC3D,OAAOA,CAAK,EAEd,KAAK,UAAUA,CAAK,EAFH+L,EAAW8D,CAAU,CAGzD,EACDI,EAAM,KAAKrC,EAAO,KAAK7B,CAAS,CAAC,CACnC,CACA,OAAOkE,EAAM,KAAK;AAAA,CAAI,EAAI;AAAA,CAC5B,CACA,SAASC,GAAWlQ,EAAO+L,EAAW8D,EAAY,CAChD,OAAIA,IAAe,QACV7P,EAEL6P,IAAe,SACV,IAAM7P,EAAM,QAAQ,KAAM,IAAI,EAAI,IAEvCA,EAAM,SAAS+L,CAAS,GAAK/L,EAAM,SAAS,GAAG,GAAKA,EAAM,SAAS;AAAA,CAAI,GAAKA,EAAM,SAAS,IAAI,EAC1F,IAAMA,EAAM,QAAQ,KAAM,IAAI,EAAI,IAEpCA,CACT,CAGA,IAAIoQ,GAAuB,CAAC,GAAI,OAAQ,OAAQ,KAAM,MAAO,MAAO,MAAO,OAAQ,MAAM,EACzF,eAAgBC,GAAcC,EAAU5E,EAAU,GAAI,CACpD,MAAM6E,EAAY7E,EAAQ,WAAa,IACjC8E,EAAK,KAAM,QAAO,uCAAI,EACtB,CAAE,iBAAAC,CAAgB,EAAKD,EAC7B,IAAIE,EACJ,GAAI,CACFA,EAASD,EAAiBH,EAAU,CAAE,SAAU5E,EAAQ,UAAY,QAAS,CAC/E,OAASiF,EAAK,CACZ,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,4BAA4B+Q,CAAQ,MAAMtR,CAAO,EAAE,CACvE,CACA,MAAM4M,EAAYF,EAAQ,YAAc,GAClCG,EAAa,IAAI,IAAIH,EAAQ,YAAc0E,EAAoB,EAC/DzE,EAAUD,EAAQ,QAClBI,EAAWJ,EAAQ,UAAY,EACrC,IAAIkF,EAAS,KACTC,EAAS,GACTnD,EAAW,GACXoD,EAAe,CAAA,EACfC,EAAe,EACfC,EAAiB,GACjBC,EAAY,CAAA,EACZ9D,EAAW,EACX+D,EAAmB,EACvB,MAAMC,EAAQzF,EAAQ,MACtB,SAAS0F,EAAUC,EAAMtF,EAAW,CAClC,MAAM6B,EAAS,CAAA,EACf,IAAI0D,EAAU,GACVC,EAAS,GACTtR,EAAI,EACR,KAAOA,EAAIoR,EAAK,QAAQ,CACtB,MAAM1D,EAAK0D,EAAKpR,CAAC,EACbsR,EACE5D,IAAO,IACL1N,EAAI,EAAIoR,EAAK,QAAUA,EAAKpR,EAAI,CAAC,IAAM,KACzCqR,GAAW,IACXrR,GAAK,IAELsR,EAAS,GACTtR,MAGFqR,GAAW3D,EACX1N,KAGE0N,IAAO,KAAO2D,EAAQ,SAAW,GACnCC,EAAS,GACTtR,KACSoR,EAAK,WAAWtF,EAAW9L,CAAC,GACrC2N,EAAO,KAAK0D,CAAO,EACnBA,EAAU,GACVrR,GAAK8L,EAAU,SAEfuF,GAAW3D,EACX1N,IAGN,CACA,GAAIsR,EACF,MAAM,IAAIjS,GAAW,kCAAkC,EAEzD,OAAAsO,EAAO,KAAK0D,CAAO,EACZ1D,CACT,CACA,SAAS4D,EAAgBvB,EAAO,CAC9B,MAAMzB,EAAa,CAAC,IAAK,IAAK,IAAK,GAAG,EACtC,IAAIG,EAAgB,IAChBC,EAAY,GAChB,UAAW6C,KAASjD,EAAY,CAC9B,MAAMtI,EAAS+J,EAAM,IAAKoB,IAAS,CACjC,IAAIjT,GAAQ,EACRsT,GAAI,GACR,QAASzR,GAAI,EAAGA,GAAIoR,GAAK,OAAQpR,KACpBoR,GAAKpR,EAAC,IACN,IAAKyR,GAAI,CAACA,GACZ,CAACA,IAAKL,GAAK,WAAWI,EAAOxR,EAAC,GAAG7B,KAE5C,OAAOA,EACT,CAAC,EACD,GAAI8H,EAAO,SAAW,EAAG,SACzB,MAAM6I,EAAM7I,EAAO,OAAO,CAAC/B,GAAGC,KAAMD,GAAIC,GAAG,CAAC,EAAI8B,EAAO,OACvD,GAAI6I,IAAQ,EAAG,SAEf,MAAMC,EADU9I,EAAO,MAAOsG,IAAMA,KAAMtG,EAAO,CAAC,CAAC,EAC3B6I,EAAM,EAAIA,EAC9BC,EAAQJ,IACVA,EAAYI,EACZL,EAAgB8C,EAEpB,CACA,OAAO9C,CACT,CACA,SAASgD,EAAWnL,EAASiG,EAAQmF,EAAM,CACzC,MAAM3C,EAAQ,CAAA,EACRC,EAAe0C,EAAK,eAAiB,GACrCzC,EAAayC,EAAK,aAAe,GACvC,UAAWvM,KAAQoH,EAAQ,CACzB,GAAImF,EAAK,QAAUvM,KAAQuM,EAAK,OAAQ,CACtC3C,EAAM5J,CAAI,EAAIuM,EAAK,OAAOvM,CAAI,EAC9B,QACF,CAEA,MAAM+J,EADS5I,EAAQnB,CAAI,EACL,MAAM,EAAG,GAAG,EAAE,OAAQjE,IAAMA,KAAM,IAAI,EAC5D,GAAIgO,EAAO,SAAW,EAAG,CACvBH,EAAM5J,CAAI,EAAI,OACd,QACF,CACA,GAAI6J,GAAgBE,EAAO,MAAMyC,EAAgB,EAAG,CAClD5C,EAAM5J,CAAI,EAAI+J,EAAO,MAAM0C,EAAgB,EAAI,MAAoB,MACnE,QACF,CACA,GAAI1C,EAAO,MAAM2C,EAAgB,EAAG,CAClC9C,EAAM5J,CAAI,EAAI,OACd,QACF,CACA,GAAI8J,GAAcC,EAAO,MAAM4C,EAAa,EAAG,CAC7C/C,EAAM5J,CAAI,EAAI,OACd,QACF,CACA4J,EAAM5J,CAAI,EAAI,MAChB,CACA,OAAO4J,CACT,CACA,SAASgD,EAAcxF,EAAQ,CAC7B,MAAMyF,EAAO,CAAA,EACb,UAAW7M,KAAQoH,EACjByF,EAAK7M,CAAI,EAAI,CAAA,EAEf,OAAO6M,CACT,CACA,SAASC,EAAcvE,EAAQwE,EAAS,CACtC,QAASnS,EAAI,EAAGA,EAAImS,EAAQ,OAAO,OAAQnS,IAAK,CAC9C,MAAMoF,EAAO+M,EAAQ,OAAOnS,CAAC,EACvBoS,EAAMpS,EAAI2N,EAAO,OAASA,EAAO3N,CAAC,EAAI,GACtCD,EAAQoS,EAAQ,WAAW,IAAIC,CAAG,EAAI,KAAOA,EACnDpB,EAAU5L,CAAI,EAAE,KAAKrF,CAAK,CAC5B,CACAmN,GACF,CACA,IAAImF,EAAe,KACfC,EAAoB,KACxB,SAASC,EAAYnB,EAAM,CACzB,GAAI1F,GAAW0F,EAAK,UAAS,EAAG,WAAW1F,CAAO,EAChD,OAAO,KAET,GAAIoF,EAAejF,EACjB,OAAAiF,IACO,KAET,GAAI,CAACC,EACH,OAAAuB,EAAoB7G,EAAQ,WAAa8F,EAAgB,CAACH,CAAI,CAAC,EAC3D3F,EAAQ,QACV4G,EAAe5G,EAAQ,OACvBoF,EAAa,KAAKO,CAAI,GACbzF,EACT0G,EAAelB,EAAUC,EAAMkB,CAAiB,EAAE,IAAK3F,GAAMA,EAAE,MAAM,GAGrE0F,EADoBlB,EAAUC,EAAMkB,CAAiB,EAC1B,IAAI,CAAC1F,EAAG5M,IAAM,UAAUA,CAAC,EAAE,EACtD6Q,EAAa,KAAKO,CAAI,GAExBL,EAAiB,GACV,KAET,GAAI,CAACJ,EAAQ,CACXE,EAAa,KAAKO,CAAI,EACtB,MAAMtF,EAAYwG,EACZ9F,EAAS6F,EACTG,EAAWR,EAAcxF,CAAM,EACrC,UAAWiG,KAAM5B,EAAc,CAC7B,MAAM6B,GAAUvB,EAAUsB,EAAI3G,CAAS,EACvC,QAAS9L,EAAI,EAAGA,EAAIwM,EAAO,OAAQxM,IAAK,CACtC,MAAMoF,GAAOoH,EAAOxM,CAAC,EACfoS,GAAMpS,EAAI0S,GAAQ,OAASA,GAAQ1S,CAAC,EAAI,GACxCD,GAAQ6L,EAAW,IAAIwG,EAAG,EAAI,KAAOA,GAC3CI,EAASpN,EAAI,EAAE,KAAKrF,EAAK,CAC3B,CACF,CACA,MAAMwN,EAAgBmE,EAAWc,EAAUhG,EAAQf,CAAO,EAC1DkF,EAAS,CAAE,OAAAnE,EAAQ,UAAAV,EAAW,WAAAF,EAAY,cAAA2B,CAAa,EACvDyD,EAAYgB,EAAcxF,CAAM,EAChC,UAAWiG,KAAM5B,EAAc,CAC7B,MAAM6B,GAAUvB,EAAUsB,EAAI3G,CAAS,EACvCoG,EAAcQ,GAAS/B,CAAM,CAC/B,CAEA,GADAE,EAAe,CAAA,EACX3D,GAAYoD,EAAW,CACzB,MAAMpQ,EAAS,CAAE,OAAQyQ,EAAO,OAAQ,WAAYK,EAAW,cAAeL,EAAO,aAAa,EAClG,OAAAK,EAAYgB,EAAcrB,EAAO,MAAM,EACvCM,GAAoB/D,EACpBA,EAAW,EACJhN,CACT,CACA,OAAO,IACT,CACA,MAAMyN,EAASwD,EAAUC,EAAMT,EAAO,SAAS,EAE/C,GADAuB,EAAcvE,EAAQgD,CAAM,EACxBzD,GAAYoD,EAAW,CACzB,MAAMpQ,EAAS,CAAE,OAAQyQ,EAAO,OAAQ,WAAYK,EAAW,cAAeL,EAAO,aAAa,EAClG,OAAAK,EAAYgB,EAAcrB,EAAO,MAAM,EACvCM,GAAoB/D,EACpBA,EAAW,EACJhN,CACT,CACA,OAAO,IACT,CACA,gBAAiByS,KAAYlC,EAAQ,CACnCG,GAAU+B,EACV,IAAIrG,EAAY,EAChB,QAAStM,EAAI,EAAGA,EAAI4Q,EAAO,OAAQ5Q,IAAK,CACtC,MAAM0N,EAAKkD,EAAO5Q,CAAC,EACnB,GAAI0N,IAAO,IACTD,EAAW,CAACA,UACH,CAACA,IAAaC,IAAO;AAAA,GAAQA,IAAO,MAAO,CACpD,MAAM0D,EAAOR,EAAO,MAAMtE,EAAWtM,CAAC,EAKtC,GAJI0N,IAAO,MAAQ1N,EAAI,EAAI4Q,EAAO,QAAUA,EAAO5Q,EAAI,CAAC,IAAM;AAAA,GAC5DA,IAEFsM,EAAYtM,EAAI,EACZoR,EAAK,OAAS,EAAG,CACnB,GAAIF,IAAU,QAAUD,EAAmB/D,GAAYgE,EACrD,MAEF,MAAMhR,EAASqS,EAAYnB,CAAI,EAC/B,GAAIlR,IACF,MAAMA,EACFgR,IAAU,QAAUD,GAAoBC,GAAO,CACjDT,EAAO,QAAO,EACd,MACF,CAEJ,CACF,CACF,CAEA,GADAG,EAASA,EAAO,MAAMtE,CAAS,EAC3B4E,IAAU,QAAUD,GAAoBC,EAAO,CACjDT,EAAO,QAAO,EACd,MACF,CACF,CACIG,EAAO,OAAS,GAAK,EAAEM,IAAU,QAAUD,GAAoBC,KAC7D,CAACxF,GAAW,CAACkF,EAAO,UAAS,EAAG,WAAWlF,CAAO,IACpD6G,EAAY3B,CAAM,EAGtB,MAAMgC,EAAcjC,EACpB,GAAIzD,EAAW,GAAK0F,IAAgB,KAAM,CACxC,GAAI1B,IAAU,OAAQ,CACpB,MAAM2B,EAAY3B,EAAQD,EAC1B,GAAI4B,GAAa,EAAG,OACpB,GAAIA,EAAY3F,EACd,UAAW9H,KAAQwN,EAAY,OAC7B5B,EAAU5L,CAAI,EAAI4L,EAAU5L,CAAI,EAAE,MAAM,EAAGyN,CAAS,CAG1D,CACA,KAAM,CAAE,OAAQD,EAAY,OAAQ,WAAY5B,EAAW,cAAe4B,EAAY,aAAa,CACrG,CACF,CACA,SAAShB,GAAiB/P,EAAG,CAC3B,GAAIA,EAAE,SAAW,EAAG,MAAO,GAC3B,MAAM2C,EAAI,OAAO3C,CAAC,EAClB,MAAO,CAAC,OAAO,MAAM2C,CAAC,GAAK3C,EAAE,KAAI,EAAG,OAAS,CAC/C,CACA,SAASgQ,GAAiBhQ,EAAG,CAC3B,GAAI,CAAC+P,GAAiB/P,CAAC,EAAG,MAAO,GACjC,MAAM2C,EAAI,OAAO3C,CAAC,EAClB,OAAO,OAAO,UAAU2C,CAAC,GAAK,CAAC3C,EAAE,SAAS,GAAG,GAAK,CAACA,EAAE,SAAS,GAAG,GAAK,CAACA,EAAE,SAAS,GAAG,CACvF,CACA,SAASiQ,GAAiBjQ,EAAG,CAC3B,MAAM2N,EAAQ3N,EAAE,YAAW,EAC3B,OAAO2N,IAAU,QAAUA,IAAU,OACvC,CACA,IAAIsD,GAAe,2EACnB,SAASf,GAAclQ,EAAG,CACxB,GAAI,CAACiR,GAAa,KAAKjR,CAAC,EAAG,MAAO,GAClC,MAAM6B,EAAI,IAAI,KAAK7B,CAAC,EACpB,MAAO,CAAC,OAAO,MAAM6B,EAAE,QAAO,CAAE,CAClC,CAGA,eAAgBqP,GAAiB1C,EAAU5E,EAAU,GAAI,CACvD,MAAM6E,EAAY7E,EAAQ,WAAa,IACjCyF,EAAQzF,EAAQ,MAChB8E,EAAK,KAAM,QAAO,uCAAI,EACtB,CAAE,iBAAAC,CAAgB,EAAKD,EAC7B,IAAIE,EACJ,GAAI,CACFA,EAASD,EAAiBH,EAAU,CAAE,SAAU5E,EAAQ,UAAY,QAAS,CAC/E,OAASiF,EAAK,CACZ,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,+BAA+B+Q,CAAQ,MAAMtR,CAAO,EAAE,CAC1E,CACA,IAAI6R,EAAS,GACToC,EAAQ,CAAA,EACRC,EAAe,EACnB,gBAAiBN,KAAYlC,EAAQ,CACnCG,GAAU+B,EACV,IAAIrG,EAAY,EAChB,QAAStM,EAAI,EAAGA,EAAI4Q,EAAO,OAAQ5Q,IAAK,CACtC,MAAM0N,EAAKkD,EAAO5Q,CAAC,EACnB,GAAI0N,IAAO;AAAA,GAAQA,IAAO,KAAM,CAC9B,MAAM0D,EAAOR,EAAO,MAAMtE,EAAWtM,CAAC,EAKtC,GAJI0N,IAAO,MAAQ1N,EAAI,EAAI4Q,EAAO,QAAUA,EAAO5Q,EAAI,CAAC,IAAM;AAAA,GAC5DA,IAEFsM,EAAYtM,EAAI,EACZoR,EAAK,OAAO,OAAS,IACvB4B,EAAM,KAAK,KAAK,MAAM5B,CAAI,CAAC,EACvB4B,EAAM,QAAU1C,IAClB,MAAM0C,EACNC,GAAgBD,EAAM,OACtBA,EAAQ,CAAA,EACJ9B,IAAU,QAAU+B,GAAgB/B,IAAO,CAC7CT,EAAO,QAAO,EACd,MACF,CAGN,CACF,CACAG,EAASA,EAAO,MAAMtE,CAAS,CACjC,CAIA,GAHIsE,EAAO,OAAO,OAAS,GACzBoC,EAAM,KAAK,KAAK,MAAMpC,CAAM,CAAC,EAE3BoC,EAAM,OAAS,EAAG,CACpB,GAAI9B,IAAU,OAAQ,CACpB,MAAM2B,EAAY3B,EAAQ+B,EAC1B,GAAIJ,GAAa,EAAG,OAChBA,EAAYG,EAAM,SACpBA,EAAQA,EAAM,MAAM,EAAGH,CAAS,EAEpC,CACA,MAAMG,CACR,CACF,CAGA,SAASE,GAAU1G,EAAQmD,EAAMlE,EAAU,CAAA,EAAI,CAC7C,MAAM0H,EAAU,CAAA,EAChB,UAAWjD,KAAOP,EAAM,CACtB,MAAMyD,EAAM,CAAA,EACZ,QAAS,EAAI,EAAG,EAAI5G,EAAO,OAAQ,IAAK,CACtC,MAAMzM,EAAQmQ,EAAI,CAAC,EACfnQ,aAAiB,KACnBqT,EAAI5G,EAAO,CAAC,CAAC,EAAIzM,EAAM,YAAW,EAElCqT,EAAI5G,EAAO,CAAC,CAAC,EAAIzM,GAAS,IAE9B,CACAoT,EAAQ,KAAKC,CAAG,CAClB,CACA,OAAI3H,EAAQ,OACH,KAAK,UAAU0H,EAAS,KAAM,CAAC,EAEjC,KAAK,UAAUA,CAAO,CAC/B,CACA,SAASE,GAAY7G,EAAQmD,EAAM,CACjC,MAAMK,EAAQ,CAAA,EACd,UAAWE,KAAOP,EAAM,CACtB,MAAMyD,EAAM,CAAA,EACZ,QAASpT,EAAI,EAAGA,EAAIwM,EAAO,OAAQxM,IAAK,CACtC,MAAMD,EAAQmQ,EAAIlQ,CAAC,EACfD,aAAiB,KACnBqT,EAAI5G,EAAOxM,CAAC,CAAC,EAAID,EAAM,YAAW,EAElCqT,EAAI5G,EAAOxM,CAAC,CAAC,EAAID,GAAS,IAE9B,CACAiQ,EAAM,KAAK,KAAK,UAAUoD,CAAG,CAAC,CAChC,CACA,OAAOpD,EAAM,KAAK;AAAA,CAAI,EAAI;AAAA,CAC5B,CAGA,SAASsD,GAAgBvT,EAAO,CAE9B,OADIA,GAAU,MACV,OAAOA,GAAU,SAAiB,MAClC,OAAOA,GAAU,UAAkB,OACnCA,aAAiB,KAAa,OAC9B,OAAOA,GAAU,SAAiB,OAClC,OAAOA,GAAU,SAAiB,SAC/B,MACT,CACA,SAASwT,GAAaC,EAAK,CACzB,MAAMpQ,EAAQ,kBAAkB,KAAKoQ,EAAI,YAAW,CAAE,EACtD,GAAI,CAACpQ,EAAO,MAAM,IAAI9D,EAAQ,4BAA4BkU,CAAG,GAAG,EAChE,MAAMC,EAASrQ,EAAM,CAAC,EAChBsQ,EAAS,SAAStQ,EAAM,CAAC,EAAG,EAAE,EACpC,IAAIuQ,EAAS,EACb,QAAS3T,EAAI,EAAGA,EAAIyT,EAAO,OAAQzT,IACjC2T,EAASA,EAAS,IAAMF,EAAO,WAAWzT,CAAC,EAAI,IAEjD,MAAO,CAAE,IAAK2T,EAAQ,IAAKD,CAAM,CACnC,CACA,SAASE,GAAWC,EAAO,CACzB,MAAMC,EAAQD,EAAM,MAAM,GAAG,EAC7B,GAAIC,EAAM,SAAW,EAAG,MAAM,IAAIxU,EAAQ,0BAA0BuU,CAAK,mCAAmC,EAC5G,MAAMrT,EAAQ+S,GAAaO,EAAM,CAAC,CAAC,EAC7BrT,EAAM8S,GAAaO,EAAM,CAAC,CAAC,EACjC,MAAO,CAAE,SAAUtT,EAAM,IAAK,SAAUA,EAAM,IAAK,OAAQC,EAAI,IAAK,OAAQA,EAAI,GAAG,CACrF,CACA,SAASsT,GAAaC,EAAUC,EAAO,CACrC,GAAIA,IAAU,QAAUA,IAAU,EAAG,CACnC,MAAMC,EAAMF,EAAS,WAAW,CAAC,EACjC,GAAI,CAACE,EAAK,MAAM,IAAI5U,EAAQ,iCAAiC,EAC7D,OAAO4U,CACT,CACA,GAAI,OAAOD,GAAU,SAAU,CAC7B,MAAMC,EAAMF,EAAS,WAAWC,CAAK,EACrC,GAAI,CAACC,EAAK,MAAM,IAAI5U,EAAQ,sBAAsB,OAAO2U,CAAK,CAAC,YAAY,EAC3E,OAAOC,CACT,CACA,MAAMC,EAAKH,EAAS,aAAaC,CAAK,EACtC,GAAI,CAACE,EAAI,MAAM,IAAI7U,EAAQ,cAAc2U,CAAK,aAAa,EAC3D,OAAOE,CACT,CACA,SAASC,GAAmBrU,EAAO,CACjC,GAAIA,GAAU,KAA0B,OAAO,KAC/C,GAAI,OAAOA,GAAU,UAAYA,IAAU,MAAQ,CAAC,MAAM,QAAQA,CAAK,GAAK,EAAEA,aAAiB,MAAO,CACpG,GAAI,aAAcA,EAChB,OAAOA,EAAM,SAAS,IAAK,GAAM,OAAO,EAAE,IAAI,CAAC,EAAE,KAAK,EAAE,EAE1D,GAAI,WAAYA,EACd,OAAOA,EAAM,MAEjB,CACA,OAAOA,CACT,CACA,SAASsU,GAAoBC,EAAW7I,EAAU,GAAI,CACpD,MAAME,EAAYF,EAAQ,YAAc,GAClC8I,EAAW9I,EAAQ,MACzB,IAAI+I,EACAC,EACAC,EACAC,EACJ,GAAIJ,EAAU,CACZ,MAAM3N,EAAIgN,GAAWW,CAAQ,EAC7BC,EAAW5N,EAAE,SACb6N,EAAS7N,EAAE,OACX8N,EAAW9N,EAAE,SACb+N,EAAS/N,EAAE,MACb,MACE4N,EAAW,EACXC,EAASH,EAAU,SACnBI,EAAW,EACXC,EAASL,EAAU,YAErB,GAAIG,EAASD,GAAYG,EAASD,EAChC,MAAO,CAAE,OAAQ,CAAA,EAAI,QAAS,CAAA,EAAI,cAAe,EAAE,EAErD,MAAME,EAAU,CAAA,EAChB,QAAShO,EAAI4N,EAAU5N,GAAK6N,EAAQ7N,IAAK,CACvC,MAAMsJ,EAAMoE,EAAU,OAAO1N,CAAC,EACxBiO,EAAY,CAAA,EAClB,QAAStI,EAAImI,EAAUnI,GAAKoI,EAAQpI,IAAK,CACvC,MAAMuI,EAAO5E,EAAI,QAAQ3D,CAAC,EAC1BsI,EAAU,KAAKT,GAAmBU,EAAK,KAAK,CAAC,CAC/C,CACAF,EAAQ,KAAKC,CAAS,CACxB,CACA,IAAIrI,EACAuI,EACJ,GAAIpJ,GAAaiJ,EAAQ,OAAS,EAChCpI,EAASoI,EAAQ,CAAC,EAAE,IAAI,CAACzT,EAAGnB,IACtBmB,GAAM,KAA6B,UAAU,OAAOnB,CAAC,CAAC,GACtD,OAAOmB,GAAM,SAAiBA,EAC9B,OAAOA,GAAM,UAAY,OAAOA,GAAM,WAAa,OAAOA,GAAM,SAAiB,OAAOA,CAAC,EACzFA,aAAa,KAAaA,EAAE,YAAW,EACpC,UAAU,OAAOnB,CAAC,CAAC,EAC3B,EACD+U,EAAe,MACV,CACL,MAAMC,EAAWL,EAASD,EAAW,EACrClI,EAAS,MAAM,KAAK,CAAE,OAAQwI,CAAQ,EAAI,CAACpI,EAAG5M,IAAM,UAAU,OAAOA,CAAC,CAAC,EAAE,EACzE+U,EAAe,CACjB,CACA,MAAMxO,EAAU,CAAA,EAChB,UAAWnB,KAAQoH,EACjBjG,EAAQnB,CAAI,EAAI,CAAA,EAElB,QAASpF,EAAI+U,EAAc/U,EAAI4U,EAAQ,OAAQ5U,IAAK,CAClD,MAAMkQ,EAAM0E,EAAQ5U,CAAC,EACrB,QAASiV,EAAI,EAAGA,EAAIzI,EAAO,OAAQyI,IAAK,CACtC,MAAMC,EAAU1I,EAAOyI,CAAC,EACxB1O,EAAQ2O,CAAO,EAAE,KAAKD,EAAI/E,EAAI,OAASA,EAAI+E,CAAC,GAAK,KAAO,IAAI,CAC9D,CACF,CACA,MAAM1H,EAAgB,CAAA,EACtB,UAAWnI,KAAQoH,EACjB,GAAIf,EAAQ,SAASrG,CAAI,IAAM,OAC7BmI,EAAcnI,CAAI,EAAIqG,EAAQ,OAAOrG,CAAI,MACpC,CACL,MAAM+P,EAAY5O,EAAQnB,CAAI,EAC9B,IAAIgQ,EAAW,MACf,UAAWjU,KAAKgU,EACd,GAAIhU,GAAM,KAAsB,CAC9BiU,EAAW9B,GAAgBnS,CAAC,EAC5B,KACF,CAEFoM,EAAcnI,CAAI,EAAIgQ,CACxB,CAEF,MAAO,CAAE,OAAA5I,EAAQ,QAAAjG,EAAS,cAAAgH,CAAa,CACzC,CACA,eAAe8H,GAAchF,EAAU5E,EAAU,GAAI,CACnD,IAAI6J,EACJ,GAAI,CACFA,EAAU,KAAM,QAAO,2BAAS,EAAA,KAAA,SAAA9Q,EAAA,CAAA,OAAAA,EAAA,CAAA,CAAA,CAClC,MAAQ,CACN,MAAM,IAAIlF,EACR,wFACN,CACE,CACA,GAAI,CACF,MAAM0U,EAAW,IAAIsB,EAAQ,SAC7B,MAAMtB,EAAS,KAAK,SAAS3D,CAAQ,EACrC,MAAMiE,EAAYP,GAAaC,EAAUvI,EAAQ,KAAK,EACtD,OAAO4I,GAAoBC,EAAW7I,CAAO,CAC/C,OAASiF,EAAK,CACZ,GAAIA,aAAepR,EAAS,MAAMoR,EAClC,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,8BAA8B+Q,CAAQ,MAAMtR,CAAO,EAAE,CACzE,CACF,CAGA,SAASwW,GAAiBC,EAAO,CAE/B,MAAMhG,GADUgG,EAAM,MAAM,WAAQ,GAAQ,OAAOA,EAAM,IAAI,GACvC,YAAW,EACjC,OAAIhG,EAAM,SAAS,OAAO,GAAKA,EAAM,SAAS,OAAO,GAAKA,EAAM,SAAS,MAAM,EACtE,MAELA,EAAM,SAAS,OAAO,GAAKA,EAAM,SAAS,KAAK,GAAKA,EAAM,SAAS,MAAM,GAGzEA,EAAM,SAAS,OAAO,GAAKA,EAAM,SAAS,QAAQ,GAAKA,EAAM,SAAS,SAAS,EAC1E,MAELA,EAAM,SAAS,MAAM,GAAKA,EAAM,SAAS,QAAQ,GAAKA,EAAM,SAAS,aAAa,GAAKA,EAAM,SAAS,WAAW,EAC5G,OAELA,IAAU,QAAUA,EAAM,SAAS,SAAS,EACvC,OAELA,EAAM,SAAS,MAAM,GAAKA,EAAM,SAAS,WAAW,EAC/C,OAEF,MACT,CACA,SAASiG,GAAoBxW,EAAQuH,EAAO/G,EAAQ,CAClD,MAAMwB,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIP,EAAQO,IAAK,CAC/B,GAAIf,EAAO,QAAQe,CAAC,IAAM,GAAO,CAC/BiB,EAAO,KAAK,IAAI,EAChB,QACF,CACA,IAAID,EAAM/B,EAAO,IAAIe,CAAC,EAClB,OAAOgB,GAAQ,WACjBA,EAAM,OAAOA,CAAG,GAEdwF,IAAU,QAAqB,OAAOxF,GAAQ,WAChDA,EAAM,IAAI,KAAKA,CAAG,GAEpBC,EAAO,KAAKD,CAAG,CACjB,CACA,OAAOC,CACT,CACA,eAAeyU,GAAgBrF,EAAU5E,EAAU,GAAI,CACrD,IAAIkK,EACJ,GAAI,CAEFA,EAAc,MAAM,OADD,eAErB,MAAQ,CACN,MAAM,IAAIrW,EACR,oGACN,CACE,CACA,GAAI,CAEF,MAAMsR,EAAS,MADJ,KAAM,QAAO,uCAAa,GACb,SAASP,CAAQ,EACnCuF,EAAQ,IAAI,WAAWhF,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAC1EiF,EAAaF,EAAY,YAAYC,CAAK,EAC1CjF,EAASkF,EAAW,OACpBC,EAAYnF,EAAO,WAAaA,EAAO,QAAQ,QAAU,EACzDoF,EAAUF,EAAW,SAAW,EAChCG,EAAY,CAAA,EAClB,QAAShW,EAAI,EAAGA,EAAI8V,EAAW9V,IAAK,CAClC,MAAMwV,EAAQ7E,EAAO,MAAM3Q,CAAC,EACtBoF,EAAO,OAAOoQ,EAAM,IAAI,EACxBhP,EAAQ+O,GAAiBC,CAAK,EACpCQ,EAAU,KAAK,CAAE,KAAA5Q,EAAM,MAAAoB,EAAO,MAAOxG,EAAG,CAC1C,CACA,MAAMiW,EAAiBxK,EAAQ,QAAUuK,EAAU,OAAQE,GAAMzK,EAAQ,QAAQ,SAASyK,EAAE,IAAI,CAAC,EAAIF,EAC/FxJ,EAAS,CAAA,EACTjG,EAAU,CAAA,EACVgH,EAAgB,CAAA,EACtB,UAAWiI,KAASS,EAAgB,CAClCzJ,EAAO,KAAKgJ,EAAM,IAAI,EACtBjI,EAAciI,EAAM,IAAI,EAAIA,EAAM,MAClC,MAAMW,EAAWN,EAAW,WAAWL,EAAM,KAAK,EAC9CW,EACF5P,EAAQiP,EAAM,IAAI,EAAIC,GAAoBU,EAAUX,EAAM,MAAOO,CAAO,EAExExP,EAAQiP,EAAM,IAAI,EAAI,IAAI,MAAMO,CAAO,EAAE,KAAK,IAAI,CAEtD,CACA,MAAO,CAAE,OAAAvJ,EAAQ,QAAAjG,EAAS,cAAAgH,CAAa,CACzC,OAASmD,EAAK,CACZ,GAAIA,aAAepR,EAAS,MAAMoR,EAClC,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,gCAAgC+Q,CAAQ,MAAMtR,CAAO,EAAE,CAC3E,CACF,CAGA,SAASqX,GAAc5C,EAAK,CAC1B,MAAMpQ,EAAQ,kBAAkB,KAAKoQ,EAAI,YAAW,CAAE,EACtD,GAAI,CAACpQ,EAAO,MAAM,IAAI9D,EAAQ,4BAA4BkU,CAAG,GAAG,EAChE,MAAMC,EAASrQ,EAAM,CAAC,EAChBsQ,EAAS,SAAStQ,EAAM,CAAC,EAAG,EAAE,EACpC,IAAIuQ,EAAS,EACb,QAAS3T,EAAI,EAAGA,EAAIyT,EAAO,OAAQzT,IACjC2T,EAASA,EAAS,IAAMF,EAAO,WAAWzT,CAAC,EAAI,IAEjD,MAAO,CAAE,IAAK2T,EAAQ,IAAKD,CAAM,CACnC,CACA,SAAS2C,GAAqBvT,EAAM,CAClC,IAAI5C,EAAS,GACT,EAAI4C,EACR,KAAO,EAAI,GAAG,CACZ,MAAMwT,GAAa,EAAI,GAAK,GAC5BpW,EAAS,OAAO,aAAa,GAAKoW,CAAS,EAAIpW,EAC/C,EAAI,KAAK,OAAO,EAAI,GAAK,EAAE,CAC7B,CACA,OAAOA,CACT,CACA,eAAeqW,GAAelG,EAAU7D,EAAQmD,EAAMlE,EAAU,CAAA,EAAI,CAClE,IAAI6J,EACJ,GAAI,CACFA,EAAU,KAAM,QAAO,2BAAS,EAAA,KAAA,SAAA9Q,EAAA,CAAA,OAAAA,EAAA,CAAA,CAAA,CAClC,MAAQ,CACN,MAAM,IAAIlF,EACR,yFACN,CACE,CACA,GAAI,CACF,MAAM0U,EAAW,IAAIsB,EAAQ,SACvBkB,EAAY/K,EAAQ,OAAS,SAC7B6I,EAAYN,EAAS,aAAawC,CAAS,EAC3CC,EAAYhL,EAAQ,WAAa,KACjC,CAAE,IAAKiJ,EAAU,IAAKF,CAAQ,EAAK4B,GAAcK,CAAS,EAChE,QAASzW,EAAI,EAAGA,EAAIwM,EAAO,OAAQxM,IAAK,CAEtC,MAAM0W,EAAU,GADEL,GAAqB3B,EAAW1U,CAAC,CACvB,GAAG,OAAOwU,CAAQ,CAAC,GAC/CF,EAAU,QAAQoC,CAAO,EAAE,MAAQlK,EAAOxM,CAAC,CAC7C,CACA,QAAS4G,EAAI,EAAGA,EAAI+I,EAAK,OAAQ/I,IAAK,CACpC,MAAMsJ,EAAMP,EAAK/I,CAAC,EAClB,QAAS2F,EAAI,EAAGA,EAAIC,EAAO,OAAQD,IAAK,CAEtC,MAAMmK,EAAU,GADEL,GAAqB3B,EAAWnI,CAAC,CACvB,GAAG,OAAOiI,EAAW,EAAI5N,CAAC,CAAC,GACjD7G,EAAQwM,EAAI2D,EAAI,OAASA,EAAI3D,CAAC,EAAI,KACxC+H,EAAU,QAAQoC,CAAO,EAAE,MAAQ3W,GAAqC,IAC1E,CACF,CACA,GAAI0L,EAAQ,WAAY,CACtB,MAAMkL,EAAgBN,GAAqB3B,EAAWlI,EAAO,OAAS,CAAC,EACjEoK,EAAUpC,EAAW7E,EAAK,OAChC2E,EAAU,WAAa,GAAG+B,GAAqB3B,CAAQ,CAAC,GAAG,OAAOF,CAAQ,CAAC,IAAImC,CAAa,GAAG,OAAOC,CAAO,CAAC,EAChH,CACA,GAAInL,EAAQ,YAAa,CACvB,MAAMoL,EAAYpL,EAAQ,YAAY,IAChCqL,EAAYrL,EAAQ,YAAY,IACtC6I,EAAU,MAAQ,CAChB,CACE,MAAO,SACP,OAAQwC,EACR,OAAQtC,EAAW,EAAIqC,EACvB,YAAa,GAAGR,GAAqB3B,EAAWoC,CAAS,CAAC,GAAG,OAAOtC,EAAWqC,CAAS,CAAC,GACzF,WAAY,GAAGR,GAAqB3B,CAAQ,CAAC,GAAG,OAAOF,CAAQ,CAAC,EAC1E,CACA,CACI,CACA,GAAI/I,EAAQ,aACV,QAASzL,EAAI,EAAGA,EAAIwM,EAAO,OAAQxM,IAAK,CACtC,MAAMkV,EAAU1I,EAAOxM,CAAC,EAClB+W,EAAQtL,EAAQ,aAAayJ,CAAO,EAC1C,GAAI6B,IAAU,OAAQ,CACpB,MAAMjU,EAAOwR,EAAU,UAAUI,EAAW1U,CAAC,EAC7C8C,EAAK,MAAQiU,CACf,CACF,CAEF,MAAM/C,EAAS,KAAK,UAAU3D,CAAQ,CACxC,OAASK,EAAK,CACZ,GAAIA,aAAepR,EAAS,MAAMoR,EAClC,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,+BAA+B+Q,CAAQ,MAAMtR,CAAO,EAAE,CAC1E,CACF,CAGA,SAASiY,GAAiBC,EAAOzQ,EAAO,CACtC,OAAQA,EAAK,CACX,IAAK,MACH,OAAO,IAAIyQ,EAAM,QACnB,IAAK,MACH,OAAO,IAAIA,EAAM,MACnB,IAAK,OACH,OAAO,IAAIA,EAAM,KACnB,IAAK,OACH,OAAO,IAAIA,EAAM,KACnB,IAAK,OACL,IAAK,WACH,OAAO,IAAIA,EAAM,gBACnB,QACE,OAAO,IAAIA,EAAM,IACvB,CACA,CACA,SAASC,GAAajW,EAAQuF,EAAO,CACnC,OAAQA,EAAK,CACX,IAAK,MACL,IAAK,MACH,OAAOvF,EAAO,IAAKE,GAAMA,GAAM,KAAuB,KAAO,OAAOA,CAAC,CAAC,EACxE,IAAK,OACH,OAAOF,EAAO,IAAKE,GACbA,GAAM,KAA6B,KACnC,OAAOA,GAAM,SAAiBA,EAC9B,OAAOA,GAAM,UAAY,OAAOA,GAAM,WAAa,OAAOA,GAAM,SAAiB,OAAOA,CAAC,EACtF,OAAOA,GAAM,SAAW,KAAK,UAAUA,CAAC,EAAI,OAAOA,CAAC,CAC5D,EACH,IAAK,OACH,OAAOF,EAAO,IAAKE,GAAMA,GAAM,KAAuB,KAAO,EAAQA,CAAE,EACzE,IAAK,OACL,IAAK,WACH,OAAOF,EAAO,IAAKE,GACbA,GAAM,KAA6B,KACnCA,aAAa,KAAaA,EAAE,QAAO,EACnC,OAAOA,GAAM,SAAiBA,EAC3B,IACR,EACH,QACE,OAAOF,EAAO,IAAKE,GACbA,GAAM,KAA6B,KACnC,OAAOA,GAAM,SAAiBA,EAC9B,OAAOA,GAAM,UAAY,OAAOA,GAAM,WAAa,OAAOA,GAAM,SAC3D,OAAOA,CAAC,EAEV,OAAOA,GAAM,SAAW,KAAK,UAAUA,CAAC,EAAI,OAAOA,CAAC,CAC5D,CACP,CACA,CACA,SAASgW,GAAmBxB,EAAayB,EAAa,CACpD,MAAMC,EAAc1B,EAAY,YAChC,GAAI,CAAC0B,EAAa,OAAOD,EAAY,YAAW,EAChD,OAAQA,EAAW,CACjB,IAAK,SACH,OAAOC,EAAY,OACrB,IAAK,OACH,OAAOA,EAAY,KACrB,IAAK,OACH,OAAOA,EAAY,KACrB,IAAK,OACH,OAAOA,EAAY,YACzB,CACA,CACA,eAAeC,GAAiBjH,EAAU7D,EAAQjG,EAASkF,EAAU,CAAA,EAAI,CACvE,IAAIkK,EACJ,GAAI,CAEFA,EAAc,MAAM,OADD,eAErB,MAAQ,CACN,MAAM,IAAIrW,EACR,qGACN,CACE,CACA,IAAI2X,EACJ,GAAI,CAEFA,EAAQ,MAAM,OADM,eAEtB,MAAQ,CACN,MAAM,IAAI3X,EACR,qGACN,CACE,CACA,GAAI,CACF,MAAMqO,EAAS,CAAA,EACT4J,EAAe,CAAA,EACrB,UAAWnS,KAAQoH,EAAQ,CACzB,MAAM1J,EAAOyD,EAAQnB,CAAI,EACnBoS,EAAYR,GAAiBC,EAAOnU,EAAK,KAAK,EACpD6K,EAAO,KAAK,IAAIsJ,EAAM,MAAM7R,EAAMoS,EAAW,EAAI,CAAC,EAClD,MAAMC,EAAUP,GAAapU,EAAK,OAAQA,EAAK,KAAK,EACpDyU,EAAanS,CAAI,EAAI6R,EAAM,gBAAgBQ,EAASD,CAAS,CAC/D,CACA,MAAM7G,EAAS,IAAIsG,EAAM,OAAOtJ,CAAM,EAChCkI,EAAa,IAAIoB,EAAM,MAAMtG,EAAQ4G,CAAY,EACjDG,EAAWT,EAAM,WAAWpB,EAAY,QAAQ,EAChD8B,EAAYhC,EAAY,MAAM,cAAc+B,CAAQ,EACpDN,EAAc3L,EAAQ,aAAe,SACrCmM,EAAsBT,GAAmBxB,EAAayB,CAAW,EACvE,IAAIS,EAAU,IAAIlC,EAAY,wBAC9BkC,EAAUA,EAAQ,eAAeD,CAAmB,EAChDnM,EAAQ,eAAiB,SAC3BoM,EAAUA,EAAQ,mBAAmBpM,EAAQ,YAAY,GAE3D,MAAMqM,EAAmBD,EAAQ,MAAK,EAChCE,EAAepC,EAAY,aAAagC,EAAWG,CAAgB,EAEzE,MADW,KAAM,QAAO,uCAAa,GAC5B,UAAUzH,EAAU0H,CAAY,CAC3C,OAASrH,EAAK,CACZ,GAAIA,aAAepR,EAAS,MAAMoR,EAClC,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,iCAAiC+Q,CAAQ,MAAMtR,CAAO,EAAE,CAC5E,CACF,CAGA,SAASiZ,GAAkBf,EAAOzQ,EAAO,CACvC,OAAQA,EAAK,CACX,IAAK,MACH,OAAO,IAAIyQ,EAAM,QACnB,IAAK,MACH,OAAO,IAAIA,EAAM,MACnB,IAAK,OACH,OAAO,IAAIA,EAAM,KACnB,IAAK,OACH,OAAO,IAAIA,EAAM,KACnB,IAAK,OACL,IAAK,WACH,OAAO,IAAIA,EAAM,gBACnB,QACE,OAAO,IAAIA,EAAM,IACvB,CACA,CACA,SAASgB,GAAYlY,EAAOyG,EAAO,CACjC,GAAIzG,GAAU,KAA0B,OAAO,KAC/C,OAAQyG,EAAK,CACX,IAAK,MACL,IAAK,MACH,OAAO,OAAOzG,CAAK,EACrB,IAAK,OACH,MAAO,EAAQA,EACjB,IAAK,OACL,IAAK,WACH,OAAIA,aAAiB,KAAaA,EAAM,QAAO,EAC3C,OAAOA,GAAU,SAAiBA,EAC/B,IAAI,KAAKA,CAAK,EAAE,QAAO,EAEhC,QACE,OAAI,OAAOA,GAAU,SAAiBA,EAClC,OAAOA,GAAU,UAAY,OAAOA,GAAU,WAAa,OAAOA,GAAU,SAAiB,OAAOA,CAAK,EACtG,OAAOA,GAAU,SAAW,KAAK,UAAUA,CAAK,EAAI,OAAOA,CAAK,CAC7E,CACA,CACA,eAAemY,GAAaC,EAAO,CACjC,IAAIlB,EACJ,GAAI,CAEFA,EAAQ,MAAM,OADK,eAErB,MAAQ,CACN,MAAM,IAAI3X,EACR,gGACN,CACE,CACA,KAAM,CAAE,YAAA8Y,EAAa,gBAAAC,CAAe,EAAKF,EACnCG,EAAY,CAAA,EAClB,UAAWlT,KAAQgT,EAAa,CAC9B,KAAM,CAAE,OAAAnX,EAAQ,MAAAuF,GAAU6R,EAAgBjT,CAAI,EACxCoS,EAAYQ,GAAkBf,EAAOzQ,CAAK,EAC1CiR,EAAUxW,EAAO,IAAKE,GAAM8W,GAAY9W,EAAGqF,CAAK,CAAC,EACvD8R,EAAUlT,CAAI,EAAI6R,EAAM,gBAAgBQ,EAASD,CAAS,CAC5D,CACA,OAAO,IAAIP,EAAM,MAAMqB,CAAS,CAClC,CAGA,SAASC,GAAkB/C,EAAO,CAChC,MAAMgD,EAAShD,EAAM,MAAM,OACrBiD,EAAU,OAAOjD,EAAM,MAAQ,EAAE,EACvC,OAAQgD,EAAM,CACZ,IAAK,GACH,MAAO,MACT,IAAK,GACH,MAAO,MACT,IAAK,GACH,MAAO,OACT,IAAK,GACH,MAAO,OACT,IAAK,GAEL,IAAK,IACH,MAAO,OACT,IAAK,GACH,OAAIC,EAAQ,SAAS,MAAM,EAAU,OAEvC,QACE,OAAIA,EAAQ,SAAS,KAAK,EAAU,MAChCA,EAAQ,SAAS,OAAO,EAAU,MAClCA,EAAQ,SAAS,MAAM,GAAKA,EAAQ,SAAS,MAAM,EAAU,OAC7DA,EAAQ,SAAS,MAAM,EAAU,OACjCA,EAAQ,SAAS,MAAM,GAAKA,EAAQ,SAAS,WAAW,EAAU,OAC/D,MACb,CACA,CACA,SAASC,GAAeC,EAAO,CAC7B,GAAI,CAACA,GAAS,CAACA,EAAM,QAAU,CAACA,EAAM,OAAO,OAC3C,MAAM,IAAIrZ,EAAQ,+CAA+C,EAEnE,MAAMkN,EAAS,CAAA,EACTjG,EAAU,CAAA,EACVgH,EAAgB,CAAA,EAChBwI,EAAU,OAAO4C,EAAM,OAAO,EAC9BhL,EAASgL,EAAM,OAAO,OAC5B,UAAWnD,KAAS7H,EAAQ,CAC1B,MAAMvI,EAAO,OAAOoQ,EAAM,IAAI,EAC9BhJ,EAAO,KAAKpH,CAAI,EAChB,MAAMoB,EAAQ+R,GAAkB/C,CAAK,EACrCjI,EAAcnI,CAAI,EAAIoB,EACtB,MAAMvH,EAAS0Z,EAAM,SAASvT,CAAI,EAC5BnE,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAI+V,EAAS/V,IAAK,CAChC,MAAMgB,EAAM/B,EAAO,IAAIe,CAAC,EACpBgB,GAAQ,KACVC,EAAO,KAAK,IAAI,EACPuF,IAAU,QAAqB,OAAOxF,GAAQ,SACvDC,EAAO,KAAK,IAAI,KAAKD,CAAG,CAAC,EAEzBC,EAAO,KAAKD,CAAG,CAEnB,CACAuF,EAAQnB,CAAI,EAAInE,CAClB,CACA,MAAO,CAAE,OAAAuL,EAAQ,QAAAjG,EAAS,cAAAgH,CAAa,CACzC,CAMA,IAAIqL,GAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiMdC,GAAoB,IACpBC,GAAqB,KAAK,IAAI,EAAGta,GAAG,KAAI,EAAG,OAAS,CAAC,EACrDua,GAAyB,KAC7B,SAASC,IAA+B,CACtC,OAAID,KAA2B,KACtB,GAEFA,EACT,CACA,SAASE,GAAkB/L,EAAUzB,EAAS,CAC5C,MAAMyN,EAAYzN,GAAS,WAAaoN,GAExC,OADI3L,EAAWgM,GACX,CAACF,GAA4B,EAAW,IACxBvN,GAAS,aAAeqN,IACvB,CACvB,CACA,SAASK,GAAgB/T,EAAMnG,EAAQ,CACrC,MAAMwC,EAAMxC,EAAO,OACnB,IAAImB,EAAW,KACf,GAAInB,EAAO,UAAY,EAAG,CACxB,MAAMma,EAAY,IAAI,WAAW,KAAK,KAAK3X,EAAM,CAAC,CAAC,EACnD,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACnBf,EAAO,IAAIe,CAAC,IAAM,OACpBoZ,EAAUpZ,GAAK,CAAC,GAAK,IAAMA,EAAI,IAGnCI,EAAWgZ,EAAU,MACvB,CACA,OAAQna,EAAO,MAAK,CAClB,IAAK,MACL,IAAK,OAAmB,CACtB,MAAMsE,EAAM,IAAI,aAAa9B,CAAG,EAChC,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,KACRoC,EAAIvD,CAAC,EAAI,EACAmB,aAAa,KACtBoC,EAAIvD,CAAC,EAAImB,EAAE,QAAO,EAElBoC,EAAIvD,CAAC,EAAImB,CAEb,CACA,MAAO,CACL,KAAAiE,EACA,MAAOnG,EAAO,QAAU,OAAoB,OAAS,UACrD,KAAMsE,EAAI,OACV,SAAAnD,EACA,OAAQqB,CAChB,CACI,CACA,IAAK,MAAmB,CACtB,MAAM8B,EAAM,IAAI,WAAW9B,CAAG,EAC9B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtBuD,EAAIvD,CAAC,EAAImB,IAAM,KAAO,EAAIA,CAC5B,CACA,MAAO,CACL,KAAAiE,EACA,MAAO,QACP,KAAM7B,EAAI,OACV,SAAAnD,EACA,OAAQqB,CAChB,CACI,CACA,IAAK,OAAsB,CACzB,MAAM8B,EAAM,IAAI,WAAW9B,CAAG,EAC9B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtBuD,EAAIvD,CAAC,EAAImB,IAAM,KAAO,EAAIA,EAAI,EAAI,CACpC,CACA,MAAO,CACL,KAAAiE,EACA,MAAO,UACP,KAAM7B,EAAI,OACV,SAAAnD,EACA,OAAQqB,CAChB,CACI,CAEA,QAAS,CACP,MAAM8B,EAAM,CAAA,EACZ,QAASvD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,KACRoC,EAAI,KAAK,EAAE,EACF,OAAOpC,GAAM,SACtBoC,EAAI,KAAKpC,CAAC,EACD,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAC/CoC,EAAI,KAAK,OAAOpC,CAAC,CAAC,EAElBoC,EAAI,KAAK,EAAE,CAEf,CACA,MAAO,CACL,KAAA6B,EACA,MAAO,OACP,KAAM7B,EACN,SAAAnD,EACA,OAAQqB,CAChB,CACI,CACJ,CACA,CACA,SAAS4X,GAAgBC,EAAcC,EAAa,CAClD,MAAMC,EAAa,MAAM,KACvB,CAAE,OAAQD,CAAW,EACrB,IAAM,CAAA,CACV,EACE,QAASvZ,EAAI,EAAGA,EAAIsZ,EAAa,OAAQtZ,IAAK,CAC5C,KAAM,EAAGY,CAAO,EAAI0Y,EAAatZ,CAAC,EAClCwZ,EAAWxZ,EAAIuZ,CAAW,EAAE,KAAK,CAACvZ,EAAGY,CAAO,CAAC,CAC/C,CACA,OAAO4Y,CACT,CACA,eAAeC,GAAYH,EAAcI,EAAgBC,EAAYC,EAAUC,EAAepO,EAAS,CACrG,MAAMqO,EAAK,KAAM,QAAO,uCAAgB,EAClC,CAAE,OAAAC,CAAM,EAAKD,EACnBf,GAAyB,GACzB,MAAMQ,EAAc,KAAK,IACvB9N,GAAS,aAAeqN,GACxBQ,EAAa,MACjB,EACQU,EAAgC,IAAI,IAC1C,UAAWC,KAAWP,EACpBM,EAAc,IAAIC,CAAO,EAE3B,UAAWC,KAAQ,OAAO,OAAON,CAAQ,EACvCI,EAAc,IAAIE,EAAK,UAAU,EAEnC,MAAMC,EAAoB,CAAA,EAC1B,UAAWjF,KAAW8E,EAAe,CACnC,MAAM/a,EAAS4a,EAAc,IAAI3E,CAAO,EACpCjW,IACFkb,EAAkBjF,CAAO,EAAIiE,GAAgBjE,EAASjW,CAAM,EAEhE,CAEA,MAAMmb,EADaf,GAAgBC,EAAcC,CAAW,EAC1B,IAAKc,GACjCA,EAAU,SAAW,EAChB,QAAQ,QAAQ,CAAE,QAAS,CAAA,CAAE,CAAE,EAEjC,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,MAAMC,EAAS,IAAIT,EAAOnB,GAAa,CAAE,KAAM,GAAM,EAC/C7Z,EAAU,CACd,QAASob,EACT,OAAQE,EACR,SAAAT,EACA,WAAYF,CACpB,EACMc,EAAO,GAAG,UAAYta,GAAW,CAC1Bsa,EAAO,UAAS,EACrBF,EAAQpa,CAAM,CAChB,CAAC,EACDsa,EAAO,GAAG,QAAU9J,GAAQ,CACrB8J,EAAO,UAAS,EACrBD,EAAO7J,CAAG,CACZ,CAAC,EACD8J,EAAO,YAAYzb,CAAO,CAC5B,CAAC,CACF,EACKkE,EAAU,MAAM,QAAQ,IAAImX,CAAc,EAC1CK,EAAa,CAAA,EACnB,UAAWC,KAAgBzX,EACzBwX,EAAW,KAAK,GAAGC,EAAa,OAAO,EAEzC,OAAAD,EAAW,KAAK,CAACvW,EAAGC,IAAMD,EAAE,WAAaC,EAAE,UAAU,EAC9CsW,CACT,CAGG,IAACE,GAAU,KAAM,CAClB,IACA,MACA,UACA,YAAY1R,EAAK2R,EAAM,CACrB,KAAK,IAAM3R,EACX,KAAK,MAAQ2R,EACb,UAAW5U,KAAO4U,EAChB,GAAI,CAAC3R,EAAI,QAAQ,SAASjD,CAAG,EAC3B,MAAM,IAAIhH,EAAoBgH,EAAKiD,EAAI,OAAO,EAGlD,KAAK,UAA4B,IAAI,IACrC,MAAM1C,EAAUqU,EAAK,IAAKC,GAAM5R,EAAI,IAAI4R,CAAC,EAAE,MAAM,EACjD,GAAID,EAAK,SAAW,EAAG,CACrB,MAAM9X,EAAOyD,EAAQ,CAAC,EACtB,GAAIzD,aAAgBxB,GAAcwB,EAAK,WAAY,CACjD,MAAMtB,EAAWsB,EAAK,gBAChBgY,EAAkBtZ,EAAS,QAC3BuZ,EAAUvZ,EAAS,WAAW,OAC9BgD,EAAIyE,EAAI,OACR+R,EAAU,IAAI,MAAMD,CAAO,EACjC,QAASrX,EAAI,EAAGA,EAAIqX,EAASrX,IAC3BsX,EAAQtX,CAAC,EAAI,CAAA,EAEf,GAAIZ,EAAK,SACP,QAAS9C,EAAI,EAAGA,EAAIwE,EAAGxE,IACrBgb,EAAQF,EAAgB9a,CAAC,CAAC,EAAE,KAAKA,CAAC,MAE/B,CACL,MAAMI,EAAW0C,EAAK,SACtB,IAAImY,EAAa,KACjB,QAASjb,EAAI,EAAGA,EAAIwE,EAAGxE,IACjBI,EAAS,UAAUJ,CAAC,EACtBgb,EAAQF,EAAgB9a,CAAC,CAAC,EAAE,KAAKA,CAAC,GAE7Bib,IAAYA,EAAa,CAAA,GAC9BA,EAAW,KAAKjb,CAAC,GAGjBib,GACF,KAAK,UAAU,IAAI,SAAUA,CAAU,CAE3C,CACA,QAASvX,EAAI,EAAGA,EAAIqX,EAASrX,IAAK,CAChC,MAAMwX,EAASF,EAAQtX,CAAC,EACpBwX,EAAO,OAAS,GAClB,KAAK,UAAU,IAAI,WAAW1Z,EAAS,WAAWkC,CAAC,CAAC,GAAIwX,CAAM,CAElE,CACA,MACF,CACF,CACA,QAASlb,EAAI,EAAGA,EAAIiJ,EAAI,OAAQjJ,IAAK,CACnC,MAAMmb,EAAS,KAAK,cAAc5U,EAASvG,CAAC,EACtCob,EAAQ,KAAK,UAAU,IAAID,CAAM,EACnCC,EACFA,EAAM,KAAKpb,CAAC,EAEZ,KAAK,UAAU,IAAImb,EAAQ,CAACnb,CAAC,CAAC,CAElC,CACF,CACA,IAAI,MAAO,CACT,MAAO,CAAC,GAAG,KAAK,KAAK,CACvB,CACA,IAAI,WAAY,CACd,OAAO,KAAK,GACd,CACA,IAAI,UAAW,CACb,OAAO,KAAK,SACd,CACA,SAAU,CACR,OAAO,KAAK,UAAU,IACxB,CACA,IAAIqb,EAAO5P,EAAS,CAClB,OAAIA,GAAWwN,GAAkB,KAAK,IAAI,MAAM,IAC1BA,GAAkB,KAAK,IAAI,OAAQxN,CAAO,EAIzD,KAAK,SAAS4P,CAAK,CAC5B,CAKA,MAAM,SAASA,EAAO5P,EAAS,CAC7B,MAAM6P,EAAgB,CAAA,EACtB,SAAW,CAAClW,EAAM8U,CAAI,IAAK,OAAO,QAAQmB,CAAK,EACzC,OAAOnB,GAAS,SAClBoB,EAAclW,CAAI,EAAI,KAAK,kBAAkBA,EAAM8U,CAAI,EAEvDoB,EAAclW,CAAI,EAAI8U,EAI1B,GAAI,CADgBjB,GAAkB,KAAK,IAAI,OAAQxN,CAAO,EAE5D,OAAO,KAAK,SAAS4P,CAAK,EAE5B,MAAMzB,EAAW,CAAA,EACjB,SAAW,CAACxU,EAAMmW,CAAO,IAAK,OAAO,QAAQD,CAAa,EAAG,CAC3D,MAAME,EAAU,KAAK,eAAeD,CAAO,EAC3C,GAAI,CAACC,EACH,OAAO,KAAK,SAASH,CAAK,EAE5BzB,EAASxU,CAAI,EAAI,CACf,WAAYmW,EAAQ,aAAa,CAAC,EAClC,QAAAC,CACR,CACI,CACA,MAAM3B,EAAgC,IAAI,IAC1C,UAAW3E,KAAW,KAAK,IAAI,QAC7B2E,EAAc,IAAI3E,EAAS,KAAK,IAAI,IAAIA,CAAO,EAAE,MAAM,EAEzD,MAAMoE,EAAe,CAAC,GAAG,KAAK,UAAU,QAAO,CAAE,EAC3CmC,EAAU,KAAK,MAAM,IAAKZ,GAAM,KAAK,IAAI,IAAIA,CAAC,EAAE,MAAM,EACtD5X,EAAU,MAAMwW,GACpBH,EACA,CAAC,GAAG,KAAK,KAAK,EACdmC,EACA7B,EACAC,EACApO,CACN,EACUiQ,EAAUzY,EAAQ,OAClB0Y,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACpB,QAASwD,EAAK,EAAGA,EAAK,KAAK,MAAM,OAAQA,IAAM,CAC7C,MAAMf,EAAI,KAAK,MAAMe,CAAE,EACjBC,EAAO5Y,EAAQ,IAAK2D,GAAMA,EAAE,UAAUgV,CAAE,GAAK,IAAI,EACvDD,EAAc,IAAId,EAAG,KAAK,iBAAiBY,EAAQG,CAAE,EAAGC,CAAI,CAAC,EAC7DzD,EAAY,KAAKyC,CAAC,CACpB,CACA,MAAMiB,EAAW,OAAO,KAAKT,CAAK,EAClC,UAAWjW,KAAQ0W,EAAU,CAC3B,MAAMD,EAAO5Y,EAAQ,IAAK2D,GAAMA,EAAE,UAAUxB,CAAI,GAAK,IAAI,EACzDuW,EAAc,IAAIvW,EAAM,KAAK,aAAayW,EAAMH,CAAO,CAAC,EACxDtD,EAAY,KAAKhT,CAAI,CACvB,CACA,MAAM2W,EAAO,KAAK,IAAI,YACtB,OAAO,IAAIA,EAAKJ,EAAevD,CAAW,CAC5C,CACA,SAASiD,EAAO,CACd,MAAM/B,EAAe,CAAC,GAAG,KAAK,UAAU,QAAO,CAAE,EAC3CoC,EAAUpC,EAAa,OACvBK,EAAa,KAAK,MAClBmC,EAAW,OAAO,KAAKT,CAAK,EAC5BC,EAAgB,CAAA,EACtB,SAAW,CAAClW,EAAM8U,CAAI,IAAK,OAAO,QAAQmB,CAAK,EACzC,OAAOnB,GAAS,SAClBoB,EAAclW,CAAI,EAAI,KAAK,kBAAkBA,EAAM8U,CAAI,EAEvDoB,EAAclW,CAAI,EAAI8U,EAG1B,MAAM8B,EAA4B,IAAI,IACtC,UAAWnB,KAAKlB,EACdqC,EAAU,IAAInB,EAAG,EAAE,EAErB,MAAMoB,EAA4B,IAAI,IACtC,UAAW7W,KAAQ0W,EACjBG,EAAU,IAAI7W,EAAM,EAAE,EAExB,MAAMqW,EAAU9B,EAAW,IAAKkB,GAAM,KAAK,IAAI,IAAIA,CAAC,EAAE,MAAM,EAC5D,GAAIiB,EAAS,SAAW,EAAG,CACzB,MAAMI,EAAcJ,EAAS,CAAC,EACxBK,EAAUb,EAAcY,CAAW,EACzC,GAAIC,aAAmBzU,GAAY,CACjC,MAAM0U,EAAY,KAAK,IAAI,IAAID,EAAQ,aAAa,CAAC,CAAC,EAAE,OACxD,SAAW,CAAA,CAAGvb,CAAO,IAAK0Y,EAAc,CACtC,MAAM+C,EAAazb,EAAQ,CAAC,EAC5B,QAASgb,EAAK,EAAGA,EAAKjC,EAAW,OAAQiC,IACvCI,EAAU,IAAIrC,EAAWiC,CAAE,CAAC,EAAE,KAAKH,EAAQG,CAAE,EAAE,IAAIS,CAAU,CAAC,EAEhE,IAAIC,EAAM,EACNC,EAAW,GACf,QAASC,EAAK,EAAGA,EAAK5b,EAAQ,OAAQ4b,IAAM,CAC1C,MAAMrb,EAAIib,EAAU,IAAIxb,EAAQ4b,CAAE,CAAC,EAC/B,OAAOrb,GAAM,WACfmb,GAAOnb,EACPob,EAAW,GAEf,CACAN,EAAU,IAAIC,CAAW,EAAE,KAAKK,EAAWD,EAAM,IAAI,CACvD,CACA,MAAMG,EAAiC,IAAI,IACrCC,EAAe,CAAA,EACrB,QAASd,EAAK,EAAGA,EAAKjC,EAAW,OAAQiC,IAAM,CAC7C,MAAMf,EAAIlB,EAAWiC,CAAE,EACjBC,EAAOG,EAAU,IAAInB,CAAC,EAC5B4B,EAAe,IAAI5B,EAAG,KAAK,iBAAiBY,EAAQG,CAAE,EAAGC,CAAI,CAAC,EAC9Da,EAAa,KAAK7B,CAAC,CACrB,CACA4B,EAAe,IACbP,EACA7b,EAAc,KAAK4b,EAAU,IAAIC,CAAW,CAAC,CACvD,EACQQ,EAAa,KAAKR,CAAW,EAC7B,MAAMS,EAAQ,KAAK,IAAI,YACvB,OAAO,IAAIA,EAAMF,EAAgBC,CAAY,CAC/C,CACF,CACA,SAAW,CAAA,CAAG9b,CAAO,IAAK0Y,EAAc,CACtC,MAAM+C,EAAazb,EAAQ,CAAC,EAC5B,QAASgb,EAAK,EAAGA,EAAKjC,EAAW,OAAQiC,IACvCI,EAAU,IAAIrC,EAAWiC,CAAE,CAAC,EAAE,KAAKH,EAAQG,CAAE,EAAE,IAAIS,CAAU,CAAC,EAEhE,MAAMO,EAAe,IAAI,WAAWhc,CAAO,EACrCic,EAA6B,IAAI,IACvC,UAAWC,KAAc,KAAK,IAAI,QAChCD,EAAW,IAAIC,EAAY,KAAK,IAAI,IAAIA,CAAU,EAAE,OAAO,KAAKF,CAAY,CAAC,EAE/E,MAAMD,EAAQ,KAAK,IAAI,YACjBI,EAAW,IAAIJ,EAAME,EAAY,CAAC,GAAG,KAAK,IAAI,OAAO,CAAC,EAC5D,UAAWzX,KAAQ0W,EAAU,CAE3B,MAAM5b,EADUob,EAAclW,CAAI,EACX,cAAc2X,CAAQ,EAC7Cd,EAAU,IAAI7W,CAAI,EAAE,KAAKlF,CAAM,CACjC,CACF,CACA,MAAMyb,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACpB,QAASwD,EAAK,EAAGA,EAAKjC,EAAW,OAAQiC,IAAM,CAC7C,MAAMf,EAAIlB,EAAWiC,CAAE,EACjBQ,EAAYX,EAAQG,CAAE,EACtBC,EAAOG,EAAU,IAAInB,CAAC,EAC5Bc,EAAc,IAAId,EAAG,KAAK,iBAAiBuB,EAAWP,CAAI,CAAC,EAC3DzD,EAAY,KAAKyC,CAAC,CACpB,CACA,UAAWzV,KAAQ0W,EAAU,CAC3B,MAAMD,EAAOI,EAAU,IAAI7W,CAAI,EAC/BuW,EAAc,IAAIvW,EAAM,KAAK,aAAayW,EAAMH,CAAO,CAAC,EACxDtD,EAAY,KAAKhT,CAAI,CACvB,CACA,MAAM2W,EAAO,KAAK,IAAI,YACtB,OAAO,IAAIA,EAAKJ,EAAevD,CAAW,CAC5C,CACA,eAAemD,EAAS,CACtB,MAAMnW,EAAOmW,EAAQ,YAAY,KAYjC,MAXY,CACV,WAAY,MACZ,YAAa,OACb,aAAc,QACd,qBAAsB,iBACtB,WAAY,MACZ,WAAY,MACZ,WAAY,MACZ,aAAc,QACd,YAAa,MACnB,EACenW,CAAI,GAAK,IACtB,CACA,kBAAkBuE,EAAYqT,EAAQ,CACpC,MAAMC,EAAU/S,GAAIP,CAAU,EAC9B,OAAQqT,EAAM,CACZ,IAAK,MACH,OAAOC,EAAQ,IAAG,EACpB,IAAK,OACH,OAAOA,EAAQ,KAAI,EACrB,IAAK,QACH,OAAOA,EAAQ,MAAK,EACtB,IAAK,MACH,OAAOA,EAAQ,IAAG,EACpB,IAAK,MACH,OAAOA,EAAQ,IAAG,EACpB,IAAK,MACH,OAAOA,EAAQ,IAAG,EACpB,IAAK,QACH,OAAOA,EAAQ,MAAK,EACtB,IAAK,OACH,OAAOA,EAAQ,KAAI,EACrB,QACE,MAAM,IAAI,MAAM,+BAA+BD,CAAM,EAAE,CAC/D,CACE,CACA,iBAAiB7Z,EAAQlC,EAAQ,CAC/B,OAAQkC,EAAO,MAAK,CAClB,IAAK,MACH,OAAO9C,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOZ,EAAc,KAAKY,CAAM,EAClC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACxC,CACE,CACA,aAAaA,EAAQic,EAAS,CAC5B,IAAI/N,EAAS,KACb,UAAWhO,KAAKF,EACd,GAAIE,IAAM,KAAM,CACdgO,EAAShO,EACT,KACF,CAEF,OAAIgO,IAAW,MAAQ,OAAOA,GAAW,SAChC9O,EAAc,KAAKY,CAAM,EAE9B,OAAOkO,GAAW,SACb7N,EAAW,KAAKL,CAAM,EAE3B,OAAOkO,GAAW,UACblN,EAAc,KAAKhB,CAAM,EAE9BkO,aAAkB,KACbhN,EAAW,KAAKlB,CAAM,EAExBZ,EAAc,KAAKY,CAAM,CAClC,CACA,OAAQ,CACN,MAAMqY,EAAe,CAAC,GAAG,KAAK,UAAU,QAAO,CAAE,EAC3CmC,EAAU,KAAK,MAAM,IAAKZ,GAAM,KAAK,IAAI,IAAIA,CAAC,EAAE,MAAM,EACtDmB,EAA4B,IAAI,IACtC,UAAWnB,KAAK,KAAK,MACnBmB,EAAU,IAAInB,EAAG,EAAE,EAErB,MAAM5U,EAAS,CAAA,EACf,SAAW,CAAA,CAAGrF,CAAO,IAAK0Y,EAAc,CACtC,MAAM+C,EAAazb,EAAQ,CAAC,EAC5B,QAASgb,EAAK,EAAGA,EAAK,KAAK,MAAM,OAAQA,IACvCI,EAAU,IAAI,KAAK,MAAMJ,CAAE,CAAC,EAAE,KAAKH,EAAQG,CAAE,EAAE,IAAIS,CAAU,CAAC,EAEhEpW,EAAO,KAAKrF,EAAQ,MAAM,CAC5B,CACA,MAAM+a,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACpB,QAASwD,EAAK,EAAGA,EAAK,KAAK,MAAM,OAAQA,IAAM,CAC7C,MAAMf,EAAI,KAAK,MAAMe,CAAE,EACjBC,EAAOG,EAAU,IAAInB,CAAC,EAC5Bc,EAAc,IAAId,EAAG,KAAK,iBAAiBY,EAAQG,CAAE,EAAGC,CAAI,CAAC,EAC7DzD,EAAY,KAAKyC,CAAC,CACpB,CACAc,EAAc,IAAI,QAAStb,EAAc,KAAK4F,CAAM,CAAC,EACrDmS,EAAY,KAAK,OAAO,EACxB,MAAM2D,EAAO,KAAK,IAAI,YACtB,OAAO,IAAIA,EAAKJ,EAAevD,CAAW,CAC5C,CACA,IAAInZ,EAAQ,CACV,OAAO,KAAK,IAAI,CAAE,CAACA,CAAM,EAAGiL,GAAIjL,CAAM,EAAE,IAAG,EAAI,CACjD,CACA,KAAKA,EAAQ,CACX,OAAO,KAAK,IAAI,CAAE,CAACA,CAAM,EAAGiL,GAAIjL,CAAM,EAAE,KAAI,EAAI,CAClD,CACA,IAAIA,EAAQ,CACV,OAAO,KAAK,IAAI,CAAE,CAACA,CAAM,EAAGiL,GAAIjL,CAAM,EAAE,IAAG,EAAI,CACjD,CACA,IAAIA,EAAQ,CACV,OAAO,KAAK,IAAI,CAAE,CAACA,CAAM,EAAGiL,GAAIjL,CAAM,EAAE,IAAG,EAAI,CACjD,CACA,OAAQ,CACN,MAAMke,EAAgB,KAAK,IAAI,QAAQ,OAAQ5Q,GAAM,CAAC,KAAK,MAAM,SAASA,CAAC,CAAC,EACtE8O,EAAQ,CAAA,EACd,UAAW9O,KAAK4Q,EACd9B,EAAM9O,CAAC,EAAIrC,GAAIqC,CAAC,EAAE,MAAK,EAEzB,OAAO,KAAK,IAAI8O,CAAK,CACvB,CACA,MAAO,CACL,MAAM8B,EAAgB,KAAK,IAAI,QAAQ,OAAQ5Q,GAAM,CAAC,KAAK,MAAM,SAASA,CAAC,CAAC,EACtE8O,EAAQ,CAAA,EACd,UAAW9O,KAAK4Q,EACd9B,EAAM9O,CAAC,EAAIrC,GAAIqC,CAAC,EAAE,KAAI,EAExB,OAAO,KAAK,IAAI8O,CAAK,CACvB,CACA,MAAMhY,EAAI,CACR,MAAMJ,EAAU,CAAA,EAChB,SAAW,CAAA,CAAGrC,CAAO,IAAK,KAAK,UAAW,CACxC,MAAMmc,EAAW,KAAK,eAAenc,CAAO,EAC5CqC,EAAQ,KAAKI,EAAG0Z,CAAQ,CAAC,CAC3B,CACA,OAAI9Z,EAAQ,SAAW,EACd,KAAK,IAAI,MAAM,EAAG,CAAC,EAEf,KAAK,IAAI,YACV,OAAO,GAAGA,CAAO,CAC/B,CACA,QAAS,CACP,MAAM/C,EAAyB,IAAI,IACnC,SAAW,CAAC8F,EAAKpF,CAAO,IAAK,KAAK,UAChCV,EAAO,IAAI8F,EAAK,KAAK,eAAepF,CAAO,CAAC,EAE9C,OAAOV,CACT,CACA,cAAcqG,EAAS3G,EAAO,CAC5B,GAAI2G,EAAQ,SAAW,EAAG,CACxB,MAAMpF,EAAIoF,EAAQ,CAAC,EAAE,IAAI3G,CAAK,EAC9B,OAAIuB,IAAM,KAAa,SACnBA,aAAa,KAAa,MAAMA,EAAE,QAAO,CAAE,GAC3C,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAC1D,KAAK,OAAOA,CAAC,GAAG,OAAOA,CAAC,CAAC,GAE3B,QAAQ,KAAK,UAAUA,CAAC,CAAC,EAClC,CACA,MAAM2S,EAAQ,CAAA,EACd,UAAW7U,KAAUsH,EAAS,CAC5B,MAAMpF,EAAIlC,EAAO,IAAIW,CAAK,EACtBuB,IAAM,KACR2S,EAAM,KAAK,QAAQ,EACV3S,aAAa,KACtB2S,EAAM,KAAK,MAAM3S,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxE2S,EAAM,KAAK,KAAK,OAAO3S,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtC2S,EAAM,KAAK,QAAQ,KAAK,UAAU3S,CAAC,CAAC,EAAE,CAE1C,CACA,OAAO2S,EAAM,KAAK,GAAG,CACvB,CACA,eAAelT,EAAS,CACtB,MAAMgc,EAAe,IAAI,WAAWhc,CAAO,EACrCwc,EAA6B,IAAI,IACjChF,EAAc,KAAK,IAAI,QAC7B,UAAWhT,KAAQgT,EACjBgF,EAAW,IAAIhY,EAAM,KAAK,IAAI,IAAIA,CAAI,EAAE,OAAO,KAAKwX,CAAY,CAAC,EAEnE,MAAMb,EAAO,KAAK,IAAI,YACtB,OAAO,IAAIA,EAAKqB,EAAYhF,CAAW,CACzC,CACF,EAGA,SAASiF,GAAa9W,EAAS3G,EAAO,CACpC,MAAMkU,EAAQ,CAAA,EACd,UAAW7U,KAAUsH,EAAS,CAC5B,MAAMpF,EAAIlC,EAAO,IAAIW,CAAK,EAC1B,GAAIuB,IAAM,KACR,OAAO,KACEA,aAAa,KACtB2S,EAAM,KAAK,MAAM3S,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxE2S,EAAM,KAAK,KAAK,OAAO3S,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtC2S,EAAM,KAAK,QAAQ,KAAK,UAAU3S,CAAC,CAAC,EAAE,CAE1C,CACA,OAAO2S,EAAM,KAAK,GAAG,CACvB,CACA,SAASwJ,GAAmBvd,EAAO,CACjC,OAAIA,IAAU,KAAa,KACvBA,aAAiB,KAAa,MAAMA,EAAM,QAAO,CAAE,GACnD,OAAOA,GAAU,UAAY,OAAOA,GAAU,UAAY,OAAOA,GAAU,UACtEA,EAEF,QAAQ,KAAK,UAAUA,CAAK,CAAC,EACtC,CACA,SAASwd,GAAsB/W,EAAOvF,EAAQ,CAC5C,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAASuc,GAAYC,EAAI,CACvB,GAAI,OAAOA,GAAO,SAChB,MAAO,CAAE,SAAU,CAACA,CAAE,EAAG,UAAW,CAACA,CAAE,CAAC,EAE1C,GAAI,MAAM,QAAQA,CAAE,EAClB,MAAO,CAAE,SAAUA,EAAI,UAAWA,CAAE,EAEtC,MAAMC,EAAW,MAAM,QAAQD,EAAG,IAAI,EAAIA,EAAG,KAAO,CAACA,EAAG,IAAI,EACtDE,EAAY,MAAM,QAAQF,EAAG,KAAK,EAAIA,EAAG,MAAQ,CAACA,EAAG,KAAK,EAChE,GAAIC,EAAS,SAAWC,EAAU,OAChC,MAAM,IAAI,MAAM,qDAAqD,EAEvE,MAAO,CAAE,SAAAD,EAAU,UAAAC,CAAS,CAC9B,CACA,SAASC,GAAUxU,EAAMC,EAAO3G,EAAQ,CACtC,MAAMmb,EAAezU,EAAK,OAASC,EAAM,OACnCsS,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACd0F,EAAkC,IAAI,IAC5C,UAAWC,KAAM1U,EAAM,QACjBD,EAAK,QAAQ,SAAS2U,CAAE,EAC1BD,EAAgB,IAAIC,EAAI,GAAGA,CAAE,GAAGrb,CAAM,EAAE,EAExCob,EAAgB,IAAIC,EAAIA,CAAE,EAG9B,UAAW7I,KAAW9L,EAAK,QAAS,CAClC,MAAM4U,EAAS5U,EAAK,IAAI8L,CAAO,EAAE,OAC3BjU,EAAS,IAAI,MAAM4c,CAAY,EACrC,QAASI,EAAK,EAAGA,EAAK7U,EAAK,OAAQ6U,IAAM,CACvC,MAAM9c,EAAI6c,EAAO,IAAIC,CAAE,EACvB,QAASC,EAAK,EAAGA,EAAK7U,EAAM,OAAQ6U,IAClCjd,EAAOgd,EAAK5U,EAAM,OAAS6U,CAAE,EAAI/c,CAErC,CACAwa,EAAc,IAAIzG,EAASqI,GAAsBS,EAAO,MAAO/c,CAAM,CAAC,EACtEmX,EAAY,KAAKlD,CAAO,CAC1B,CACA,UAAWA,KAAW7L,EAAM,QAAS,CACnC,MAAM2U,EAAS3U,EAAM,IAAI6L,CAAO,EAAE,OAC5BiJ,EAAaL,EAAgB,IAAI5I,CAAO,EACxCjU,EAAS,IAAI,MAAM4c,CAAY,EACrC,QAASI,EAAK,EAAGA,EAAK7U,EAAK,OAAQ6U,IACjC,QAASC,EAAK,EAAGA,EAAK7U,EAAM,OAAQ6U,IAClCjd,EAAOgd,EAAK5U,EAAM,OAAS6U,CAAE,EAAIF,EAAO,IAAIE,CAAE,EAGlDvC,EAAc,IAAIwC,EAAYZ,GAAsBS,EAAO,MAAO/c,CAAM,CAAC,EACzEmX,EAAY,KAAK+F,CAAU,CAC7B,CACA,MAAMpC,EAAO3S,EAAK,YAClB,OAAO,IAAI2S,EAAKJ,EAAevD,CAAW,CAC5C,CACA,SAASgG,GAAahV,EAAMC,EAAOoU,EAAIY,EAAM,CAC3C,KAAM,CAAE,SAAAX,EAAU,UAAAC,GAAcH,GAAYC,CAAE,EAC9C,UAAWzX,KAAO0X,EAChB,GAAI,CAACtU,EAAK,QAAQ,SAASpD,CAAG,EAC5B,MAAM,IAAIhH,EAAoBgH,EAAKoD,EAAK,OAAO,EAGnD,UAAWpD,KAAO2X,EAChB,GAAI,CAACtU,EAAM,QAAQ,SAASrD,CAAG,EAC7B,MAAM,IAAIhH,EAAoBgH,EAAKqD,EAAM,OAAO,EAGpD,MAAMiV,EAAeX,EAAU,IAAK9C,GAAMxR,EAAM,IAAIwR,CAAC,EAAE,MAAM,EACvD0D,EAAcb,EAAS,IAAK7C,GAAMzR,EAAK,IAAIyR,CAAC,EAAE,MAAM,EACpD2D,EAA8B,IAAI,IACxC,GAAIF,EAAa,SAAW,EAAG,CAC7B,MAAMG,EAAcH,EAAa,CAAC,EAClC,QAASte,EAAI,EAAGA,EAAIqJ,EAAM,OAAQrJ,IAAK,CACrC,MAAMgG,EAAMsX,GAAmBmB,EAAY,IAAIze,CAAC,CAAC,EAC7CgG,IAAQ,MAAMwY,EAAY,IAAIxY,CAAG,CACvC,CACF,KACE,SAAShG,EAAI,EAAGA,EAAIqJ,EAAM,OAAQrJ,IAAK,CACrC,MAAMmb,EAASkC,GAAaiB,EAActe,CAAC,EACvCmb,IAAW,MAAMqD,EAAY,IAAIrD,CAAM,CAC7C,CAEF,MAAMuD,EAAiB,CAAA,EACvB,GAAIH,EAAY,SAAW,EAAG,CAC5B,MAAMI,EAAaJ,EAAY,CAAC,EAChC,QAASve,EAAI,EAAGA,EAAIoJ,EAAK,OAAQpJ,IAAK,CACpC,MAAMgG,EAAMsX,GAAmBqB,EAAW,IAAI3e,CAAC,CAAC,EAC1C4e,EAAW5Y,IAAQ,MAAQwY,EAAY,IAAIxY,CAAG,GAChDqY,EAAO,CAACO,EAAWA,IACrBF,EAAe,KAAK1e,CAAC,CAEzB,CACF,KACE,SAASA,EAAI,EAAGA,EAAIoJ,EAAK,OAAQpJ,IAAK,CACpC,MAAMmb,EAASkC,GAAakB,EAAave,CAAC,EACpC4e,EAAWzD,IAAW,MAAQqD,EAAY,IAAIrD,CAAM,GACtDkD,EAAO,CAACO,EAAWA,IACrBF,EAAe,KAAK1e,CAAC,CAEzB,CAEF,MAAM2b,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACpB,UAAWlD,KAAW9L,EAAK,QAAS,CAClC,MAAM4U,EAAS5U,EAAK,IAAI8L,CAAO,EAAE,OAC3BjU,EAAS,IAAI,MAAMyd,EAAe,MAAM,EAC9C,QAAS1e,EAAI,EAAGA,EAAI0e,EAAe,OAAQ1e,IACzCiB,EAAOjB,CAAC,EAAIge,EAAO,IAAIU,EAAe1e,CAAC,CAAC,EAE1C2b,EAAc,IAAIzG,EAASqI,GAAsBS,EAAO,MAAO/c,CAAM,CAAC,EACtEmX,EAAY,KAAKlD,CAAO,CAC1B,CACA,MAAM6G,EAAO3S,EAAK,YAClB,OAAO,IAAI2S,EAAKJ,EAAevD,CAAW,CAC5C,CACA,SAASyG,GAASzV,EAAMC,EAAOoU,EAAIqB,EAAM,QAASrT,EAAS,CACzD,MAAM/I,EAAS+I,GAAS,QAAU,SAClC,GAAIqT,IAAQ,QACV,OAAOlB,GAAUxU,EAAMC,EAAO3G,CAAM,EAEtC,GAAIoc,IAAQ,OACV,OAAOV,GAAahV,EAAMC,EAAOoU,EAAI,EAAK,EAE5C,GAAIqB,IAAQ,OACV,OAAOV,GAAahV,EAAMC,EAAOoU,EAAI,EAAI,EAE3C,KAAM,CAAE,SAAAC,EAAU,UAAAC,GAAcH,GAAYC,CAAE,EAC9C,UAAWzX,KAAO0X,EAChB,GAAI,CAACtU,EAAK,QAAQ,SAASpD,CAAG,EAC5B,MAAM,IAAIhH,EAAoBgH,EAAKoD,EAAK,OAAO,EAGnD,UAAWpD,KAAO2X,EAChB,GAAI,CAACtU,EAAM,QAAQ,SAASrD,CAAG,EAC7B,MAAM,IAAIhH,EAAoBgH,EAAKqD,EAAM,OAAO,EAGpD,GAAIyV,IAAQ,QAAUpB,EAAS,SAAW,GAAKC,EAAU,SAAW,EAAG,CACrE,MAAMgB,EAAavV,EAAK,IAAIsU,EAAS,CAAC,CAAC,EAAE,OACnCe,EAAcpV,EAAM,IAAIsU,EAAU,CAAC,CAAC,EAAE,OACtCoB,EAAkC,IAAI,IAC5C,IAAIC,EAAiB,GACrB,QAAShf,EAAI,EAAGA,EAAIqJ,EAAM,OAAQrJ,IAAK,CACrC,MAAMgG,EAAMsX,GAAmBmB,EAAY,IAAIze,CAAC,CAAC,EACjD,GAAIgG,IAAQ,KACZ,IAAI+Y,EAAgB,IAAI/Y,CAAG,EAAG,CAC5BgZ,EAAiB,GACjB,KACF,CACAD,EAAgB,IAAI/Y,EAAKhG,CAAC,EAC5B,CACA,GAAIgf,EAAgB,CAClB,MAAMvC,EAAiC,IAAI,IACrCC,EAAe,CAAA,EACrB,UAAWxH,KAAW9L,EAAK,QACzBqT,EAAe,IAAIvH,EAAS9L,EAAK,IAAI8L,CAAO,EAAE,MAAM,EACpDwH,EAAa,KAAKxH,CAAO,EAE3B,MAAM+J,EAAmB5V,EAAM,QAAQ,OAAQkD,GAAMA,IAAMoR,EAAU,CAAC,CAAC,EACjEuB,EAAmC,IAAI,IAC7C,UAAWnB,KAAMkB,EACfC,EAAiB,IAAInB,EAAI3U,EAAK,QAAQ,SAAS2U,CAAE,EAAI,GAAGA,CAAE,GAAGrb,CAAM,GAAKqb,CAAE,EAE5E,UAAW7I,KAAW+J,EAAkB,CACtC,MAAMjB,EAAS3U,EAAM,IAAI6L,CAAO,EAAE,OAC5BjU,EAAS,IAAI,MAAMmI,EAAK,MAAM,EACpC,QAAS6U,EAAK,EAAGA,EAAK7U,EAAK,OAAQ6U,IAAM,CACvC,MAAMjY,EAAMsX,GAAmBqB,EAAW,IAAIV,CAAE,CAAC,EACjD,GAAIjY,IAAQ,KAAM,CAChB/E,EAAOgd,CAAE,EAAI,KACb,QACF,CACA,MAAMC,GAAKa,EAAgB,IAAI/Y,CAAG,EAClC/E,EAAOgd,CAAE,EAAIC,KAAO,OAAS,KAAOF,EAAO,IAAIE,EAAE,CACnD,CACA,MAAMC,EAAae,EAAiB,IAAIhK,CAAO,EAC/CuH,EAAe,IAAI0B,EAAYZ,GAAsBS,EAAO,MAAO/c,CAAM,CAAC,EAC1Eyb,EAAa,KAAKyB,CAAU,CAC9B,CACA,MAAMxB,EAAQvT,EAAK,YACnB,OAAO,IAAIuT,EAAMF,EAAgBC,CAAY,CAC/C,CACF,CACA,MAAM4B,EAAeX,EAAU,IAAK9C,GAAMxR,EAAM,IAAIwR,CAAC,EAAE,MAAM,EACvDsE,EAA4B,IAAI,IACtC,GAAIb,EAAa,SAAW,EAAG,CAC7B,MAAMG,EAAcH,EAAa,CAAC,EAClC,QAASte,EAAI,EAAGA,EAAIqJ,EAAM,OAAQrJ,IAAK,CACrC,MAAMgG,EAAMsX,GAAmBmB,EAAY,IAAIze,CAAC,CAAC,EACjD,GAAIgG,IAAQ,KAAM,SAClB,MAAMkV,EAASiE,EAAU,IAAInZ,CAAG,EAC5BkV,IAAW,OACbiE,EAAU,IAAInZ,EAAKhG,CAAC,EACX,OAAOkb,GAAW,SAC3BiE,EAAU,IAAInZ,EAAK,CAACkV,EAAQlb,CAAC,CAAC,EAE9Bkb,EAAO,KAAKlb,CAAC,CAEjB,CACF,KACE,SAASA,EAAI,EAAGA,EAAIqJ,EAAM,OAAQrJ,IAAK,CACrC,MAAMmb,EAASkC,GAAaiB,EAActe,CAAC,EAC3C,GAAImb,IAAW,KAAM,SACrB,MAAMD,EAASiE,EAAU,IAAIhE,CAAM,EAC/BD,IAAW,OACbiE,EAAU,IAAIhE,EAAQ,CAACnb,CAAC,CAAC,EAChB,OAAOkb,GAAW,SAC3BiE,EAAU,IAAIhE,EAAQ,CAACD,EAAQlb,CAAC,CAAC,EAEjCkb,EAAO,KAAKlb,CAAC,CAEjB,CAEF,MAAMue,EAAcb,EAAS,IAAK7C,GAAMzR,EAAK,IAAIyR,CAAC,EAAE,MAAM,EACpDuE,EAAc,CAAA,EACdC,EAAe,CAAA,EACfC,EAAe,IAAI,WAAWjW,EAAM,MAAM,EAChD,GAAIkV,EAAY,SAAW,EAAG,CAC5B,MAAMI,EAAaJ,EAAY,CAAC,EAChC,QAASve,EAAI,EAAGA,EAAIoJ,EAAK,OAAQpJ,IAAK,CACpC,MAAMgG,EAAMsX,GAAmBqB,EAAW,IAAI3e,CAAC,CAAC,EAChD,GAAIgG,IAAQ,KAAM,EACZ8Y,IAAQ,QAAUA,IAAQ,WAC5BM,EAAY,KAAKpf,CAAC,EAClBqf,EAAa,KAAK,IAAI,GAExB,QACF,CACA,MAAME,EAAUJ,EAAU,IAAInZ,CAAG,EACjC,GAAIuZ,IAAY,OACd,GAAI,OAAOA,GAAY,SACrBH,EAAY,KAAKpf,CAAC,EAClBqf,EAAa,KAAKE,CAAO,GACrBT,IAAQ,SAAWA,IAAQ,WAC7BQ,EAAaC,CAAO,EAAI,OAG1B,SAASC,EAAK,EAAGA,EAAKD,EAAQ,OAAQC,IAAM,CAC1C,MAAMtB,EAAKqB,EAAQC,CAAE,EACrBJ,EAAY,KAAKpf,CAAC,EAClBqf,EAAa,KAAKnB,CAAE,GAChBY,IAAQ,SAAWA,IAAQ,WAC7BQ,EAAapB,CAAE,EAAI,EAEvB,MAEOY,IAAQ,QAAUA,IAAQ,WACnCM,EAAY,KAAKpf,CAAC,EAClBqf,EAAa,KAAK,IAAI,EAE1B,CACF,KACE,SAASrf,EAAI,EAAGA,EAAIoJ,EAAK,OAAQpJ,IAAK,CACpC,MAAMmb,EAASkC,GAAakB,EAAave,CAAC,EAC1C,GAAImb,IAAW,KAAM,EACf2D,IAAQ,QAAUA,IAAQ,WAC5BM,EAAY,KAAKpf,CAAC,EAClBqf,EAAa,KAAK,IAAI,GAExB,QACF,CACA,MAAME,EAAUJ,EAAU,IAAIhE,CAAM,EACpC,GAAIoE,IAAY,OACd,GAAI,OAAOA,GAAY,SACrBH,EAAY,KAAKpf,CAAC,EAClBqf,EAAa,KAAKE,CAAO,GACrBT,IAAQ,SAAWA,IAAQ,WAC7BQ,EAAaC,CAAO,EAAI,OAG1B,SAASC,EAAK,EAAGA,EAAKD,EAAQ,OAAQC,IAAM,CAC1C,MAAMtB,EAAKqB,EAAQC,CAAE,EACrBJ,EAAY,KAAKpf,CAAC,EAClBqf,EAAa,KAAKnB,CAAE,GAChBY,IAAQ,SAAWA,IAAQ,WAC7BQ,EAAapB,CAAE,EAAI,EAEvB,MAEOY,IAAQ,QAAUA,IAAQ,WACnCM,EAAY,KAAKpf,CAAC,EAClBqf,EAAa,KAAK,IAAI,EAE1B,CAEF,GAAIP,IAAQ,SAAWA,IAAQ,QAC7B,QAAS9e,EAAI,EAAGA,EAAIqJ,EAAM,OAAQrJ,IAC5Bsf,EAAatf,CAAC,IAAM,IACtBof,EAAY,KAAK,EAAE,EACnBC,EAAa,KAAKrf,CAAC,GAIzB,MAAM2b,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACdyF,EAAeuB,EAAY,OAC3BK,EAAkBpW,EAAM,QAAQ,OAAQkD,GAAM,CAACoR,EAAU,SAASpR,CAAC,CAAC,EACpEmT,EAAiBtW,EAAK,QAAQ,OAAQmD,GAAM,CAACmR,EAAS,SAASnR,CAAC,CAAC,EACjEuR,EAAkC,IAAI,IAC5C,UAAWC,KAAM0B,EACXrW,EAAK,QAAQ,SAAS2U,CAAE,EAC1BD,EAAgB,IAAIC,EAAI,GAAGA,CAAE,GAAGrb,CAAM,EAAE,EAExCob,EAAgB,IAAIC,EAAIA,CAAE,EAG9B,QAASnC,EAAK,EAAGA,EAAK8B,EAAS,OAAQ9B,IAAM,CAC3C,MAAM+D,EAAUjC,EAAS9B,CAAE,EACrBgE,EAAWjC,EAAU/B,CAAE,EACvBiE,EAAUzW,EAAK,IAAIuW,CAAO,EAAE,OAC5BG,EAAWzW,EAAM,IAAIuW,CAAQ,EAAE,OAC/B3e,EAAS,IAAI,MAAM4c,CAAY,EACrC,QAAS7d,EAAI,EAAGA,EAAI6d,EAAc7d,IAAK,CACrC,MAAMie,EAAKmB,EAAYpf,CAAC,EAClBke,EAAKmB,EAAarf,CAAC,EACrBie,GAAM,EACRhd,EAAOjB,CAAC,EAAI6f,EAAQ,IAAI5B,CAAE,EACjBC,IAAO,KAChBjd,EAAOjB,CAAC,EAAI8f,EAAS,IAAI5B,CAAE,EAE3Bjd,EAAOjB,CAAC,EAAI,IAEhB,CACA2b,EAAc,IAAIgE,EAASpC,GAAsBsC,EAAQ,MAAO5e,CAAM,CAAC,EACvEmX,EAAY,KAAKuH,CAAO,CAC1B,CACA,UAAWzK,KAAWwK,EAAgB,CACpC,MAAM1B,EAAS5U,EAAK,IAAI8L,CAAO,EAAE,OAC3BjU,EAAS,IAAI,MAAM4c,CAAY,EACrC,QAAS7d,EAAI,EAAGA,EAAI6d,EAAc7d,IAAK,CACrC,MAAMie,EAAKmB,EAAYpf,CAAC,EACxBiB,EAAOjB,CAAC,EAAIie,GAAM,EAAID,EAAO,IAAIC,CAAE,EAAI,IACzC,CACAtC,EAAc,IAAIzG,EAASqI,GAAsBS,EAAO,MAAO/c,CAAM,CAAC,EACtEmX,EAAY,KAAKlD,CAAO,CAC1B,CACA,UAAWA,KAAWuK,EAAiB,CACrC,MAAMzB,EAAS3U,EAAM,IAAI6L,CAAO,EAAE,OAC5BiJ,EAAaL,EAAgB,IAAI5I,CAAO,EACxCjU,EAAS,IAAI,MAAM4c,CAAY,EACrC,QAAS7d,EAAI,EAAGA,EAAI6d,EAAc7d,IAAK,CACrC,MAAMke,EAAKmB,EAAarf,CAAC,EACrBke,IAAO,KACTjd,EAAOjB,CAAC,EAAIge,EAAO,IAAIE,CAAE,EAEzBjd,EAAOjB,CAAC,EAAI,IAEhB,CACA2b,EAAc,IAAIwC,EAAYZ,GAAsBS,EAAO,MAAO/c,CAAM,CAAC,EACzEmX,EAAY,KAAK+F,CAAU,CAC7B,CACA,MAAMpC,EAAO3S,EAAK,YAClB,OAAO,IAAI2S,EAAKJ,EAAevD,CAAW,CAC5C,CAGA,SAAS2H,GAAcxZ,EAAS3G,EAAO,CACrC,MAAMkU,EAAQ,CAAA,EACd,UAAW7U,KAAUsH,EAAS,CAC5B,MAAMpF,EAAIlC,EAAO,IAAIW,CAAK,EAC1B,GAAIuB,IAAM,KACR,OAAO,KACEA,aAAa,KACtB2S,EAAM,KAAK,MAAM3S,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxE2S,EAAM,KAAK,KAAK,OAAO3S,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtC2S,EAAM,KAAK,QAAQ,KAAK,UAAU3S,CAAC,CAAC,EAAE,CAE1C,CACA,OAAO2S,EAAM,KAAK,GAAG,CACvB,CACA,SAASkM,GAAuBxZ,EAAOvF,EAAQ,CAC7C,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,QACE,OAAO,IAAIoB,GAAapB,CAAM,CACpC,CACA,CACA,SAASgf,GAAO7W,EAAMC,EAAOoU,EAAIxc,EAAQ,CACvC,GAAI,CAACmI,EAAK,QAAQ,SAASqU,CAAE,EAC3B,MAAM,IAAIze,EAAoBye,EAAIrU,EAAK,OAAO,EAEhD,GAAI,CAACC,EAAM,QAAQ,SAASoU,CAAE,EAC5B,MAAM,IAAIze,EAAoBye,EAAIpU,EAAM,OAAO,EAEjD,MAAM6W,EAAYjf,GAAUoI,EAAM,QAAQ,OAAQkD,GAAMA,IAAMkR,CAAE,EAChE,UAAW3a,KAAQod,EACjB,GAAI,CAAC7W,EAAM,QAAQ,SAASvG,CAAI,EAC9B,MAAM,IAAI9D,EAAoB8D,EAAMuG,EAAM,OAAO,EAGrD,MAAMoV,EAAc,CAACpV,EAAM,IAAIoU,CAAE,EAAE,MAAM,EACnC0C,EAA4B,IAAI,IACtC,QAASngB,EAAI,EAAGA,EAAIqJ,EAAM,OAAQrJ,IAAK,CACrC,MAAMmb,EAAS4E,GAActB,EAAaze,CAAC,EACvCmb,IAAW,OACVgF,EAAU,IAAIhF,CAAM,GACvBgF,EAAU,IAAIhF,EAAQnb,CAAC,EAE3B,CACA,MAAM2e,EAAa,CAACvV,EAAK,IAAIqU,CAAE,EAAE,MAAM,EACjC9B,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACpB,UAAWlD,KAAW9L,EAAK,QACzBuS,EAAc,IAAIzG,EAAS9L,EAAK,IAAI8L,CAAO,EAAE,MAAM,EACnDkD,EAAY,KAAKlD,CAAO,EAE1B,UAAWA,KAAWgL,EAAW,CAC/B,MAAMlC,EAAS3U,EAAM,IAAI6L,CAAO,EAAE,OAC5B2G,EAAO,IAAI,MAAMzS,EAAK,MAAM,EAClC,QAASpJ,EAAI,EAAGA,EAAIoJ,EAAK,OAAQpJ,IAAK,CACpC,MAAMmb,EAAS4E,GAAcpB,EAAY3e,CAAC,EAC1C,GAAImb,IAAW,KAAM,CACnB,MAAM+C,EAAKiC,EAAU,IAAIhF,CAAM,EAC/BU,EAAK7b,CAAC,EAAIke,IAAO,OAASF,EAAO,IAAIE,CAAE,EAAI,IAC7C,MACErC,EAAK7b,CAAC,EAAI,IAEd,CACA,MAAMme,GAAa/U,EAAK,QAAQ,SAAS8L,CAAO,EAAIA,GACpDyG,EAAc,IAAIwC,EAAY6B,GAAuBhC,EAAO,MAAOnC,CAAI,CAAC,EACxEzD,EAAY,KAAK+F,CAAU,CAC7B,CACA,MAAMpC,EAAO3S,EAAK,YAClB,OAAO,IAAI2S,EAAKJ,EAAevD,CAAW,CAC5C,CAGA,SAASgI,GAAOnX,EAAKhK,EAAQwM,EAAU,CAAA,EAAI,CACzC,GAAI,CAACxC,EAAI,QAAQ,SAAShK,CAAM,EAC9B,MAAM,IAAID,EAAoBC,EAAQgK,EAAI,OAAO,EAEnD,KAAM,CAAE,MAAAoX,EAAO,KAAMC,EAAQ,KAAAC,EAAO,EAAK,EAAK9U,EACxCuS,EAAS/U,EAAI,IAAIhK,CAAM,EAAE,OACzBwC,EAAMwH,EAAI,OAChB,IAAIuX,EAAW,GACXC,EAAc,EAClB,MAAMC,EAA6B,IAAI,IACvC,QAAS1gB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMgB,EAAMgd,EAAO,IAAIhe,CAAC,EACxB,GAAIgB,IAAQ,MACZ,GAAI,MAAM,QAAQA,CAAG,EACnByf,EAAc,KAAK,IAAIA,EAAazf,EAAI,MAAM,UACrC,OAAOA,GAAQ,SAAU,CAClCwf,EAAW,GACX,UAAWxa,KAAO,OAAO,KAAKhF,CAAG,EAC/B0f,EAAW,IAAI1a,CAAG,CAEtB,EACF,CACA,MAAM2V,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACpB,UAAWlD,KAAWjM,EAAI,QACpBsX,GAAQrL,IAAYjW,IACxB0c,EAAc,IAAIzG,EAASjM,EAAI,IAAIiM,CAAO,EAAE,MAAM,EAClDkD,EAAY,KAAKlD,CAAO,GAE1B,GAAIsL,EAAU,CACZ,MAAM5F,EAAO,CAAC,GAAG8F,CAAU,EACrBC,EAAgBN,IAAU,OAASzF,EAAK,MAAM,EAAGyF,CAAK,EAAIzF,EAChE,UAAW5U,KAAO2a,EAAe,CAC/B,MAAMC,EAAUN,EAASA,EAAOrhB,EAAQ+G,CAAG,EAAI,GAAG/G,CAAM,IAAI+G,CAAG,GACzD/E,EAAS,IAAI,MAAMQ,CAAG,EAC5B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMgB,EAAMgd,EAAO,IAAIhe,CAAC,EACxB,GAAIgB,IAAQ,MAAQ,OAAOA,GAAQ,UAAY,MAAM,QAAQA,CAAG,EAC9DC,EAAOjB,CAAC,EAAI,SACP,CACL,MAAMoT,EAAMpS,EACZC,EAAOjB,CAAC,EAAIgG,KAAOoN,EAAMA,EAAIpN,CAAG,EAAI,IACtC,CACF,CACA2V,EAAc,IAAIiF,EAASve,GAAa,KAAKpB,CAAM,CAAC,EACpDmX,EAAY,KAAKwI,CAAO,CAC1B,CACF,KAAO,CACL,MAAM7J,EAAQsJ,IAAU,OAAS,KAAK,IAAII,EAAaJ,CAAK,EAAII,EAChE,QAAS5f,EAAM,EAAGA,EAAMkW,EAAOlW,IAAO,CACpC,MAAM+f,EAAUN,EAASA,EAAOrhB,EAAQ4B,CAAG,EAAI,GAAG5B,CAAM,IAAI,OAAO4B,CAAG,CAAC,GACjEI,EAAS,IAAI,MAAMQ,CAAG,EAC5B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMgB,EAAMgd,EAAO,IAAIhe,CAAC,EACpBgB,IAAQ,MAAQ,CAAC,MAAM,QAAQA,CAAG,GAAKH,GAAOG,EAAI,OACpDC,EAAOjB,CAAC,EAAI,KAEZiB,EAAOjB,CAAC,EAAIgB,EAAIH,CAAG,CAEvB,CACA8a,EAAc,IAAIiF,EAASve,GAAa,KAAKpB,CAAM,CAAC,EACpDmX,EAAY,KAAKwI,CAAO,CAC1B,CACF,CACA,MAAM7E,EAAO9S,EAAI,YACjB,OAAO,IAAI8S,EAAKJ,EAAevD,CAAW,CAC5C,CAGA,SAASyI,GAAO5X,EAAK1C,EAASkF,EAAU,CAAA,EAAI,CAC1C,MAAMwG,EAAO,MAAM,QAAQ1L,CAAO,EAAIA,EAAU,CAACA,CAAO,EACxD,UAAWgG,KAAK0F,EACd,GAAI,CAAChJ,EAAI,QAAQ,SAASsD,CAAC,EACzB,MAAM,IAAIvN,EAAoBuN,EAAGtD,EAAI,OAAO,EAGhD,MAAMxH,EAAMwH,EAAI,OACV6X,EAAgB7X,EAAI,QAAQ,OAAQsD,GAAM,CAAC0F,EAAK,SAAS1F,CAAC,CAAC,EAC3DwU,EAAY,IAAI,MAAMtf,CAAG,EAC/B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,IAAIghB,EAAS,EACb,UAAWzU,KAAK0F,EAAM,CACpB,MAAMjR,EAAMiI,EAAI,IAAIsD,CAAC,EAAE,OAAO,IAAIvM,CAAC,EAC/B,MAAM,QAAQgB,CAAG,IACnBggB,EAAS,KAAK,IAAIA,EAAQhgB,EAAI,MAAM,EAExC,CACA+f,EAAU/gB,CAAC,EAAIghB,CACjB,CACA,MAAMC,EAAYF,EAAU,OAAO,CAAC7c,EAAGC,IAAMD,EAAIC,EAAG,CAAC,EAC/C+c,EAAa,CAAA,EACnB,UAAW3U,KAAKuU,EACdI,EAAW3U,CAAC,EAAI,IAAI,MAAM0U,CAAS,EAErC,UAAW1U,KAAK0F,EACdiP,EAAW3U,CAAC,EAAI,IAAI,MAAM0U,CAAS,EAErC,IAAIE,EACA1V,EAAQ,QACV0V,EAAY,IAAI,MAAMF,CAAS,GAEjC,IAAIG,EAAS,EACb,QAASphB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAM7B,EAAQ4iB,EAAU/gB,CAAC,EACzB,GAAI7B,IAAU,EACd,QAAS8W,EAAI,EAAGA,EAAI9W,EAAO8W,IAAK,CAC9B,UAAW1I,KAAKuU,EACdI,EAAW3U,CAAC,EAAE6U,CAAM,EAAInY,EAAI,IAAIsD,CAAC,EAAE,OAAO,IAAIvM,CAAC,EAEjD,UAAWuM,KAAK0F,EAAM,CACpB,MAAMjR,EAAMiI,EAAI,IAAIsD,CAAC,EAAE,OAAO,IAAIvM,CAAC,EAC/B,MAAM,QAAQgB,CAAG,GAAKiU,EAAIjU,EAAI,OAChCkgB,EAAW3U,CAAC,EAAE6U,CAAM,EAAIpgB,EAAIiU,CAAC,EAE7BiM,EAAW3U,CAAC,EAAE6U,CAAM,EAAI,IAE5B,CACID,IACFA,EAAUC,CAAM,EAAInM,GAEtBmM,GACF,CACF,CACA,MAAMzF,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACpB,UAAW7L,KAAKtD,EAAI,QAClB0S,EAAc,IAAIpP,EAAGlK,GAAa,KAAK6e,EAAW3U,CAAC,CAAC,CAAC,EACrD6L,EAAY,KAAK7L,CAAC,EAEhBd,EAAQ,OAAS0V,IACnBxF,EAAc,IAAIlQ,EAAQ,MAAOpJ,GAAa,KAAK8e,CAAS,CAAC,EAC7D/I,EAAY,KAAK3M,EAAQ,KAAK,GAEhC,MAAMsQ,EAAO9S,EAAI,YACjB,OAAO,IAAI8S,EAAKJ,EAAevD,CAAW,CAC5C,CAGA,SAASiJ,GAAOnR,EAAK0K,EAAM,CACzB,OAAOA,EAAK,IAAKC,GAAM,CACrB,MAAM9a,EAAQmQ,EAAI2K,CAAC,EACnB,OAAI9a,IAAU,KAAa,WACvBA,aAAiB,KAAa,WAAW,OAAOA,EAAM,QAAO,CAAE,CAAC,GAC7D,KAAK,OAAOA,CAAK,KAAK,KAAK,UAAUA,CAAK,CAAC,EACpD,CAAC,EAAE,KAAK,GAAG,CACb,CACA,SAASuhB,GAAUrgB,EAAQ,CACzB,GAAIA,EAAO,SAAW,EAAG,MAAO,CAAC,CAAA,CAAE,EACnC,IAAIsgB,EAAM,CAAC,EAAE,EACb,UAAW1b,KAAO5E,EAAQ,CACxB,MAAM6M,EAAO,CAAA,EACb,UAAWrL,KAAU8e,EACnB,UAAWC,KAAQ3b,EACjBiI,EAAK,KAAK,CAAC,GAAGrL,EAAQ+e,CAAI,CAAC,EAG/BD,EAAMzT,CACR,CACA,OAAOyT,CACT,CACA,SAASE,GAAOxY,EAAKhI,EAAQwK,EAAU,CAAA,EAAI,CACzC,UAAWyJ,KAAW,OAAO,KAAKjU,CAAM,EACtC,GAAI,CAACgI,EAAI,QAAQ,SAASiM,CAAO,EAC/B,MAAM,IAAIlW,EAAoBkW,EAASjM,EAAI,OAAO,EAGtD,MAAMyY,EAAajW,EAAQ,QAAU,CAAA,EACrC,UAAWzF,KAAO0b,EAChB,GAAI,CAACzY,EAAI,QAAQ,SAASjD,CAAG,EAC3B,MAAM,IAAIhH,EAAoBgH,EAAKiD,EAAI,OAAO,EAGlD,MAAM0Y,EAAa1Y,EAAI,QAAO,EAC9B,IAAI2Y,EAAcD,EAClB,GAAID,EAAW,OAAS,EAAG,CACzB,MAAMG,EAAaH,EAAW,IAAK1b,GAAQ,CACzC,MAAMD,EAAuB,IAAI,IAC3Bwb,EAAM,CAAA,EACZ,UAAWrR,KAAOyR,EAAY,CAC5B,MAAMvP,EAAMlC,EAAIlK,CAAG,EACb8b,EAAa1P,aAAe,KAAO,KAAK,OAAOA,EAAI,QAAO,CAAE,CAAC,GAAK,KAAK,UAAUA,CAAG,EACrFrM,EAAK,IAAI+b,CAAU,IACtB/b,EAAK,IAAI+b,CAAU,EACnBP,EAAI,KAAKnP,GAAO,IAAI,EAExB,CACA,OAAOmP,CACT,CAAC,EACKQ,EAAST,GAAUO,CAAU,EAC7BG,EAA2B,IAAI,IACrC,UAAW9R,KAAOyR,EAChBK,EAAS,IAAIX,GAAOnR,EAAKwR,CAAU,EAAGxR,CAAG,EAE3C0R,EAAcG,EAAO,IAAKE,GAAU,CAClC,MAAMC,EAAW,CAAA,EACjB,QAASliB,EAAI,EAAGA,EAAI0hB,EAAW,OAAQ1hB,IACrCkiB,EAASR,EAAW1hB,CAAC,CAAC,EAAIiiB,EAAMjiB,CAAC,GAAK,KAExC,MAAMmiB,EAAcH,EAAS,IAAIX,GAAOa,EAAUR,CAAU,CAAC,EAC7D,GAAIS,EACF,OAAOA,EAET,MAAMC,EAAY,CAAA,EAClB,UAAWlN,KAAWjM,EAAI,QACxBmZ,EAAUlN,CAAO,EAAIgN,EAAShN,CAAO,GAAK,KAE5C,OAAOkN,CACT,CAAC,CACH,CACA,MAAMC,EAAa,CAAA,EACnB,UAAWnN,KAAWjM,EAAI,QACxBoZ,EAAWnN,CAAO,EAAI0M,EAAY,IAAK1R,GAAQA,EAAIgF,CAAO,GAAK,IAAI,EAErE,MAAMoN,EAAiB,CAAA,EACvB,SAAW,CAACpN,EAASgF,CAAI,IAAK,OAAO,QAAQjZ,CAAM,EACjDqhB,EAAepN,CAAO,EAAI,OAAOgF,GAAS,WAAaA,EAAKmI,CAAU,EAAInI,EAE5E,MAAMqI,EAAaX,EAAY,IAAK1R,GAAQ,CAC1C,MAAMpC,EAAO,CAAE,GAAGoC,CAAG,EACrB,SAAW,CAACgF,EAASsN,CAAS,IAAK,OAAO,QAAQF,CAAc,GACzDxU,EAAKoH,CAAO,GAAK,QAAU,OAC9BpH,EAAKoH,CAAO,EAAIsN,GAGpB,OAAO1U,CACT,CAAC,EACD,OAAO7E,EAAI,YAAY,SAASsZ,CAAU,CAC5C,CAGA,SAASE,GAAUxhB,EAAQyhB,EAAS,CAClC,OAAQA,EAAO,CACb,IAAK,QACH,OAAOzhB,EAAO,OAAS,EAAIA,EAAO,CAAC,EAAI,KACzC,IAAK,OACH,OAAOA,EAAO,OAAS,EAAIA,EAAOA,EAAO,OAAS,CAAC,EAAI,KACzD,IAAK,QACH,OAAOA,EAAO,OAChB,IAAK,MAAO,CACV,IAAIH,EAAQ,EACZ,UAAWK,KAAKF,EACV,OAAOE,GAAM,WAAUL,GAASK,GAEtC,OAAOL,CACT,CACA,IAAK,OAAQ,CACX,IAAIA,EAAQ,EACR3C,EAAQ,EACZ,UAAWgD,KAAKF,EACV,OAAOE,GAAM,WACfL,GAASK,EACThD,KAGJ,OAAOA,EAAQ,EAAI2C,EAAQ3C,EAAQ,IACrC,CACJ,CACA,CACA,SAASwkB,GAAc1Z,EAAKrJ,EAAOgjB,EAAW,CAC5C,MAAM9O,EAAQ,CAAA,EACd,UAAW1O,KAAQwd,EAAW,CAC5B,MAAMzhB,EAAI8H,EAAI,IAAI7D,CAAI,EAAE,IAAIxF,CAAK,EAC7BuB,IAAM,KACR2S,EAAM,KAAK,QAAQ,EACV3S,aAAa,KACtB2S,EAAM,KAAK,MAAM3S,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxE2S,EAAM,KAAK,KAAK,OAAO3S,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtC2S,EAAM,KAAK,QAAQ,KAAK,UAAU3S,CAAC,CAAC,EAAE,CAE1C,CACA,OAAO2S,EAAM,KAAK,GAAG,CACvB,CACA,SAAS+O,GAAuBrc,EAAOvF,EAAQ,CAC7C,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAAS6hB,GAAM7Z,EAAKwC,EAAS,CAC3B,MAAMmX,EAAY,MAAM,QAAQnX,EAAQ,KAAK,EAAIA,EAAQ,MAAQ,CAACA,EAAQ,KAAK,EACzEsX,EAAatX,EAAQ,QACrBuX,EAAYvX,EAAQ,OACpBiX,EAAUjX,EAAQ,SAAW,QACnC,UAAW3I,IAAQ,CAAC,GAAG8f,EAAWG,EAAYC,CAAS,EACrD,GAAI,CAAC/Z,EAAI,QAAQ,SAASnG,CAAI,EAC5B,MAAM,IAAI9D,EAAoB8D,EAAMmG,EAAI,OAAO,EAGnD,MAAMga,EAAgB,CAAA,EAChBC,EAAuC,IAAI,IACjD,QAASljB,EAAI,EAAGA,EAAIiJ,EAAI,OAAQjJ,IAAK,CACnC,MAAMgG,EAAM2c,GAAc1Z,EAAKjJ,EAAG4iB,CAAS,EACtCM,EAAqB,IAAIld,CAAG,IAC/Bid,EAAc,KAAKjd,CAAG,EACtBkd,EAAqB,IAAIld,EAAK,EAAE,GAElCkd,EAAqB,IAAIld,CAAG,EAAE,KAAKhG,CAAC,CACtC,CACA,MAAMmjB,EAAiB,CAAA,EACjBC,EAA8B,IAAI,IAClCC,EAAoBpa,EAAI,IAAI8Z,CAAU,EAC5C,QAAS/iB,EAAI,EAAGA,EAAIiJ,EAAI,OAAQjJ,IAAK,CACnC,MAAMmB,EAAIkiB,EAAkB,IAAIrjB,CAAC,EACjC,IAAIsjB,EACAniB,IAAM,KACRmiB,EAAM,OACG,OAAOniB,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxEmiB,EAAM,OAAOniB,CAAC,EACLA,aAAa,KACtBmiB,EAAMniB,EAAE,YAAW,EAEnBmiB,EAAM,KAAK,UAAUniB,CAAC,EAEnBiiB,EAAY,IAAIE,CAAG,IACtBF,EAAY,IAAIE,CAAG,EACnBH,EAAe,KAAKG,CAAG,EAE3B,CACA,MAAMC,EAA2B,IAAI,IACrC,QAASvjB,EAAI,EAAGA,EAAIiJ,EAAI,OAAQjJ,IAAK,CACnC,MAAMwjB,EAAWb,GAAc1Z,EAAKjJ,EAAG4iB,CAAS,EAC1Ca,EAAWJ,EAAkB,IAAIrjB,CAAC,EACxC,IAAI0jB,EACAD,IAAa,KACfC,EAAW,OACF,OAAOD,GAAa,UAAY,OAAOA,GAAa,UAAY,OAAOA,GAAa,UAC7FC,EAAW,OAAOD,CAAQ,EACjBA,aAAoB,KAC7BC,EAAWD,EAAS,YAAW,EAE/BC,EAAW,KAAK,UAAUD,CAAQ,EAEpC,MAAME,EAAUH,EAAW,IAAME,EAC5BH,EAAS,IAAII,CAAO,GACvBJ,EAAS,IAAII,EAAS,EAAE,EAE1BJ,EAAS,IAAII,CAAO,EAAE,KAAK1a,EAAI,IAAI+Z,CAAS,EAAE,IAAIhjB,CAAC,CAAC,CACtD,CACA,MAAM4jB,EAAc3a,EAAI,IAAI+Z,CAAS,EAAE,OAAO,MACxCa,EAAcnB,IAAY,QAAU,MAAsBkB,EAC1DjI,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACpB,UAAW0L,KAAUlB,EAAW,CAC9B,MAAM/G,EAAO,CAAA,EACPO,EAAYnT,EAAI,IAAI6a,CAAM,EAChC,UAAW9d,KAAOid,EAAe,CAC/B,MAAMc,EAAWb,EAAqB,IAAIld,CAAG,EAAE,CAAC,EAChD6V,EAAK,KAAKO,EAAU,IAAI2H,CAAQ,CAAC,CACnC,CACApI,EAAc,IAAImI,EAAQjB,GAAuBzG,EAAU,OAAO,MAAOP,CAAI,CAAC,EAC9EzD,EAAY,KAAK0L,CAAM,CACzB,CACA,UAAWL,KAAYN,EAAgB,CACrC,MAAMtH,EAAO,CAAA,EACb,UAAW2H,KAAYP,EAAe,CACpC,MAAMU,EAAUH,EAAW,IAAMC,EAC3BO,EAAaT,EAAS,IAAII,CAAO,EACnCK,GAAcA,EAAW,OAAS,EACpCnI,EAAK,KAAK4G,GAAUuB,EAAYtB,CAAO,CAAC,EAExC7G,EAAK,KAAK,IAAI,CAElB,CACAF,EAAc,IAAI8H,EAAUZ,GAAuBgB,EAAahI,CAAI,CAAC,EACrEzD,EAAY,KAAKqL,CAAQ,CAC3B,CACA,MAAM1H,EAAO9S,EAAI,YACjB,OAAO,IAAI8S,EAAKJ,EAAevD,CAAW,CAC5C,CAGA,SAAS6L,GAAuBzd,EAAOvF,EAAQ,CAC7C,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAASijB,GAAYjjB,EAAQ,CAC3B,UAAWE,KAAKF,EACd,GAAIE,GAAM,KACV,IAAI,OAAOA,GAAM,SAAU,OAAO,OAAO,UAAUA,CAAC,EAAI,MACxD,GAAI,OAAOA,GAAM,SAAU,MAAO,OAClC,GAAI,OAAOA,GAAM,UAAW,MAAO,OACnC,GAAIA,aAAa,KAAM,MAAO,OAEhC,MAAO,KACT,CACA,SAASgjB,GAAKlb,EAAKwC,EAAS,CAC1B,MAAM2Y,EAAS,MAAM,QAAQ3Y,EAAQ,MAAM,EAAIA,EAAQ,OAAS,CAACA,EAAQ,MAAM,EACzE4Y,EAAU5Y,EAAQ,SAAW,WAC7B6Y,EAAY7Y,EAAQ,WAAa,QACvC,UAAW3I,KAAQshB,EACjB,GAAI,CAACnb,EAAI,QAAQ,SAASnG,CAAI,EAC5B,MAAM,IAAI9D,EAAoB8D,EAAMmG,EAAI,OAAO,EAGnD,IAAIsb,EACJ,GAAI9Y,EAAQ,UAAW,CACrB8Y,EAAY,MAAM,QAAQ9Y,EAAQ,SAAS,EAAIA,EAAQ,UAAY,CAACA,EAAQ,SAAS,EACrF,UAAW3I,KAAQyhB,EACjB,GAAI,CAACtb,EAAI,QAAQ,SAASnG,CAAI,EAC5B,MAAM,IAAI9D,EAAoB8D,EAAMmG,EAAI,OAAO,CAGrD,KAAO,CACL,MAAMub,EAAQ,IAAI,IAAIJ,CAAM,EAC5BG,EAAYtb,EAAI,QAAQ,OAAQsD,GAAM,CAACiY,EAAM,IAAIjY,CAAC,CAAC,CACrD,CACA,MAAM2E,EAAQjI,EAAI,OACZwb,EAAaF,EAAU,OACvB1G,EAAe3M,EAAQuT,EACvB9I,EAAgC,IAAI,IACpCvD,EAAc,CAAA,EACpB,UAAWsM,KAASN,EAAQ,CAC1B,MAAMO,EAAe1b,EAAI,IAAIyb,CAAK,EAC5B7I,EAAO,IAAI,MAAMgC,CAAY,EACnC,QAAS7d,EAAI,EAAGA,EAAIkR,EAAOlR,IAAK,CAC9B,MAAMmB,EAAIwjB,EAAa,IAAI3kB,CAAC,EAC5B,QAASiV,EAAI,EAAGA,EAAIwP,EAAYxP,IAC9B4G,EAAK7b,EAAIykB,EAAaxP,CAAC,EAAI9T,CAE/B,CACAwa,EAAc,IAAI+I,EAAOT,GAAuBU,EAAa,OAAO,MAAO9I,CAAI,CAAC,EAChFzD,EAAY,KAAKsM,CAAK,CACxB,CACA,MAAME,EAAY,IAAI,MAAM/G,CAAY,EACxC,QAAS7d,EAAI,EAAGA,EAAIkR,EAAOlR,IACzB,QAASiV,EAAI,EAAGA,EAAIwP,EAAYxP,IAC9B2P,EAAU5kB,EAAIykB,EAAaxP,CAAC,EAAIsP,EAAUtP,CAAC,EAG/C0G,EAAc,IAAI0I,EAAS/iB,EAAW,KAAKsjB,CAAS,CAAC,EACrDxM,EAAY,KAAKiM,CAAO,EACxB,MAAMQ,EAAc,IAAI,MAAMhH,CAAY,EAC1C,QAAS7d,EAAI,EAAGA,EAAIkR,EAAOlR,IACzB,QAASiV,EAAI,EAAGA,EAAIwP,EAAYxP,IAC9B4P,EAAY7kB,EAAIykB,EAAaxP,CAAC,EAAIhM,EAAI,IAAIsb,EAAUtP,CAAC,CAAC,EAAE,IAAIjV,CAAC,EAGjE,MAAM8kB,EAAaZ,GAAYW,CAAW,EAC1ClJ,EAAc,IAAI2I,EAAWL,GAAuBa,EAAYD,CAAW,CAAC,EAC5EzM,EAAY,KAAKkM,CAAS,EAC1B,MAAMvI,EAAO9S,EAAI,YACjB,OAAO,IAAI8S,EAAKJ,EAAevD,CAAW,CAC5C,CAGA,SAAS2M,GAAa9jB,EAAQ,CAC5B,UAAWE,KAAKF,EACd,GAAIE,GAAM,KACV,IAAI,OAAOA,GAAM,SAAU,MAAO,MAClC,GAAI,OAAOA,GAAM,SAAU,MAAO,OAClC,GAAI,OAAOA,GAAM,UAAW,MAAO,OACnC,GAAIA,aAAa,KAAM,MAAO,OAEhC,MAAO,KACT,CACA,SAAS6jB,GAAuBxe,EAAOvF,EAAQ,CAC7C,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAASgkB,GAAe9jB,EAAG,CACzB,OAAIA,GAAM,KAA6B,OACnCA,aAAa,KAAaA,EAAE,YAAW,EACvC,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAC1D,OAAOA,CAAC,EAEV,KAAK,UAAUA,CAAC,CACzB,CACA,SAAS+jB,GAAUjc,EAAKkc,EAAc,CACpC,MAAMpJ,EAAO9S,EAAI,YACXiI,EAAQjI,EAAI,OACZgJ,EAAOhJ,EAAI,QACjB,GAAIgJ,EAAK,SAAW,GAAKf,IAAU,EACjC,OAAO,IAAI6K,EAAqB,IAAI,IAAO,CAAA,CAAE,EAE/C,IAAIqJ,EACAvL,EACJ,GAAIsL,EAAc,CAChB,MAAME,EAAepc,EAAI,IAAIkc,CAAY,EACzCC,EAAa,CAAA,EACb,QAASplB,EAAI,EAAGA,EAAIkR,EAAOlR,IACzBolB,EAAW,KAAKH,GAAeI,EAAa,IAAIrlB,CAAC,CAAC,CAAC,EAErD6Z,EAAgB5H,EAAK,OAAQ1F,GAAMA,IAAM4Y,CAAY,CACvD,KAAO,CACLC,EAAa,CAAA,EACb,QAASplB,EAAI,EAAGA,EAAIkR,EAAOlR,IACzBolB,EAAW,KAAK,OAAOplB,CAAC,CAAC,EAE3B6Z,EAAgB5H,CAClB,CACA,MAAM0J,EAAgC,IAAI,IACpCvD,EAAc,CAAC,QAAQ,EAC7BuD,EAAc,IAAI,SAAUra,EAAW,KAAKuY,CAAa,CAAC,EAC1D,QAASyL,EAAS,EAAGA,EAASpU,EAAOoU,IAAU,CAC7C,MAAM9Y,EAAS4Y,EAAWE,CAAM,EAC1BrkB,EAAS,CAAA,EACf,UAAWiU,KAAW2E,EACpB5Y,EAAO,KAAKgI,EAAI,IAAIiM,CAAO,EAAE,IAAIoQ,CAAM,CAAC,EAE1C,MAAM9e,EAAQue,GAAa9jB,CAAM,EACjC0a,EAAc,IAAInP,EAAQwY,GAAuBxe,EAAOvF,CAAM,CAAC,EAC/DmX,EAAY,KAAK5L,CAAM,CACzB,CACA,OAAO,IAAIuP,EAAKJ,EAAevD,CAAW,CAC5C,CACA,SAASmN,MAAUC,EAAQ,CACzB,GAAIA,EAAO,SAAW,EACpB,MAAM,IAAIpmB,GAAmB,wCAAwC,EAEvE,MAAMqmB,EAAQD,EAAO,CAAC,EAChBzJ,EAAO0J,EAAM,YACnB,GAAID,EAAO,SAAW,EACpB,OAAOC,EAET,MAAMrY,EAAa,CAAA,EACbsY,EAA4B,IAAI,IACtC,UAAWC,KAASH,EAClB,UAAW1iB,KAAQ6iB,EAAM,QAClBD,EAAU,IAAI5iB,CAAI,IACrB4iB,EAAU,IAAI5iB,CAAI,EAClBsK,EAAW,KAAKtK,CAAI,GAI1B,MAAM8iB,EAA2B,IAAI,IACrC,UAAWD,KAASH,EAAQ,CAC1B,MAAMK,EAASF,EAAM,OACrB,UAAW7iB,KAAQ6iB,EAAM,QAAS,CAChC,MAAM3D,EAAW4D,EAAS,IAAI9iB,CAAI,EAC5BuO,EAAUwU,EAAO/iB,CAAI,EAC3B,GAAIkf,IAAa,QAAUA,IAAa3Q,EACtC,MAAM,IAAIjS,GACR,WAAW0D,CAAI,6BAA6Bkf,CAAQ,OAAO3Q,CAAO,EAC5E,EAEMuU,EAAS,IAAI9iB,EAAMuO,CAAO,CAC5B,CACF,CACA,MAAM4P,EAAYuE,EAAO,OAAO,CAAClJ,EAAKpG,IAAMoG,EAAMpG,EAAE,OAAQ,CAAC,EACvDyF,EAAgC,IAAI,IAC1C,UAAWzG,KAAW9H,EAAY,CAChC,MAAMnM,EAAS,IAAI,MAAMggB,CAAS,EAClC,IAAI6E,EAAS,EACb,UAAWH,KAASH,EAAQ,CAC1B,MAAMO,EAAWJ,EAAM,OACvB,GAAIA,EAAM,QAAQ,SAASzQ,CAAO,EAAG,CACnC,MAAM1S,EAASmjB,EAAM,IAAIzQ,CAAO,EAChC,QAASlV,EAAI,EAAGA,EAAI+lB,EAAU/lB,IAC5BiB,EAAO6kB,EAAS9lB,CAAC,EAAIwC,EAAO,IAAIxC,CAAC,CAErC,KACE,SAASA,EAAI,EAAGA,EAAI+lB,EAAU/lB,IAC5BiB,EAAO6kB,EAAS9lB,CAAC,EAAI,KAGzB8lB,GAAUC,CACZ,CACA,MAAMvf,EAAQof,EAAS,IAAI1Q,CAAO,GAAK6P,GAAa9jB,CAAM,EAC1D0a,EAAc,IAAIzG,EAAS8P,GAAuBxe,EAAOvF,CAAM,CAAC,CAClE,CACA,OAAO,IAAI8a,EAAKJ,EAAevO,CAAU,CAC3C,CAGA,SAAS4Y,GAAa/c,EAAKrJ,EAAOqS,EAAM,CACtC,MAAM6B,EAAQ,CAAA,EACd,UAAW1O,KAAQ6M,EAAM,CACvB,MAAM9Q,EAAI8H,EAAI,IAAI7D,CAAI,EAAE,IAAIxF,CAAK,EAC7BuB,IAAM,KACR2S,EAAM,KAAK,QAAQ,EACV3S,aAAa,KACtB2S,EAAM,KAAK,MAAM3S,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxE2S,EAAM,KAAK,KAAK,OAAO3S,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtC2S,EAAM,KAAK,QAAQ,KAAK,UAAU3S,CAAC,CAAC,EAAE,CAE1C,CACA,OAAO2S,EAAM,KAAK,GAAG,CACvB,CACA,SAASmS,GAAwB7c,EAAMC,EAAO,CAC5C,MAAM6c,EAAW9c,EAAK,QAChB+c,EAAY9c,EAAM,QACxB,GAAI6c,EAAS,SAAWC,EAAU,OAChC,MAAM,IAAI/mB,GACR,6BAA6B8mB,EAAS,MAAM,uBAAuBC,EAAU,MAAM,UACzF,EAEE,MAAMC,EAAahd,EAAK,OAClBid,EAAchd,EAAM,OAC1B,UAAWjE,KAAQ8gB,EAAU,CAC3B,GAAI,EAAE9gB,KAAQihB,GACZ,MAAM,IAAIjnB,GACR,4BAA4BgG,CAAI,gCACxC,EAEI,GAAIghB,EAAWhhB,CAAI,IAAMihB,EAAYjhB,CAAI,EACvC,MAAM,IAAIhG,GACR,4BAA4BgG,CAAI,gBAAgBghB,EAAWhhB,CAAI,CAAC,kBAAkBihB,EAAYjhB,CAAI,CAAC,YAC3G,CAEE,CACF,CACA,SAASkhB,GAAuB9f,EAAOvF,EAAQ,CAC7C,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAASslB,GAAYtd,EAAKrI,EAAS,CACjC,MAAMqR,EAAOhJ,EAAI,QACX4c,EAAS5c,EAAI,OACb0S,EAAgC,IAAI,IAC1C,UAAWvW,KAAQ6M,EAAM,CACvB,MAAMzP,EAASyG,EAAI,IAAI7D,CAAI,EACrBnE,EAAS,CAAA,EACf,UAAWJ,KAAOD,EAChBK,EAAO,KAAKuB,EAAO,IAAI3B,CAAG,CAAC,EAE7B8a,EAAc,IAAIvW,EAAMkhB,GAAuBT,EAAOzgB,CAAI,EAAGnE,CAAM,CAAC,CACtE,CACA,MAAM8a,EAAO9S,EAAI,YACjB,OAAO,IAAI8S,EAAKJ,EAAe,CAAC,GAAG1J,CAAI,CAAC,CAC1C,CACA,SAASuU,GAAMpd,EAAMC,EAAO,CAC1B4c,GAAwB7c,EAAMC,CAAK,EACnC,MAAM4I,EAAO7I,EAAK,QACZyc,EAASzc,EAAK,OACdrD,EAAuB,IAAI,IAC3B0gB,EAA8B,IAAI,IACxC,UAAWrhB,KAAQ6M,EACjBwU,EAAY,IAAIrhB,EAAM,EAAE,EAE1B,QAASpF,EAAI,EAAGA,EAAIoJ,EAAK,OAAQpJ,IAAK,CACpC,MAAMgG,EAAMggB,GAAa5c,EAAMpJ,EAAGiS,CAAI,EACtC,GAAI,CAAClM,EAAK,IAAIC,CAAG,EAAG,CAClBD,EAAK,IAAIC,CAAG,EACZ,UAAWZ,KAAQ6M,EACjBwU,EAAY,IAAIrhB,CAAI,EAAE,KAAKgE,EAAK,IAAIhE,CAAI,EAAE,IAAIpF,CAAC,CAAC,CAEpD,CACF,CACA,QAASA,EAAI,EAAGA,EAAIqJ,EAAM,OAAQrJ,IAAK,CACrC,MAAMgG,EAAMggB,GAAa3c,EAAOrJ,EAAGiS,CAAI,EACvC,GAAI,CAAClM,EAAK,IAAIC,CAAG,EAAG,CAClBD,EAAK,IAAIC,CAAG,EACZ,UAAWZ,KAAQ6M,EACjBwU,EAAY,IAAIrhB,CAAI,EAAE,KAAKiE,EAAM,IAAIjE,CAAI,EAAE,IAAIpF,CAAC,CAAC,CAErD,CACF,CACA,MAAM2b,EAAgC,IAAI,IAC1C,UAAWvW,KAAQ6M,EACjB0J,EAAc,IAAIvW,EAAMkhB,GAAuBT,EAAOzgB,CAAI,EAAGqhB,EAAY,IAAIrhB,CAAI,CAAC,CAAC,EAErF,MAAM2W,EAAO3S,EAAK,YAClB,OAAO,IAAI2S,EAAKJ,EAAe,CAAC,GAAG1J,CAAI,CAAC,CAC1C,CACA,SAASyU,GAAatd,EAAMC,EAAO,CACjC4c,GAAwB7c,EAAMC,CAAK,EACnC,MAAM4I,EAAO7I,EAAK,QACZuU,EAA4B,IAAI,IACtC,QAAS,EAAI,EAAG,EAAItU,EAAM,OAAQ,IAChCsU,EAAU,IAAIqI,GAAa3c,EAAO,EAAG4I,CAAI,CAAC,EAE5C,MAAMlM,EAAuB,IAAI,IAC3BnF,EAAU,CAAA,EAChB,QAAS,EAAI,EAAG,EAAIwI,EAAK,OAAQ,IAAK,CACpC,MAAMpD,EAAMggB,GAAa5c,EAAM,EAAG6I,CAAI,EAClC0L,EAAU,IAAI3X,CAAG,GAAK,CAACD,EAAK,IAAIC,CAAG,IACrCD,EAAK,IAAIC,CAAG,EACZpF,EAAQ,KAAK,CAAC,EAElB,CACA,OAAO2lB,GAAYnd,EAAMxI,CAAO,CAClC,CACA,SAAS+lB,GAAWvd,EAAMC,EAAO,CAC/B4c,GAAwB7c,EAAMC,CAAK,EACnC,MAAM4I,EAAO7I,EAAK,QACZuU,EAA4B,IAAI,IACtC,QAAS,EAAI,EAAG,EAAItU,EAAM,OAAQ,IAChCsU,EAAU,IAAIqI,GAAa3c,EAAO,EAAG4I,CAAI,CAAC,EAE5C,MAAMlM,EAAuB,IAAI,IAC3BnF,EAAU,CAAA,EAChB,QAAS,EAAI,EAAG,EAAIwI,EAAK,OAAQ,IAAK,CACpC,MAAMpD,EAAMggB,GAAa5c,EAAM,EAAG6I,CAAI,EAClC,CAAC0L,EAAU,IAAI3X,CAAG,GAAK,CAACD,EAAK,IAAIC,CAAG,IACtCD,EAAK,IAAIC,CAAG,EACZpF,EAAQ,KAAK,CAAC,EAElB,CACA,OAAO2lB,GAAYnd,EAAMxI,CAAO,CAClC,CAGA,SAASgmB,GAAiBxhB,EAAM,CAC9B,MAAO,IAAIA,EAAK,QAAQ,KAAM,IAAI,CAAC,GACrC,CACA,SAASyhB,GAAe9mB,EAAO,CAC7B,OAAIA,GAAU,KACL,OAEL,OAAOA,GAAU,UACZA,EAAQ,OAAS,QAEtB,OAAOA,GAAU,SACd,SAASA,CAAK,EAGZ,OAAOA,CAAK,EAFV,OAIP,OAAOA,GAAU,SACZ,OAAOA,CAAK,EAEjBA,aAAiB,KACZ,IAAIA,EAAM,YAAW,CAAE,IAE5B,OAAOA,GAAU,SACZ,IAAIA,EAAM,QAAQ,KAAM,IAAI,CAAC,IAG/B,IADM,KAAK,UAAUA,CAAK,EACjB,QAAQ,KAAM,IAAI,CAAC,GACrC,CACA,SAAS+mB,GAASC,EAAWva,EAAQmD,EAAMlE,EAAU,CAAA,EAAI,CACvD,MAAMub,EAAYvb,EAAQ,WAAa,IACvC,GAAIe,EAAO,SAAW,GAAKmD,EAAK,SAAW,EACzC,MAAO,GAET,MAAMsX,EAAaza,EAAO,IAAIoa,EAAgB,EAAE,KAAK,IAAI,EACnDM,EAAa,CAAA,EACnB,QAASlnB,EAAI,EAAGA,EAAI2P,EAAK,OAAQ3P,GAAKgnB,EAAW,CAE/C,MAAMG,EADQxX,EAAK,MAAM3P,EAAGA,EAAIgnB,CAAS,EACjB,IAAK9W,GAEpB,IADQA,EAAI,IAAI2W,EAAc,EAAE,KAAK,IAAI,CAC/B,GAClB,EACDK,EAAW,KACT,eAAeN,GAAiBG,CAAS,CAAC,KAAKE,CAAU;AAAA,EAC7DE,EAAU,KAAK;AAAA,CAAK,CAAC,GACvB,CACE,CACA,OAAOD,EAAW,KAAK;AAAA;AAAA,CAAM,CAC/B,CAGA,IAAIE,GAAa,EACjB,SAASC,IAAiB,CACxB,MAAO,CAAE,KAAM,OAAQ,GAAID,IAAY,CACzC,CACA,SAASE,GAAYC,EAAMC,EAAS,EAAG,CACrC,MAAMC,EAAM,KAAK,OAAOD,CAAM,EAC9B,OAAQD,EAAK,KAAI,CACf,IAAK,OACH,OAAIA,EAAK,WACA,GAAGE,CAAG,YAAYF,EAAK,EAAE,UAAUA,EAAK,WAAW,KAAK,IAAI,CAAC,IAE/D,GAAGE,CAAG,YAAYF,EAAK,EAAE,IAClC,IAAK,SACH,MAAO,GAAGE,CAAG,WAAWF,EAAK,UAAU,UAAU;AAAA,EACrDD,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,SACH,MAAO,GAAGC,CAAG,WAAWF,EAAK,QAAQ,KAAK,IAAI,CAAC;AAAA,EACnDD,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,UAAW,CACd,MAAME,EAAWH,EAAK,MAAM,IAAK7c,GAAMA,EAAE,SAAQ,CAAE,EAAE,KAAK,IAAI,EAC9D,MAAO,GAAG+c,CAAG,YAAYC,CAAQ;AAAA,EACrCJ,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,EACjC,CACA,IAAK,UAAW,CACd,MAAMG,EAAUJ,EAAK,KAAK,IAAKrjB,GAAMA,EAAE,SAAQ,CAAE,EAAE,KAAK,IAAI,EAC5D,MAAO,GAAGujB,CAAG,kBAAkBF,EAAK,KAAK,KAAK,IAAI,CAAC,WAAWI,CAAO;AAAA,EACzEL,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,EACjC,CACA,IAAK,OACH,MAAO,GAAGC,CAAG,SAASF,EAAK,GAAG;AAAA,EAClCE,CAAG;AAAA,EACHH,GAAYC,EAAK,KAAMC,EAAS,CAAC,CAAC;AAAA,EAClCC,CAAG;AAAA,EACHH,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,OACH,MAAO,GAAGC,CAAG,SAASF,EAAK,EAAE,IAAIA,EAAK,WAAa,OAAS,KAAK;AAAA,EACrED,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,QACH,MAAO,GAAGC,CAAG,UAAUF,EAAK,CAAC;AAAA,EACjCD,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,WACH,MAAO,GAAGC,CAAG,WAAWF,EAAK,OAAS,KAAKA,EAAK,OAAO,KAAK,IAAI,CAAC,IAAM,EAAE;AAAA,EAC7ED,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,EACrC,CACA,CAGA,SAASI,GAAQC,EAAM1kB,EAAQ,CAC7B,SAAS2kB,EAAIP,EAAM,CACjB,OAAQA,EAAK,KAAI,CACf,IAAK,OACH,OAAIA,EAAK,WACApkB,EAAO,OAAO,GAAGokB,EAAK,UAAU,EAElCpkB,EACT,IAAK,SAEH,OADc2kB,EAAIP,EAAK,KAAK,EACf,OAAOA,EAAK,SAAS,EAEpC,IAAK,SAEH,OADcO,EAAIP,EAAK,KAAK,EACf,OAAO,GAAGA,EAAK,OAAO,EAErC,IAAK,UAAW,CACd,MAAMpP,EAAQ2P,EAAIP,EAAK,KAAK,EAC5B,IAAIrnB,EAASiY,EACb,UAAWrP,KAAQye,EAAK,MAAO,CAC7B,MAAM/kB,EAASsG,EAAK,SAASqP,CAAK,EAClCjY,EAASA,EAAO,WAAWsC,EAAO,KAAMsG,CAAI,CAC9C,CACA,OAAO5I,CACT,CACA,IAAK,UAAW,CAEd,MAAM6nB,EADQD,EAAIP,EAAK,KAAK,EACX,QAAQ,GAAGA,EAAK,IAAI,EAC/BlM,EAAQ,CAAA,EACd,UAAWE,KAAWgM,EAAK,KAAM,CAC/B,MAAMS,EAAMzM,EAEN4C,EADO6J,EAAI,aACO,CAAC,GAAK,QAC9B3M,EAAM8C,CAAU,EAAI6J,CACtB,CACA,OAAOD,EAAG,IAAI1M,CAAK,CACrB,CACA,IAAK,OAEH,OADcyM,EAAIP,EAAK,KAAK,EACf,OAAOA,EAAK,GAAIA,EAAK,WAAa,OAAS,KAAK,EAE/D,IAAK,QAEH,OADcO,EAAIP,EAAK,KAAK,EACf,KAAKA,EAAK,CAAC,EAE1B,IAAK,WAEH,OADcO,EAAIP,EAAK,KAAK,EACf,OAAOA,EAAK,MAAM,EAEjC,IAAK,OAAQ,CACX,MAAMne,EAAO0e,EAAIP,EAAK,IAAI,EACpBle,EAAQye,EAAIP,EAAK,KAAK,EAC5B,OAAOne,EAAK,KAAKC,EAAOke,EAAK,GAAIA,EAAK,GAAG,CAC3C,CACN,CACE,CACA,OAAOO,EAAID,CAAI,CACjB,CAGA,SAASI,GAASJ,EAAM,CACtB,MAAMK,EAAYC,GAASN,CAAI,EACzBO,EAASC,GAAaH,CAAS,EACrC,OAAOI,GAAmBF,CAAM,CAClC,CACA,SAASD,GAASZ,EAAM,CACtB,OAAQA,EAAK,KAAI,CACf,IAAK,OACH,OAAOA,EACT,IAAK,SAAU,CAEb,MAAMgB,EAAS,CAAE,KAAM,SAAU,MADnBJ,GAASZ,EAAK,KAAK,EACO,UAAWA,EAAK,SAAS,EACjE,OAAOiB,GAAeD,CAAM,CAC9B,CACA,IAAK,SACH,MAAO,CAAE,KAAM,SAAU,MAAOJ,GAASZ,EAAK,KAAK,EAAG,QAASA,EAAK,OAAO,EAC7E,IAAK,UACH,MAAO,CAAE,KAAM,UAAW,MAAOY,GAASZ,EAAK,KAAK,EAAG,MAAOA,EAAK,KAAK,EAC1E,IAAK,UACH,MAAO,CAAE,KAAM,UAAW,MAAOY,GAASZ,EAAK,KAAK,EAAG,KAAMA,EAAK,KAAM,KAAMA,EAAK,IAAI,EACzF,IAAK,OACH,MAAO,CAAE,KAAM,OAAQ,MAAOY,GAASZ,EAAK,KAAK,EAAG,GAAIA,EAAK,GAAI,WAAYA,EAAK,UAAU,EAC9F,IAAK,QACH,MAAO,CAAE,KAAM,QAAS,MAAOY,GAASZ,EAAK,KAAK,EAAG,EAAGA,EAAK,CAAC,EAChE,IAAK,WACH,MAAO,CAAE,KAAM,WAAY,MAAOY,GAASZ,EAAK,KAAK,EAAG,OAAQA,EAAK,MAAM,EAC7E,IAAK,OACH,MAAO,CAAE,KAAM,OAAQ,KAAMY,GAASZ,EAAK,IAAI,EAAG,MAAOY,GAASZ,EAAK,KAAK,EAAG,GAAIA,EAAK,GAAI,IAAKA,EAAK,GAAG,CAC/G,CACA,CACA,SAASiB,GAAeD,EAAQ,CAC9B,MAAME,EAAQF,EAAO,MACrB,OAAQE,EAAM,KAAI,CAEhB,IAAK,SACH,MAAO,CACL,KAAM,SACN,MAAOD,GAAe,CAAE,KAAM,SAAU,MAAOC,EAAM,MAAO,UAAWF,EAAO,SAAS,CAAE,EACzF,QAASE,EAAM,OACvB,EACI,IAAK,UACH,MAAO,CACL,KAAM,UACN,MAAOD,GAAe,CAAE,KAAM,SAAU,MAAOC,EAAM,MAAO,UAAWF,EAAO,SAAS,CAAE,EACzF,MAAOE,EAAM,KACrB,EAEI,IAAK,OACH,MAAO,CACL,KAAM,OACN,MAAOD,GAAe,CAAE,KAAM,SAAU,MAAOC,EAAM,MAAO,UAAWF,EAAO,SAAS,CAAE,EACzF,GAAIE,EAAM,GACV,WAAYA,EAAM,UAC1B,EAEI,IAAK,UACH,OAAOF,EAET,QACE,OAAOA,CACb,CACA,CACA,SAASF,GAAad,EAAM,CAC1B,OAAQA,EAAK,KAAI,CACf,IAAK,OACH,OAAOA,EACT,IAAK,SAAU,CACb,MAAMpP,EAAQkQ,GAAad,EAAK,KAAK,EACrC,OAAIpP,EAAM,OAAS,SACV,CACL,KAAM,SACN,MAAOA,EAAM,MACb,UAAWA,EAAM,UAAU,IAAIoP,EAAK,SAAS,CACvD,EAEa,CAAE,KAAM,SAAU,MAAApP,EAAO,UAAWoP,EAAK,SAAS,CAC3D,CACA,IAAK,SACH,MAAO,CAAE,KAAM,SAAU,MAAOc,GAAad,EAAK,KAAK,EAAG,QAASA,EAAK,OAAO,EACjF,IAAK,UACH,MAAO,CAAE,KAAM,UAAW,MAAOc,GAAad,EAAK,KAAK,EAAG,MAAOA,EAAK,KAAK,EAC9E,IAAK,UACH,MAAO,CAAE,KAAM,UAAW,MAAOc,GAAad,EAAK,KAAK,EAAG,KAAMA,EAAK,KAAM,KAAMA,EAAK,IAAI,EAC7F,IAAK,OACH,MAAO,CAAE,KAAM,OAAQ,MAAOc,GAAad,EAAK,KAAK,EAAG,GAAIA,EAAK,GAAI,WAAYA,EAAK,UAAU,EAClG,IAAK,QACH,MAAO,CAAE,KAAM,QAAS,MAAOc,GAAad,EAAK,KAAK,EAAG,EAAGA,EAAK,CAAC,EACpE,IAAK,WACH,MAAO,CAAE,KAAM,WAAY,MAAOc,GAAad,EAAK,KAAK,EAAG,OAAQA,EAAK,MAAM,EACjF,IAAK,OACH,MAAO,CAAE,KAAM,OAAQ,KAAMc,GAAad,EAAK,IAAI,EAAG,MAAOc,GAAad,EAAK,KAAK,EAAG,GAAIA,EAAK,GAAI,IAAKA,EAAK,GAAG,CACvH,CACA,CACA,SAASe,GAAmBf,EAAMmB,EAAQ,CACxC,OAAQnB,EAAK,KAAI,CACf,IAAK,OAAQ,CACX,GAAImB,GAAUA,EAAO,KAAO,EAAG,CAC7B,MAAMC,EAAa,CAAC,GAAGD,CAAM,EAAE,KAAI,EACnC,MAAO,CAAE,KAAM,OAAQ,GAAInB,EAAK,GAAI,WAAAoB,CAAU,CAChD,CACA,OAAOpB,CACT,CACA,IAAK,SAAU,CACb,MAAMqB,EAAc,IAAI,IAAIrB,EAAK,OAAO,EACxC,MAAO,CAAE,KAAM,SAAU,MAAOe,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,QAASrB,EAAK,OAAO,CACpG,CACA,IAAK,SAAU,CACb,MAAMqB,EAAc,IAAI,IAAIF,CAAM,EAClC,UAAWG,KAAOtB,EAAK,UAAU,aAC/BqB,EAAY,IAAIC,CAAG,EAErB,MAAO,CAAE,KAAM,SAAU,MAAOP,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,UAAWrB,EAAK,SAAS,CACxG,CACA,IAAK,UAAW,CACd,MAAMqB,EAA8B,IAAI,IACxC,UAAW9f,KAAQye,EAAK,MACtB,UAAWsB,KAAO/f,EAAK,aACrB8f,EAAY,IAAIC,CAAG,EAGvB,MAAO,CAAE,KAAM,UAAW,MAAOP,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,MAAOrB,EAAK,KAAK,CACjG,CACA,IAAK,UAAW,CACd,MAAMqB,EAAc,IAAI,IAAIrB,EAAK,IAAI,EACrC,UAAWS,KAAOT,EAAK,KACrB,UAAWsB,KAAOb,EAAI,aACpBY,EAAY,IAAIC,CAAG,EAGvB,MAAO,CAAE,KAAM,UAAW,MAAOP,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,KAAMrB,EAAK,KAAM,KAAMA,EAAK,IAAI,CAChH,CACA,IAAK,OAAQ,CACX,MAAMqB,EAAc,IAAI,IAAIF,CAAM,EAClC,OAAAE,EAAY,IAAIrB,EAAK,EAAE,EAChB,CAAE,KAAM,OAAQ,MAAOe,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,GAAIrB,EAAK,GAAI,WAAYA,EAAK,UAAU,CACrH,CACA,IAAK,QACH,MAAO,CAAE,KAAM,QAAS,MAAOe,GAAmBf,EAAK,MAAOmB,CAAM,EAAG,EAAGnB,EAAK,CAAC,EAClF,IAAK,WAAY,CACf,GAAIA,EAAK,OAAQ,CACf,MAAMqB,EAAc,IAAI,IAAIF,CAAM,EAClC,UAAW5lB,KAAQykB,EAAK,OACtBqB,EAAY,IAAI9lB,CAAI,EAEtB,MAAO,CAAE,KAAM,WAAY,MAAOwlB,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,OAAQrB,EAAK,MAAM,CACpG,CACA,MAAO,CAAE,KAAM,WAAY,MAAOe,GAAmBf,EAAK,MAAOmB,CAAM,EAAG,OAAQnB,EAAK,MAAM,CAC/F,CACA,IAAK,OAAQ,CACX,MAAMuB,EAAS,OAAOvB,EAAK,IAAO,SAAW,CAACA,EAAK,EAAE,EAAIA,EAAK,GACxDwB,EAAa,IAAI,IAAIL,CAAM,EAC3BM,EAAc,IAAI,IAAIN,CAAM,EAClC,UAAWnc,KAAKuc,EACdC,EAAW,IAAIxc,CAAC,EAChByc,EAAY,IAAIzc,CAAC,EAEnB,MAAO,CAAE,KAAM,OAAQ,KAAM+b,GAAmBf,EAAK,KAAMwB,CAAU,EAAG,MAAOT,GAAmBf,EAAK,MAAOyB,CAAW,EAAG,GAAIzB,EAAK,GAAI,IAAKA,EAAK,GAAG,CACxJ,CACJ,CACA,CAGG,IAAC0B,GAAc,KAAM,CAEtB,QAEA,MAEA,MACA,YAAY9lB,EAAQ0kB,EAAMjN,EAAM,CAC9B,KAAK,QAAUzX,EACf,KAAK,MAAQ0kB,EACb,KAAK,MAAQjN,CACf,CACA,OAAOS,EAAO,CACZ,OAAO,IAAI6N,GAAU,KAAK,QAAS,CACjC,KAAM,UACN,MAAO,KAAK,MACZ,KAAM,CAAC,GAAG,KAAK,KAAK,EACpB,KAAM7N,CACZ,CAAK,CACH,CACF,EACI6N,GAAY,MAAMC,EAAW,CAE/B,QAEA,MACA,YAAYhmB,EAAQ0kB,EAAM,CACxB,KAAK,QAAU1kB,EACf,KAAK,MAAQ0kB,CACf,CACA,OAAOhhB,EAAW,CAChB,OAAO,IAAIsiB,GAAW,KAAK,QAAS,CAClC,KAAM,SACN,MAAO,KAAK,MACZ,UAAAtiB,CACN,CAAK,CACH,CACA,UAAUN,EAAS,CACjB,OAAO,IAAI4iB,GAAW,KAAK,QAAS,CAClC,KAAM,SACN,MAAO,KAAK,MACZ,QAAA5iB,CACN,CAAK,CACH,CACA,WAAW+B,EAAO,CAChB,OAAO,IAAI6gB,GAAW,KAAK,QAAS,CAClC,KAAM,UACN,MAAO,KAAK,MACZ,MAAA7gB,CACN,CAAK,CACH,CACA,KAAK8gB,EAAIC,EAAa,GAAO,CAC3B,OAAO,IAAIF,GAAW,KAAK,QAAS,CAClC,KAAM,OACN,MAAO,KAAK,MACZ,GAAAC,EACA,WAAAC,CACN,CAAK,CACH,CACA,OAAOD,EAAIC,EAAa,GAAO,CAC7B,OAAO,KAAK,KAAKD,EAAIC,CAAU,CACjC,CACA,MAAM7kB,EAAG,CACP,OAAO,IAAI2kB,GAAW,KAAK,QAAS,CAClC,KAAM,QACN,MAAO,KAAK,MACZ,EAAA3kB,CACN,CAAK,CACH,CACA,KAAKA,EAAG,CACN,OAAO,KAAK,MAAMA,CAAC,CACrB,CACA,SAAS8kB,EAAQ,CACf,OAAO,IAAIH,GAAW,KAAK,QAAS,CAClC,KAAM,WACN,MAAO,KAAK,MACZ,OAAAG,CACN,CAAK,CACH,CACA,OAAOA,EAAQ,CACb,OAAO,KAAK,SAASA,CAAM,CAC7B,CACA,WAAW1O,EAAM,CACf,OAAO,IAAIqO,GAAY,KAAK,QAAS,KAAK,MAAOrO,CAAI,CACvD,CACA,SAAU,CACR,MAAM2O,EAAWjC,GAAY,KAAK,KAAK,EACjCkC,EAAgBvB,GAAS,KAAK,KAAK,EACnCC,EAAYZ,GAAYkC,CAAa,EAC3C,MAAO;AAAA,EACTD,CAAQ;AAAA;AAAA;AAAA,EAGRrB,CAAS,EACT,CACA,SAAU,CACR,OAAO,QAAQ,QAAQN,GAAQ,KAAK,MAAO,KAAK,OAAO,CAAC,CAC1D,CACA,MAAM,KAAKvX,EAAU,CACnB,MAAMpH,EAAM,MAAM,KAAK,QAAO,EACxBwgB,EAAMpZ,EAAS,YAAW,EAChC,GAAIoZ,EAAI,SAAS,MAAM,GAAKA,EAAI,SAAS,MAAM,EAC7C,MAAMxgB,EAAI,MAAMoH,CAAQ,UACfoZ,EAAI,SAAS,SAAS,GAAKA,EAAI,SAAS,QAAQ,EACzD,MAAMxgB,EAAI,SAASoH,CAAQ,MAE3B,OAAM,IAAI,MAAM,gCAAgCA,CAAQ,2CAA2C,CAEvG,CACF,EACA,SAASqZ,GAAgBvmB,EAAQ,CAC/B,OAAO,IAAI+lB,GAAU/lB,EAAQkkB,IAAgB,CAC/C,CAGA,IAAIsC,GAA2B,IAAI,IAAI,CACrC,SACA,OACA,QACA,QACA,KACA,QACA,QACA,SACA,MACA,KACA,KACA,OACA,KACA,MACA,OACA,MACA,OACA,IACF,CAAC,EACD,SAASC,GAASzR,EAAO,CACvB,MAAM0R,EAAS,CAAA,EACf,IAAI7pB,EAAI,EACR,KAAOA,EAAImY,EAAM,QAAQ,CACvB,GAAI,KAAK,KAAKA,EAAMnY,CAAC,CAAC,EAAG,CACvBA,IACA,QACF,CACA,MAAMmM,EAAMnM,EACZ,GAAImY,EAAMnY,CAAC,IAAM,IAAK,CACpBA,IACA,IAAID,EAAQ,GACZ,KAAOC,EAAImY,EAAM,QAAUA,EAAMnY,CAAC,IAAM,KAClCmY,EAAMnY,CAAC,IAAM,KAAOmY,EAAMnY,EAAI,CAAC,IAAM,KACvCD,GAAS,IACTC,GAAK,IAELD,GAASoY,EAAMnY,CAAC,EAChBA,KAGJ,GAAIA,GAAKmY,EAAM,OACb,MAAM,IAAI9Y,GAAW,2CAA2C8M,CAAG,EAAE,EAEvEnM,IACA6pB,EAAO,KAAK,CAAE,KAAM,SAAuB,MAAA9pB,EAAO,SAAUoM,EAAK,EACjE,QACF,CACA,GAAI,KAAK,KAAKgM,EAAMnY,CAAC,CAAC,GAAKmY,EAAMnY,CAAC,IAAM,KAAOA,EAAI,EAAImY,EAAM,QAAU,KAAK,KAAKA,EAAMnY,EAAI,CAAC,CAAC,EAAG,CAC9F,IAAID,EAAQ,GAKZ,IAJIoY,EAAMnY,CAAC,IAAM,MACfD,GAAS,IACTC,KAEKA,EAAImY,EAAM,QAAU,QAAQ,KAAKA,EAAMnY,CAAC,CAAC,GAC9CD,GAASoY,EAAMnY,CAAC,EAChBA,IAEF6pB,EAAO,KAAK,CAAE,KAAM,SAAuB,MAAA9pB,EAAO,SAAUoM,EAAK,EACjE,QACF,CACA,GAAIgM,EAAMnY,CAAC,IAAM,IAAK,CACpB6pB,EAAO,KAAK,CAAE,KAAM,OAAmB,MAAO,IAAK,SAAU1d,EAAK,EAClEnM,IACA,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,IAAK,CACpB6pB,EAAO,KAAK,CAAE,KAAM,QAAqB,MAAO,IAAK,SAAU1d,EAAK,EACpEnM,IACA,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,IAAK,CACpB6pB,EAAO,KAAK,CAAE,KAAM,SAAuB,MAAO,IAAK,SAAU1d,EAAK,EACtEnM,IACA,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,IAAK,CACpB6pB,EAAO,KAAK,CAAE,KAAM,SAAuB,MAAO,IAAK,SAAU1d,EAAK,EACtEnM,IACA,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,KAAOmY,EAAMnY,EAAI,CAAC,IAAM,IAAK,CAC5C6pB,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,KAAM,SAAU1d,EAAK,EACjEnM,GAAK,EACL,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,KAAOmY,EAAMnY,EAAI,CAAC,IAAM,IAAK,CAC5C6pB,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,KAAM,SAAU1d,EAAK,EACjEnM,GAAK,EACL,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,KAAOmY,EAAMnY,EAAI,CAAC,IAAM,IAAK,CAC5C6pB,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,KAAM,SAAU1d,EAAK,EACjEnM,GAAK,EACL,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,KAAOmY,EAAMnY,EAAI,CAAC,IAAM,IAAK,CAC5C6pB,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,KAAM,SAAU1d,EAAK,EACjEnM,GAAK,EACL,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,IAAK,CACpB6pB,EAAO,KAAK,CAAE,KAAM,KAAe,MAAO,IAAK,SAAU1d,EAAK,EAC9DnM,IACA,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,IAAK,CACpB6pB,EAAO,KAAK,CAAE,KAAM,KAAe,MAAO,IAAK,SAAU1d,EAAK,EAC9DnM,IACA,QACF,CACA,GAAImY,EAAMnY,CAAC,IAAM,IAAK,CACpB6pB,EAAO,KAAK,CAAE,KAAM,KAAe,MAAO,IAAK,SAAU1d,EAAK,EAC9DnM,IACA,QACF,CACA,GAAI,YAAY,KAAKmY,EAAMnY,CAAC,CAAC,EAAG,CAC9B,IAAID,EAAQ,GACZ,KAAOC,EAAImY,EAAM,QAAU,eAAe,KAAKA,EAAMnY,CAAC,CAAC,GACrDD,GAASoY,EAAMnY,CAAC,EAChBA,IAEF,MAAM8pB,EAAQ/pB,EAAM,YAAW,EAC3B4pB,GAAS,IAAIG,CAAK,EACpBD,EAAO,KAAK,CAAE,KAAMC,EAAO,MAAOA,EAAO,SAAU3d,EAAK,EAExD0d,EAAO,KAAK,CAAE,KAAM,aAA+B,MAAA9pB,EAAO,SAAUoM,EAAK,EAE3E,QACF,CACA,MAAM,IAAI9M,GAAW,yBAAyB8Y,EAAMnY,CAAC,CAAC,iBAAiBmM,CAAG,EAAE,CAC9E,CACA,OAAA0d,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,GAAI,SAAU7pB,EAAG,EACtD6pB,CACT,CACA,IAAIE,GAAS,KAAM,CACjB,OACA,IACA,aAAe,CAAA,EACf,YAAYF,EAAQ,CAClB,KAAK,OAASA,EACd,KAAK,IAAM,CACb,CACA,SAAU,CACR,OAAO,KAAK,OAAO,KAAK,GAAG,CAC7B,CACA,MAAO,CACL,OAAO,KAAK,OAAO,KAAK,GAAG,CAC7B,CACA,SAAU,CACR,MAAMG,EAAQ,KAAK,OAAO,KAAK,GAAG,EAClC,YAAK,MACEA,CACT,CACA,OAAOC,EAAM,CACX,MAAMD,EAAQ,KAAK,QAAO,EAC1B,GAAIA,EAAM,OAASC,EACjB,MAAM,IAAI5qB,GACR,YAAY4qB,CAAI,aAAaD,EAAM,KAAK,iBAAiBA,EAAM,QAAQ,EAC/E,EAEI,OAAO,KAAK,QAAO,CACrB,CACA,MAAMC,EAAM,CACV,OAAI,KAAK,UAAU,OAASA,GAC1B,KAAK,QAAO,EACL,IAEF,EACT,CACA,OAAQ,CACN,KAAK,OAAO,QAAQ,EACpB,IAAIC,EAAY,GAChB,MAAMC,EAAc,CAAA,EACpB,GAAI,KAAK,UAAU,OAAS,OAC1BD,EAAY,GACZ,KAAK,QAAO,MAGZ,KADAC,EAAY,KAAK,KAAK,iBAAiB,EAChC,KAAK,MAAM,UAChBA,EAAY,KAAK,KAAK,iBAAiB,EAG3C,KAAK,aAAeA,EACpB,KAAK,OAAO,MAAM,EAClB,MAAMC,EAAY,KAAK,OAAO,YAAY,EAC1C,GAAIA,EAAU,QAAU,OACtB,MAAM,IAAI/qB,GACR,2CAA2C+qB,EAAU,KAAK,iBAAiBA,EAAU,QAAQ,EACrG,EAEI,IAAIC,EACA,KAAK,UAAU,OAAS,UAC1B,KAAK,QAAO,EACZA,EAAY,KAAK,YAAW,GAE9B,MAAMC,EAAiB,CAAA,EACvB,GAAI,KAAK,UAAU,OAAS,QAI1B,IAHA,KAAK,QAAO,EACZ,KAAK,OAAO,IAAI,EAChBA,EAAe,KAAK,KAAK,OAAO,YAAY,EAAmB,KAAK,EAC7D,KAAK,MAAM,UAChBA,EAAe,KAAK,KAAK,OAAO,YAAY,EAAmB,KAAK,EAGxE,IAAIC,EACA,KAAK,UAAU,OAAS,WAC1B,KAAK,QAAO,EACZA,EAAa,KAAK,YAAW,GAE/B,MAAMC,EAAe,CAAA,EACrB,GAAI,KAAK,UAAU,OAAS,QAI1B,IAHA,KAAK,QAAO,EACZ,KAAK,OAAO,IAAI,EAChBA,EAAa,KAAK,KAAK,kBAAkB,EAClC,KAAK,MAAM,UAChBA,EAAa,KAAK,KAAK,kBAAkB,EAG7C,IAAInK,EACJ,GAAI,KAAK,UAAU,OAAS,QAAqB,CAC/C,KAAK,QAAO,EACZ,MAAMoK,EAAM,KAAK,OAAO,QAAQ,EAChCpK,EAAQ,SAASoK,EAAI,MAAO,EAAE,CAChC,CACA,GAAI,KAAK,UAAU,OAAS,MAC1B,MAAM,IAAIprB,GACR,qBAAqB,KAAK,UAAU,KAAK,iBAAiB,KAAK,QAAO,EAAG,QAAQ,EACzF,EAEI,MAAO,CAAE,YAAA8qB,EAAa,UAAAD,EAAW,UAAAG,EAAW,eAAAC,EAAgB,WAAAC,EAAY,aAAAC,EAAc,MAAAnK,CAAK,CAC7F,CACA,iBAAkB,CAChB,MAAM2J,EAAQ,KAAK,QAAO,EACpBU,EAAWV,EAAM,MAAM,YAAW,EACxC,GAAIA,EAAM,OAAS,cAAiC,CAAC,MAAO,MAAO,QAAS,MAAO,KAAK,EAAE,SAASU,CAAQ,GAAK,KAAK,OAAO,KAAK,IAAM,CAAC,GAAG,OAAS,SAAuB,CACzK,MAAMC,EAAUD,EAChB,KAAK,QAAO,EACZ,KAAK,QAAO,EACZ,IAAI/gB,EACA,KAAK,UAAU,OAAS,QAC1BA,EAAa,IACb,KAAK,QAAO,GAEZA,EAAa,KAAK,OAAO,YAAY,EAAmB,MAE1D,KAAK,OAAO,QAAQ,EACpB,IAAIihB,EACJ,OAAI,KAAK,UAAU,OAAS,OAC1B,KAAK,QAAO,EACZA,EAAS,KAAK,OAAO,YAAY,EAAmB,OAE/C,CAAE,OAAQjhB,EAAY,MAAOihB,EAAQ,UAAWD,CAAO,CAChE,CACA,MAAMzV,EAAU,KAAK,OAAO,YAAY,EAAmB,MAC3D,IAAI2V,EACJ,OAAI,KAAK,UAAU,OAAS,OAC1B,KAAK,QAAO,EACZA,EAAQ,KAAK,OAAO,YAAY,EAAmB,OAE9C,CAAE,OAAQ3V,EAAS,MAAA2V,EAAO,UAAW,MAAM,CACpD,CACA,kBAAmB,CACjB,MAAM5rB,EAAS,KAAK,OAAO,YAAY,EAAmB,MAC1D,IAAI6rB,EAAY,MAChB,OAAI,KAAK,UAAU,OAAS,OAC1B,KAAK,QAAO,EACZA,EAAY,OACH,KAAK,QAAO,EAAG,OAAS,SACjC,KAAK,QAAO,EACZA,EAAY,QAEP,CAAE,OAAA7rB,EAAQ,UAAA6rB,CAAS,CAC5B,CAEA,aAAc,CACZ,IAAI1hB,EAAO,KAAK,aAAY,EAC5B,KAAO,KAAK,UAAU,OAAS,MAAe,CAC5C,KAAK,QAAO,EACZ,MAAMC,EAAQ,KAAK,aAAY,EAC/BD,EAAOA,EAAK,GAAGC,CAAK,CACtB,CACA,OAAOD,CACT,CACA,cAAe,CACb,IAAIA,EAAO,KAAK,gBAAe,EAC/B,KAAO,KAAK,UAAU,OAAS,OAAiB,CAC9C,KAAK,QAAO,EACZ,MAAMC,EAAQ,KAAK,gBAAe,EAClCD,EAAOA,EAAK,IAAIC,CAAK,CACvB,CACA,OAAOD,CACT,CACA,iBAAkB,CAChB,GAAI,KAAK,UAAU,OAAS,SAAuB,CACjD,KAAK,QAAO,EACZ,MAAMN,EAAO,KAAK,YAAW,EAC7B,YAAK,OAAO,QAAQ,EACbA,CACT,CACA,GAAI,KAAK,UAAU,OAAS,MAC1B,YAAK,QAAO,EACC,KAAK,gBAAe,EACrB,IAAG,EAEjB,MAAMiiB,EAAY,KAAK,QAAO,EACxBL,EAAWK,EAAU,MAAM,YAAW,EAC5C,GAAIA,EAAU,OAAS,cAAiC,CAAC,MAAO,MAAO,QAAS,MAAO,KAAK,EAAE,SAASL,CAAQ,GAAK,KAAK,OAAO,KAAK,IAAM,CAAC,GAAG,OAAS,SACtJ,OAAO,KAAK,yBAAwB,EAEtC,MAAM/gB,EAAa,KAAK,OAAO,YAAY,EAAmB,MACxDsT,EAAU/S,GAAIP,CAAU,EAC9B,GAAI,KAAK,UAAU,OAAS,KAE1B,OADA,KAAK,QAAO,EACR,KAAK,UAAU,OAAS,OAC1B,KAAK,QAAO,EACZ,KAAK,OAAO,MAAM,EACX,IAAIqhB,GAAYrhB,EAAY,EAAI,IAEzC,KAAK,OAAO,MAAM,EACX,IAAIqhB,GAAYrhB,EAAY,EAAK,GAE1C,GAAI,KAAK,UAAU,OAAS,MAAiB,CAE3C,GADA,KAAK,QAAO,EACR,KAAK,UAAU,OAAS,KAAe,CACzC,KAAK,QAAO,EACZ,MAAM1I,EAAS,KAAK,eAAc,EAClC,IAAIgqB,EAAShO,EAAQ,GAAG9S,EAAIlJ,EAAO,CAAC,CAAC,CAAC,EACtC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IACjCirB,EAASA,EAAO,GAAGhO,EAAQ,GAAG9S,EAAIlJ,EAAOjB,CAAC,CAAC,CAAC,CAAC,EAE/C,OAAOirB,EAAO,IAAG,CACnB,CACA,GAAI,KAAK,UAAU,OAAS,OAAmB,CAC7C,KAAK,QAAO,EACZ,MAAMtoB,EAAU,KAAK,OAAO,QAAQ,EAAe,MACnD,OAAO,KAAK,cAAcgH,EAAYhH,CAAO,EAAE,IAAG,CACpD,CACA,MAAM,IAAItD,GAAW,6CAA6C,KAAK,QAAO,EAAG,QAAQ,EAAE,CAC7F,CACA,GAAI,KAAK,UAAU,OAAS,KAAe,CACzC,KAAK,QAAO,EACZ,MAAM4B,EAAS,KAAK,eAAc,EAClC,IAAIgqB,EAAShO,EAAQ,GAAG9S,EAAIlJ,EAAO,CAAC,CAAC,CAAC,EACtC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IACjCirB,EAASA,EAAO,GAAGhO,EAAQ,GAAG9S,EAAIlJ,EAAOjB,CAAC,CAAC,CAAC,CAAC,EAE/C,OAAOirB,CACT,CACA,GAAI,KAAK,UAAU,OAAS,OAAmB,CAC7C,KAAK,QAAO,EACZ,MAAMtoB,EAAU,KAAK,OAAO,QAAQ,EAAe,MACnD,OAAO,KAAK,cAAcgH,EAAYhH,CAAO,CAC/C,CACA,MAAM2G,EAAK,KAAK,QAAO,EACvB,KAAK,QAAO,EACZ,MAAM4hB,EAAa,KAAK,kBAAiB,EACzC,OAAQ5hB,EAAG,KAAI,CACb,IAAK,KACH,OAAO2T,EAAQ,GAAG9S,EAAI+gB,CAAU,CAAC,EACnC,IAAK,MACH,OAAOjO,EAAQ,IAAI9S,EAAI+gB,CAAU,CAAC,EACpC,IAAK,KACH,OAAOjO,EAAQ,GAAG9S,EAAI+gB,CAAU,CAAC,EACnC,IAAK,MACH,OAAOjO,EAAQ,IAAI9S,EAAI+gB,CAAU,CAAC,EACpC,IAAK,KACH,OAAOjO,EAAQ,GAAG9S,EAAI+gB,CAAU,CAAC,EACnC,IAAK,MACH,OAAOjO,EAAQ,IAAI9S,EAAI+gB,CAAU,CAAC,EACpC,QACE,MAAM,IAAI7rB,GAAW,4CAA4CiK,EAAG,QAAQ,UAAUA,EAAG,KAAK,GAAG,CACzG,CACE,CACA,0BAA2B,CACzB,MAAMqhB,EAAU,KAAK,QAAO,EAAG,MAAM,YAAW,EAChD,KAAK,OAAO,QAAQ,EACpB,IAAIhhB,EACA,KAAK,UAAU,OAAS,QAC1BA,EAAa,IACb,KAAK,QAAO,GAEZA,EAAa,KAAK,OAAO,YAAY,EAAmB,MAE1D,KAAK,OAAO,QAAQ,EAIpB,MAAMwhB,EAHiB,KAAK,aAAa,KACtC3J,GAASA,EAAK,YAAcmJ,GAAWnJ,EAAK,SAAW7X,CAC9D,GACqC,QAAUA,IAAe,IAAM,GAAGghB,EAAQ,YAAW,CAAE,GAAK,GAAGA,EAAQ,YAAW,CAAE,IAAIhhB,CAAU,IAC7HyhB,EAAalhB,GAAIihB,CAAQ,EACzB7hB,EAAK,KAAK,QAAO,EACvB,KAAK,QAAO,EACZ,MAAM4hB,EAAa,KAAK,kBAAiB,EACzC,OAAQ5hB,EAAG,KAAI,CACb,IAAK,KACH,OAAO8hB,EAAW,GAAGjhB,EAAI+gB,CAAU,CAAC,EACtC,IAAK,MACH,OAAOE,EAAW,IAAIjhB,EAAI+gB,CAAU,CAAC,EACvC,IAAK,KACH,OAAOE,EAAW,GAAGjhB,EAAI+gB,CAAU,CAAC,EACtC,IAAK,MACH,OAAOE,EAAW,IAAIjhB,EAAI+gB,CAAU,CAAC,EACvC,IAAK,KACH,OAAOE,EAAW,GAAGjhB,EAAI+gB,CAAU,CAAC,EACtC,IAAK,MACH,OAAOE,EAAW,IAAIjhB,EAAI+gB,CAAU,CAAC,EACvC,QACE,MAAM,IAAI7rB,GAAW,4CAA4CiK,EAAG,QAAQ,UAAUA,EAAG,KAAK,GAAG,CACzG,CACE,CACA,mBAAoB,CAClB,MAAM0gB,EAAQ,KAAK,QAAO,EAC1B,GAAIA,EAAM,OAAS,SACjB,YAAK,QAAO,EACL,WAAWA,EAAM,KAAK,EAE/B,GAAIA,EAAM,OAAS,SACjB,YAAK,QAAO,EACLA,EAAM,MAEf,GAAIA,EAAM,OAAS,OACjB,YAAK,QAAO,EACL,KAET,GAAIA,EAAM,OAAS,aAA+B,CAChD,MAAMF,EAAQE,EAAM,MAAM,YAAW,EACrC,GAAIF,IAAU,OACZ,YAAK,QAAO,EACL,GAET,GAAIA,IAAU,QACZ,YAAK,QAAO,EACL,EAEX,CACA,MAAM,IAAIzqB,GAAW,sCAAsC2qB,EAAM,QAAQ,UAAUA,EAAM,KAAK,GAAG,CACnG,CACA,gBAAiB,CACf,KAAK,OAAO,QAAQ,EACpB,MAAM/oB,EAAS,CAAA,EAEf,IADAA,EAAO,KAAK,KAAK,mBAAmB,EAC7B,KAAK,MAAM,UAChBA,EAAO,KAAK,KAAK,mBAAmB,EAEtC,YAAK,OAAO,QAAQ,EACbA,CACT,CACA,cAAc0I,EAAYhH,EAAS,CACjC,MAAM0oB,EAAW,IAAM1oB,EAAQ,QAAQ,sBAAuB,MAAM,EAAE,QAAQ,KAAM,IAAI,EAAE,QAAQ,KAAM,GAAG,EAAI,IAC/G,OAAO,IAAI2oB,GAAS3hB,EAAY0hB,CAAQ,CAC1C,CACF,EACIC,GAAW,cAAcvkB,CAAK,CAChC,YACA,UACA,YAAY4C,EAAY0hB,EAAU,CAChC,MAAK,EACL,KAAK,YAAc1hB,EACnB,KAAK,UAAY0hB,CACnB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,KAAK,WAAW,CAC1B,CACA,SAASpiB,EAAK,CACZ,MAAMzG,EAASyG,EAAI,IAAI,KAAK,WAAW,EACjCsiB,EAAQ,IAAI,OAAO,KAAK,SAAS,EACjCtoB,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,OAAO,IAAIxC,CAAC,EAC3BgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKsoB,EAAM,KAAK,OAAOvqB,GAAQ,SAAWA,EAAM,GAAGA,CAAG,EAAE,CAAC,CAErE,CACA,OAAO,IAAIgC,EAAO,cAAef,EAAc,KAAKgB,CAAO,CAAC,CAC9D,CACA,UAAW,CACT,MAAO,QAAQ,KAAK,WAAW,KAAK,KAAK,SAAS,GACpD,CACF,EACI+nB,GAAc,cAAcjkB,CAAK,CACnC,YACA,QACA,YAAY4C,EAAY6hB,EAAQ,CAC9B,MAAK,EACL,KAAK,YAAc7hB,EACnB,KAAK,QAAU6hB,CACjB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,KAAK,WAAW,CAC1B,CACA,SAASviB,EAAK,CACZ,MAAMzG,EAASyG,EAAI,IAAI,KAAK,WAAW,EACvC,OAAO,KAAK,QAAUzG,EAAO,UAAS,EAAKA,EAAO,OAAM,CAC1D,CACA,UAAW,CACT,MAAO,GAAG,KAAK,WAAW,OAAO,KAAK,QAAU,OAAS,EAAE,MAC7D,CACF,EACA,SAASipB,GAAatB,EAAaG,EAAgB,CACjD,MAAMjP,EAAQ,CAAA,EACd,UAAWmG,KAAQ2I,EAAa,CAE9B,GADIG,EAAe,SAAS9I,EAAK,MAAM,GACnCA,EAAK,YAAc,OAAQ,SAC/B,MAAMqJ,EAAQrJ,EAAK,QAAUA,EAAK,SAAW,IAAM,GAAGA,EAAK,UAAU,YAAW,CAAE,GAAK,GAAGA,EAAK,UAAU,YAAW,CAAE,IAAIA,EAAK,MAAM,IAC/HpF,EAAYoF,EAAK,SAAW,IAAM8I,EAAe,CAAC,EAAI9I,EAAK,OAC3DkK,EAASxhB,GAAIkS,CAAS,EAC5B,OAAQoF,EAAK,UAAS,CACpB,IAAK,MACHnG,EAAMwP,CAAK,EAAIa,EAAO,IAAG,EACzB,MACF,IAAK,MACHrQ,EAAMwP,CAAK,EAAIa,EAAO,KAAI,EAC1B,MACF,IAAK,QACHrQ,EAAMwP,CAAK,EAAIa,EAAO,MAAK,EAC3B,MACF,IAAK,MACHrQ,EAAMwP,CAAK,EAAIa,EAAO,IAAG,EACzB,MACF,IAAK,MACHrQ,EAAMwP,CAAK,EAAIa,EAAO,IAAG,EACzB,KACR,CACE,CACA,OAAOrQ,CACT,CACA,SAASsQ,GAAa1iB,EAAK2iB,EAAU,CACnC,MAAM/B,EAASD,GAASgC,CAAQ,EAE1BC,EADS,IAAI9B,GAAOF,CAAM,EACX,MAAK,EAC1B,IAAI3pB,EAAS+I,EAIb,GAHI4iB,EAAM,YAAc,SACtB3rB,EAASA,EAAO,OAAO2rB,EAAM,SAAS,GAEpCA,EAAM,eAAe,OAAS,EAAG,CACnC,MAAMC,EAAUL,GAAaI,EAAM,YAAaA,EAAM,cAAc,EAMpE,GAJA3rB,EADcA,EAAO,QAAQ,GAAG2rB,EAAM,cAAc,EACrC,IAAIC,CAAO,EACtBD,EAAM,aAAe,SACvB3rB,EAASA,EAAO,OAAO2rB,EAAM,UAAU,GAErC,CAACA,EAAM,UAAW,CACpB,MAAME,EAAe,CAAA,EACrB,UAAWvK,KAAQqK,EAAM,YACvB,GAAIrK,EAAK,YAAc,OAAQ,CAC7B,MAAMqJ,EAAQrJ,EAAK,QAAUA,EAAK,SAAW,IAAM,GAAGA,EAAK,UAAU,YAAW,CAAE,GAAK,GAAGA,EAAK,UAAU,YAAW,CAAE,IAAIA,EAAK,MAAM,IACrIuK,EAAa,KAAKlB,CAAK,CACzB,MACEkB,EAAa,KAAKvK,EAAK,OAASA,EAAK,MAAM,EAG/CthB,EAASA,EAAO,OAAO,GAAG6rB,CAAY,CACxC,CACF,SACM,CAACF,EAAM,UAAW,CACpB,MAAMG,EAAcH,EAAM,YAAY,IAAKrK,GAASA,EAAK,MAAM,EAC/DthB,EAASA,EAAO,OAAO,GAAG8rB,CAAW,EACrC,MAAMC,EAAY,CAAA,EAClB,UAAWzK,KAAQqK,EAAM,YACnBrK,EAAK,QAAU,SACjByK,EAAUzK,EAAK,MAAM,EAAIA,EAAK,OAG9B,OAAO,KAAKyK,CAAS,EAAE,OAAS,IAClC/rB,EAASA,EAAO,OAAO+rB,CAAS,EAEpC,CAEF,GAAIJ,EAAM,aAAa,OAAS,EAAG,CACjC,MAAMtlB,EAAUslB,EAAM,aAAa,IAAKrK,GAASA,EAAK,MAAM,EACtD0K,EAASL,EAAM,aAAa,IAAKrK,GAASA,EAAK,SAAS,EAC9DthB,EAASA,EAAO,OAAOqG,EAAS2lB,CAAM,CACxC,CACA,OAAIL,EAAM,QAAU,SAClB3rB,EAASA,EAAO,KAAK2rB,EAAM,KAAK,GAE3B3rB,CACT,CAGG,IAACisB,GAAY,MAAMC,CAAW,CAC/B,OAAO,SAA2B,IAAI,IACtC,OAAO,SAA2B,IAAI,IACtC,SACA,aACA,YAAY7lB,EAAS6R,EAAa,CAChC,KAAK,SAAW7R,EAChB,KAAK,aAAe6R,EACpB,UAAWtV,KAAQyD,EAAQ,SACzBzD,EAAK,OAAM,CAEf,CACA,IAAI,OAAQ,CACV,MAAO,CAAC,KAAK,OAAQ,KAAK,aAAa,MAAM,CAC/C,CACA,IAAI,SAAU,CACZ,MAAO,CAAC,GAAG,KAAK,YAAY,CAC9B,CACA,IAAI,QAAS,CACX,MAAM5C,EAAS,CAAA,EACf,UAAWkF,KAAQ,KAAK,aACtBlF,EAAOkF,CAAI,EAAI,KAAK,SAAS,IAAIA,CAAI,EAAE,MAEzC,OAAOlF,CACT,CACA,IAAI,QAAS,CACX,OAAI,KAAK,aAAa,SAAW,EAAU,EACpC,KAAK,SAAS,IAAI,KAAK,aAAa,CAAC,CAAC,EAAE,MACjD,CACA,IAAIkF,EAAM,CACR,MAAMnG,EAAS,KAAK,SAAS,IAAImG,CAAI,EACrC,GAAI,CAACnG,EACH,MAAM,IAAID,EAAoBoG,EAAM,KAAK,YAAY,EAEvD,OAAO,IAAIpC,EAAOoC,EAAMnG,CAAM,CAChC,CACA,IAAIW,EAAO,CACT,GAAIA,EAAQ,GAAKA,GAAS,KAAK,OAC7B,MAAM,IAAIf,EACR,oBACA,aAAae,CAAK,qCAAqC,KAAK,MAAM,OAC1E,EAEI,MAAMM,EAAS,CAAA,EACf,UAAWkF,KAAQ,KAAK,aACtBlF,EAAOkF,CAAI,EAAI,KAAK,SAAS,IAAIA,CAAI,EAAE,IAAIxF,CAAK,EAElD,OAAOM,CACT,CACA,EAAE,OAAO,QAAQ,GAAI,CACnB,QAASF,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/B,MAAM,KAAK,IAAIA,CAAC,CAEpB,CACA,MAAO,CACL,OAAO,KAAK,OAAO,QAAQ,EAAC,CAC9B,CACA,SAAU,CACR,MAAME,EAAS,CAAA,EACf,QAASF,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/BE,EAAO,KAAK,KAAK,IAAIF,CAAC,CAAC,EAEzB,OAAOE,CACT,CACA,OAAQ,CACN,MAAMmsB,EAAgC,IAAI,IAC1C,SAAW,CAACjnB,EAAMtC,CAAI,IAAK,KAAK,SAC9BupB,EAAc,IAAIjnB,EAAMtC,EAAK,MAAK,CAAE,EAEtC,OAAO,IAAIspB,EAAWC,EAAe,CAAC,GAAG,KAAK,YAAY,CAAC,CAC7D,CACA,OAAQ,CACN,OAAO,KAAK,MAAK,CACnB,CACA,MAAO,CACL,OAAO3C,GAAgB,IAAI,CAC7B,CACA,UAAUnjB,EAAS,CACjB,UAAWnB,KAAQmB,EACjB,GAAI,CAAC,KAAK,SAAS,IAAInB,CAAI,EACzB,MAAM,IAAIpG,EAAoBoG,EAAM,KAAK,YAAY,EAGzD,MAAMgY,EAA6B,IAAI,IACvC,UAAWhY,KAAQmB,EACjB6W,EAAW,IAAIhY,EAAM,KAAK,SAAS,IAAIA,CAAI,CAAC,EAE9C,OAAO,IAAIgnB,EAAWhP,EAAY,CAAC,GAAG7W,CAAO,CAAC,CAChD,CACA,QAAQA,EAAS,CACf,UAAWnB,KAAQmB,EACjB,GAAI,CAAC,KAAK,SAAS,IAAInB,CAAI,EACzB,MAAM,IAAIpG,EAAoBoG,EAAM,KAAK,YAAY,EAGzD,MAAMknB,EAAU,IAAI,IAAI/lB,CAAO,EACzB6W,EAA6B,IAAI,IACjCmP,EAAW,CAAA,EACjB,UAAWnnB,KAAQ,KAAK,aACjBknB,EAAQ,IAAIlnB,CAAI,IACnBgY,EAAW,IAAIhY,EAAM,KAAK,SAAS,IAAIA,CAAI,CAAC,EAC5CmnB,EAAS,KAAKnnB,CAAI,GAGtB,OAAO,IAAIgnB,EAAWhP,EAAYmP,CAAQ,CAC5C,CACA,KAAK/nB,EAAI,EAAG,CACV,OAAO,KAAK,MAAM,EAAG,KAAK,IAAIA,EAAG,KAAK,MAAM,CAAC,CAC/C,CACA,KAAKA,EAAI,EAAG,CACV,MAAMhE,EAAQ,KAAK,IAAI,EAAG,KAAK,OAASgE,CAAC,EACzC,OAAO,KAAK,MAAMhE,EAAO,KAAK,MAAM,CACtC,CACA,MAAMA,EAAOC,EAAK,CAChB,MAAM+rB,EAAc/rB,IAAQ,OAAS,KAAK,OAAS,KAAK,IAAIA,EAAK,KAAK,MAAM,EACtEgsB,EAAgB,KAAK,IAAI,EAAGjsB,CAAK,EACjC4c,EAA6B,IAAI,IACvC,UAAWhY,KAAQ,KAAK,aACtBgY,EAAW,IAAIhY,EAAM,KAAK,SAAS,IAAIA,CAAI,EAAE,MAAMqnB,EAAeD,CAAW,CAAC,EAEhF,OAAO,IAAIJ,EAAWhP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,WAAWhY,EAAMsnB,EAAkB,CACjC,GAAIA,aAA4B3lB,EAAM,CACpC,MAAMvE,EAASkqB,EAAiB,SAAS,IAAI,EACvCC,EAAc,IAAI,IAAI,KAAK,QAAQ,EACzCA,EAAY,IAAIvnB,EAAM5C,EAAO,MAAM,EACnC,MAAMoqB,EAAY,KAAK,aAAa,SAASxnB,CAAI,EAAI,CAAC,GAAG,KAAK,YAAY,EAAI,CAAC,GAAG,KAAK,aAAcA,CAAI,EACzG,OAAO,IAAIgnB,EAAWO,EAAaC,CAAS,CAC9C,CACA,IAAIC,EACJ,GAAI,OAAOH,GAAqB,WAAY,CAC1C,MAAMrpB,EAAKqpB,EACXG,EAAe,CAAA,EACf,QAAS7sB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/B6sB,EAAa,KAAKxpB,EAAG,KAAK,IAAIrD,CAAC,CAAC,CAAC,CAErC,SACE6sB,EAAeH,EACXG,EAAa,SAAW,KAAK,OAC/B,MAAM,IAAIztB,GACR,WAAWgG,CAAI,gBAAgBynB,EAAa,MAAM,cAAc,KAAK,MAAM,EACrF,EAGI,MAAMrmB,EAAQsmB,GAAaD,CAAY,EACjCE,EAASC,GAAYxmB,EAAOqmB,CAAY,EACxCzP,EAAa,IAAI,IAAI,KAAK,QAAQ,EACxCA,EAAW,IAAIhY,EAAM2nB,CAAM,EAC3B,MAAMR,EAAW,KAAK,aAAa,SAASnnB,CAAI,EAAI,CAAC,GAAG,KAAK,YAAY,EAAI,CAAC,GAAG,KAAK,aAAcA,CAAI,EACxG,OAAO,IAAIgnB,EAAWhP,EAAYmP,CAAQ,CAC5C,CACA,OAAOtsB,EAAO,CACZ,GAAIA,EAAM,SAAW,KAAK,QAAUA,EAAM,QAAQ,OAAS,GAAK,KAAK,aAAa,OAAS,EACzF,MAAM,IAAIb,GACR,gCAAgCa,EAAM,MAAM,2BAA2B,KAAK,MAAM,OAC1F,EAEI,MAAMmd,EAAa,IAAI,IAAI,KAAK,QAAQ,EAClCmP,EAAW,CAAC,GAAG,KAAK,YAAY,EACtC,UAAWnnB,KAAQnF,EAAM,QACvBmd,EAAW,IAAIhY,EAAMnF,EAAM,SAAS,IAAImF,CAAI,CAAC,EACxC,KAAK,aAAa,SAASA,CAAI,GAClCmnB,EAAS,KAAKnnB,CAAI,EAGtB,OAAO,IAAIgnB,EAAWhP,EAAYmP,CAAQ,CAC5C,CACA,OAAOjkB,EAAO,CACZ,IAAIpI,EAAS,KACb,SAAW,CAACkF,EAAM/B,CAAE,IAAK,OAAO,QAAQiF,CAAK,EAAG,CAC9C,GAAI,KAAK,SAAW,EAAG,CACrBpI,EAASA,EAAO,WAAWkF,EAAM,CAAA,CAAE,EACnC,QACF,CACA,MAAMqgB,EAAQpiB,EAAG,KAAK,IAAI,CAAC,CAAC,EAC5B,GAAIoiB,aAAiB1e,EAAM,CACzB7G,EAASA,EAAO,WAAWkF,EAAMqgB,EAAM,SAAS,IAAI,EAAE,SAAS,EAC/D,QACF,CACA,MAAMxkB,EAAS,CAACwkB,CAAK,EACrB,QAASzlB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/BiB,EAAO,KAAKoC,EAAG,KAAK,IAAIrD,CAAC,CAAC,CAAC,EAE7BE,EAASA,EAAO,WAAWkF,EAAMnE,CAAM,CACzC,CACA,OAAOf,CACT,CACA,OAAOD,EAAOwd,EAAIxc,EAAQ,CACxB,OAAOgf,GAAO,KAAMhgB,EAAOwd,EAAIxc,CAAM,CACvC,CACA,OAAOhC,EAAQwM,EAAS,CACtB,OAAO2U,GAAO,KAAMnhB,EAAQwM,CAAO,CACrC,CACA,OAAOlF,EAASkF,EAAS,CACvB,OAAOoV,GAAO,KAAMta,EAASkF,CAAO,CACtC,CACA,OAAOxK,EAAQwK,EAAS,CACtB,OAAOgW,GAAO,KAAMxgB,EAAQwK,CAAO,CACrC,CACA,SAASlF,EAASkF,EAAS,CACzB,KAAM,CAAE,OAAAwhB,EAAQ,MAAAC,CAAK,EAAKzhB,EAC1B,GAAIwhB,IAAW,QAAUC,IAAU,OACjC,MAAM,IAAIruB,EACR,oBACA,sDACR,EAEI,GAAIouB,IAAW,QAAUC,IAAU,OACjC,MAAM,IAAIruB,EACR,oBACA,qDACR,EAEI,UAAWiE,KAAQyD,EACjB,GAAI,CAAC,KAAK,SAAS,IAAIzD,CAAI,EACzB,MAAM,IAAI9D,EAAoB8D,EAAM,KAAK,YAAY,EAGzD,MAAMqqB,EAASF,GAAUC,EACzB,GAAI,CAAC,KAAK,SAAS,IAAIC,CAAM,EAC3B,MAAM,IAAInuB,EAAoBmuB,EAAQ,KAAK,YAAY,EAEzD,MAAMta,EAAY,KAAK,aAAa,OAAQtG,GAAM,CAAChG,EAAQ,SAASgG,CAAC,CAAC,EAChE6gB,EAAYva,EAAU,QAAQsa,CAAM,EACpCE,EAAYJ,IAAW,OAASG,EAAYA,EAAY,EACxDb,EAAW,CAAC,GAAG1Z,EAAU,MAAM,EAAGwa,CAAS,EAAG,GAAG9mB,EAAS,GAAGsM,EAAU,MAAMwa,CAAS,CAAC,EAC7F,OAAO,IAAIjB,EAAW,IAAI,IAAI,KAAK,QAAQ,EAAGG,CAAQ,CACxD,CACA,OAAOe,EAAS,CACd,UAAWC,KAAW,OAAO,KAAKD,CAAO,EACvC,GAAI,CAAC,KAAK,SAAS,IAAIC,CAAO,EAC5B,MAAM,IAAIvuB,EAAoBuuB,EAAS,KAAK,YAAY,EAG5D,MAAMnQ,EAA6B,IAAI,IACjCmP,EAAW,CAAA,EACjB,UAAWnnB,KAAQ,KAAK,aAAc,CACpC,MAAMooB,EAAUF,EAAQloB,CAAI,GAAKA,EACjCgY,EAAW,IAAIoQ,EAAS,KAAK,SAAS,IAAIpoB,CAAI,CAAC,EAC/CmnB,EAAS,KAAKiB,CAAO,CACvB,CACA,OAAO,IAAIpB,EAAWhP,EAAYmP,CAAQ,CAC5C,CACA,OAAOkB,EAAiB,CACtB,GAAIA,aAA2B1mB,EAAM,CAEnC,MAAM2mB,EADWD,EAEjB,GAAIC,EAAO,MAAQ,QAAUA,EAAO,iBAAiBxkB,IAAcwkB,EAAO,kBAAkBllB,GAAa,CACvG,MAAMmB,EAAa+jB,EAAO,MAAM,aAAa,CAAC,EACxC9jB,EAAU8jB,EAAO,OAAO,OACxBvqB,EAAS,KAAK,SAAS,IAAIwG,CAAU,EAC3C,GAAIxG,EAAQ,CACV,GAAIA,aAAkB7B,GAAc6B,EAAO,YAAc,OAAOyG,GAAY,WAAa8jB,EAAO,MAAQ,MAAQA,EAAO,MAAQ,OAAQ,CACrI,MAAMlsB,EAAW2B,EAAO,gBAClBwqB,EAAYnsB,EAAS,WAAW,QAAQoI,CAAO,EAC/CgkB,EAAOF,EAAO,MAAQ,KAC5B,GAAIE,GAAQD,IAAc,GACxB,OAAO,KAAK,MAAM,EAAG,CAAC,EAExB,MAAM7S,EAAkBtZ,EAAS,QAC3BgD,EAAI,KAAK,OACf,GAAIrB,EAAO,SAAU,CACnB,IAAI0qB,EAAS,EACb,GAAID,EACF,QAAS5tB,EAAI,EAAGA,EAAIwE,EAAGxE,IACjB8a,EAAgB9a,CAAC,IAAM2tB,GAAWE,QAEnC,CACL,GAAIF,IAAc,GAChB,OAAO,KAET,QAAS3tB,EAAI,EAAGA,EAAIwE,EAAGxE,IACjB8a,EAAgB9a,CAAC,IAAM2tB,GAAWE,GAE1C,CACA,GAAIA,IAAWrpB,EAAG,OAAO,KACzB,GAAIqpB,IAAW,EAAG,OAAO,KAAK,MAAM,EAAG,CAAC,EACxC,MAAMC,EAAW,IAAI,WAAWD,CAAM,EACtC,IAAIE,EAAO,EACX,GAAIH,EACF,QAAS5tB,EAAI,EAAGA,EAAIwE,EAAGxE,IACjB8a,EAAgB9a,CAAC,IAAM2tB,IAAWG,EAASC,GAAM,EAAI/tB,OAG3D,SAASA,EAAI,EAAGA,EAAIwE,EAAGxE,IACjB8a,EAAgB9a,CAAC,IAAM2tB,IAAWG,EAASC,GAAM,EAAI/tB,GAG7D,OAAO,KAAK,oBAAoB8tB,CAAQ,CAC1C,KAAO,CACL,MAAM1tB,EAAW+C,EAAO,SACxB,IAAI0qB,EAAS,EACb,GAAID,EACF,QAAS5tB,EAAI,EAAGA,EAAIwE,EAAGxE,IACjBI,EAAS,UAAUJ,CAAC,GAAK8a,EAAgB9a,CAAC,IAAM2tB,GAAWE,QAGjE,SAAS7tB,EAAI,EAAGA,EAAIwE,EAAGxE,IACjBI,EAAS,UAAUJ,CAAC,GAAK8a,EAAgB9a,CAAC,IAAM2tB,GAAWE,IAGnE,GAAIA,IAAWrpB,EAAG,OAAO,KACzB,GAAIqpB,IAAW,EAAG,OAAO,KAAK,MAAM,EAAG,CAAC,EACxC,MAAMC,EAAW,IAAI,WAAWD,CAAM,EACtC,IAAIE,EAAO,EACX,GAAIH,EACF,QAAS5tB,EAAI,EAAGA,EAAIwE,EAAGxE,IACjBI,EAAS,UAAUJ,CAAC,GAAK8a,EAAgB9a,CAAC,IAAM2tB,IAAWG,EAASC,GAAM,EAAI/tB,OAGpF,SAASA,EAAI,EAAGA,EAAIwE,EAAGxE,IACjBI,EAAS,UAAUJ,CAAC,GAAK8a,EAAgB9a,CAAC,IAAM2tB,IAAWG,EAASC,GAAM,EAAI/tB,GAGtF,OAAO,KAAK,oBAAoB8tB,CAAQ,CAC1C,CACF,CACA,IAAIE,EAAS,EACb,QAAShuB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMmB,EAAIgC,EAAO,IAAInD,CAAC,EACtB,GAAImB,IAAM,MAAQyI,IAAY,KAAM,SACpC,IAAIqkB,EAAO,GACX,OAAQP,EAAO,IAAG,CAChB,IAAK,KACHO,EAAO9sB,IAAMyI,EACb,MACF,IAAK,MACHqkB,EAAO9sB,IAAMyI,EACb,MACF,IAAK,KACHqkB,EAAO9sB,EAAIyI,EACX,MACF,IAAK,MACHqkB,EAAO9sB,GAAKyI,EACZ,MACF,IAAK,KACHqkB,EAAO9sB,EAAIyI,EACX,MACF,IAAK,MACHqkB,EAAO9sB,GAAKyI,EACZ,KAChB,CACgBqkB,GAAMD,GACZ,CACA,GAAIA,IAAW,KAAK,OAClB,OAAO,KAET,GAAIA,IAAW,EACb,OAAO,KAAK,MAAM,EAAG,CAAC,EAExB,MAAME,EAAW,IAAI,WAAWF,CAAM,EACtC,IAAIG,EAAO,EACX,QAASnuB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMmB,EAAIgC,EAAO,IAAInD,CAAC,EACtB,GAAImB,IAAM,MAAQyI,IAAY,KAAM,SACpC,IAAIqkB,EAAO,GACX,OAAQP,EAAO,IAAG,CAChB,IAAK,KACHO,EAAO9sB,IAAMyI,EACb,MACF,IAAK,MACHqkB,EAAO9sB,IAAMyI,EACb,MACF,IAAK,KACHqkB,EAAO9sB,EAAIyI,EACX,MACF,IAAK,MACHqkB,EAAO9sB,GAAKyI,EACZ,MACF,IAAK,KACHqkB,EAAO9sB,EAAIyI,EACX,MACF,IAAK,MACHqkB,EAAO9sB,GAAKyI,EACZ,KAChB,CACgBqkB,IAAMC,EAASC,GAAM,EAAInuB,EAC/B,CACA,OAAO,KAAK,oBAAoBkuB,CAAQ,CAC1C,CACF,CACA,MAAME,EAAaX,EAAgB,SAAS,IAAI,EAChD,IAAIY,EAAS,EACb,QAASruB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC3BouB,EAAW,IAAIpuB,CAAC,IAAM,IACxBquB,IAGJ,GAAIA,IAAW,KAAK,OAClB,OAAO,KAET,GAAIA,IAAW,EACb,OAAO,KAAK,MAAM,EAAG,CAAC,EAExB,MAAMC,EAAW,IAAI,WAAWD,CAAM,EACtC,IAAIE,EAAO,EACX,QAASvuB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC3BouB,EAAW,IAAIpuB,CAAC,IAAM,KACxBsuB,EAASC,GAAM,EAAIvuB,GAGvB,OAAO,KAAK,oBAAoBsuB,CAAQ,CAC1C,CACA,MAAMznB,EAAY4mB,EAClB,IAAItvB,EAAQ,EACZ,QAAS,EAAI,EAAG,EAAI,KAAK,OAAQ,IAC3B0I,EAAU,KAAK,IAAI,CAAC,CAAC,GACvB1I,IAGJ,GAAIA,IAAU,KAAK,OACjB,OAAO,KAET,GAAIA,IAAU,EACZ,OAAO,KAAK,MAAM,EAAG,CAAC,EAExB,MAAMyC,EAAU,IAAI,WAAWzC,CAAK,EACpC,IAAIgO,EAAM,EACV,QAAS,EAAI,EAAG,EAAI,KAAK,OAAQ,IAC3BtF,EAAU,KAAK,IAAI,CAAC,CAAC,IACvBjG,EAAQuL,GAAK,EAAI,GAGrB,OAAO,KAAK,oBAAoBvL,CAAO,CACzC,CACA,MAAMyC,EAAI,CACR,GAAI,KAAK,SAAW,EAClB,OAAO,IAAI+oB,EAA2B,IAAI,IAAO,CAAC,GAAG,KAAK,YAAY,CAAC,EAEzE,MAAMzc,EAAO,CAAA,EACb,QAAS3P,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/B2P,EAAK,KAAKtM,EAAG,KAAK,IAAIrD,CAAC,CAAC,CAAC,EAE3B,OAAOosB,EAAW,SAASzc,CAAI,CACjC,CACA,MAAM1Q,EAAQqK,EAAIvJ,EAAO,CACvB,MAAMkd,EAAU/S,GAAIjL,CAAM,EACpBuvB,EAAWzuB,EACjB,IAAI+I,EACJ,OAAQQ,EAAE,CACR,IAAK,IACHR,EAAOmU,EAAQ,GAAGuR,CAAQ,EAC1B,MACF,IAAK,KACH1lB,EAAOmU,EAAQ,IAAIuR,CAAQ,EAC3B,MACF,IAAK,IACH1lB,EAAOmU,EAAQ,GAAGuR,CAAQ,EAC1B,MACF,IAAK,KACH1lB,EAAOmU,EAAQ,IAAIuR,CAAQ,EAC3B,MACF,IAAK,IACH1lB,EAAOmU,EAAQ,GAAGuR,CAAQ,EAC1B,MACF,IAAK,KACH1lB,EAAOmU,EAAQ,IAAIuR,CAAQ,EAC3B,KACR,CACI,OAAO,KAAK,OAAO1lB,CAAI,CACzB,CACA,OAAOvC,EAASL,EAAO,CACrB,MAAM+L,EAAO,MAAM,QAAQ1L,CAAO,EAAIA,EAAU,CAACA,CAAO,EAClD2lB,EAAS,MAAM,QAAQhmB,CAAK,EAAIA,EAAQ+L,EAAK,IAAI,IAAM/L,GAAS,KAAK,EAC3E,UAAWd,KAAQ6M,EACjB,GAAI,CAAC,KAAK,SAAS,IAAI7M,CAAI,EACzB,MAAM,IAAIpG,EAAoBoG,EAAM,KAAK,YAAY,EAGzD,GAAI6M,EAAK,SAAW,EAAG,CACrB,MAAMwc,EAAU,KAAK,SAAS,IAAIxc,EAAK,CAAC,CAAC,EACnCyc,EAAOxC,EAAO,CAAC,IAAM,OAC3B,GAAIuC,aAAmBntB,GAAcmtB,EAAQ,WAAY,CACvD,MAAMjtB,EAAWitB,EAAQ,gBACnB1T,EAAUvZ,EAAS,WAAW,OAC9BmtB,EAAoB,MAAM,KAAK,CAAE,OAAQ5T,CAAO,EAAI,CAACnO,EAAG5M,IAAMA,CAAC,EACrE2uB,EAAkB,KAAK,CAACzqB,EAAGC,IAAM,CAC/B,MAAMyqB,EAAKptB,EAAS,WAAW0C,CAAC,EAC1B2qB,EAAKrtB,EAAS,WAAW2C,CAAC,EAC1B2qB,EAAMF,EAAKC,EAAK,GAAKD,EAAKC,EAAK,EAAI,EACzC,OAAOH,EAAO,CAACI,EAAMA,CACvB,CAAC,EACD,MAAMC,EAAO,IAAI,YAAYhU,CAAO,EACpC,QAASnU,EAAI,EAAGA,EAAImU,EAASnU,IAC3BmoB,EAAKJ,EAAkB/nB,CAAC,CAAC,EAAIA,EAE/B,MAAMpC,EAAI,KAAK,OACTsW,EAAkBtZ,EAAS,QAC3B0sB,EAAW,MAAM,KAAK,CAAE,OAAQ1pB,CAAC,EAAI,CAACoI,EAAG5M,IAAMA,CAAC,EACtD,GAAIyuB,EAAQ,SACVP,EAAS,KAAK,CAAChqB,EAAGC,IAAM4qB,EAAKjU,EAAgB5W,CAAC,CAAC,EAAI6qB,EAAKjU,EAAgB3W,CAAC,CAAC,CAAC,MACtE,CACL,MAAM/D,EAAWquB,EAAQ,SACzBP,EAAS,KAAK,CAAChqB,EAAGC,IAAM,CACtB,MAAM6qB,EAAS5uB,EAAS,UAAU8D,CAAC,EAC7B+qB,EAAS7uB,EAAS,UAAU+D,CAAC,EACnC,MAAI,CAAC6qB,GAAU,CAACC,EAAe,EAC1BD,EACAC,EACEF,EAAKjU,EAAgB5W,CAAC,CAAC,EAAI6qB,EAAKjU,EAAgB3W,CAAC,CAAC,EADrC,GADA,CAGtB,CAAC,CACH,CACA,MAAM+qB,EAAgB,IAAI,WAAWhB,CAAQ,EACvCiB,EAA8B,IAAI,IACxC,UAAW/pB,KAAQ,KAAK,aACtB+pB,EAAY,IAAI/pB,EAAM,KAAK,SAAS,IAAIA,CAAI,EAAE,KAAK8pB,CAAa,CAAC,EAEnE,OAAO,IAAI9C,EAAW+C,EAAa,CAAC,GAAG,KAAK,YAAY,CAAC,CAC3D,CACA,MAAMtT,EAAO,IAAI,MAAM,KAAK,MAAM,EAClC,QAAS7b,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK6b,EAAK7b,CAAC,EAAIyuB,EAAQ,IAAIzuB,CAAC,EAC7D,MAAMsuB,EAAW,MAAM,KAAK,CAAE,OAAQ,KAAK,QAAU,CAAC1hB,EAAG5M,IAAMA,CAAC,EAChEsuB,EAAS,KAAK,CAACpqB,EAAGC,IAAM,CACtB,MAAMirB,EAAKvT,EAAK3X,CAAC,EACXmrB,EAAKxT,EAAK1X,CAAC,EACXmrB,EAAUF,GAAO,KACjBG,EAAUF,GAAO,KACvB,GAAIC,GAAWC,EAAS,MAAO,GAC/B,GAAID,EAAS,MAAO,GACpB,GAAIC,EAAS,MAAO,GACpB,IAAIT,EAAM,EACV,OAAI,OAAOM,GAAO,UAAY,OAAOC,GAAO,SAC1CP,EAAMM,EAAKC,EACF,OAAOD,GAAO,UAAY,OAAOC,GAAO,SACjDP,EAAMM,EAAKC,EAAK,GAAKD,EAAKC,EAAK,EAAI,EAC1B,OAAOD,GAAO,WAAa,OAAOC,GAAO,UAClDP,GAAOM,EAAK,EAAI,IAAMC,EAAK,EAAI,GACtBD,aAAc,MAAQC,aAAc,OAC7CP,EAAMM,EAAG,UAAYC,EAAG,QAAO,GAE1BX,EAAO,CAACI,EAAMA,CACvB,CAAC,EACD,MAAMU,EAAgB,IAAI,WAAWlB,CAAQ,EACvC3B,EAA8B,IAAI,IACxC,UAAWvnB,KAAQ,KAAK,aACtBunB,EAAY,IAAIvnB,EAAM,KAAK,SAAS,IAAIA,CAAI,EAAE,KAAKoqB,CAAa,CAAC,EAEnE,OAAO,IAAIpD,EAAWO,EAAa,CAAC,GAAG,KAAK,YAAY,CAAC,CAC3D,CACA,GAAI1a,EAAK,SAAW,GAAK,KAAK,SAAS,IAAIA,EAAK,CAAC,CAAC,EAAE,QAAU,SAAsB,KAAK,SAAS,IAAIA,EAAK,CAAC,CAAC,EAAE,QAAU,OAAuB,KAAK,SAAS,IAAIA,EAAK,CAAC,CAAC,EAAE,QAAU,OAAoB,CACvM,MAAMwd,EAAK,KAAK,SAAS,IAAIxd,EAAK,CAAC,CAAC,EAC9Byd,EAAK,KAAK,SAAS,IAAIzd,EAAK,CAAC,CAAC,EAC9B0d,EAAK,IAAI,MAAM,KAAK,MAAM,EAC1BC,EAAK,IAAI,MAAM,KAAK,MAAM,EAChC,QAAS5vB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/B2vB,EAAG3vB,CAAC,EAAIyvB,EAAG,IAAIzvB,CAAC,EAChB4vB,EAAG5vB,CAAC,EAAI0vB,EAAG,IAAI1vB,CAAC,EAElB,MAAM6vB,EAAK3D,EAAO,CAAC,IAAM,OACnB4D,EAAK5D,EAAO,CAAC,IAAM,OACnBoC,EAAW,MAAM,KAAK,CAAE,OAAQ,KAAK,QAAU,CAAC1hB,EAAG5M,IAAMA,CAAC,EAChEsuB,EAAS,KAAK,CAACpqB,EAAGC,IAAM,CACtB,MAAM4rB,EAAKJ,EAAGzrB,CAAC,EACT8rB,EAAKL,EAAGxrB,CAAC,EACT8rB,EAASF,IAAO,KAChBG,EAASF,IAAO,KACtB,GAAI,CAACC,GAAU,CAACC,EAAQ,CACtB,GAAID,EAAQ,MAAO,GACnB,GAAIC,EAAQ,MAAO,GACnB,MAAMC,EAAOJ,EAAKC,EAAK,GAAKD,EAAKC,EAAK,EAAI,EAC1C,GAAIG,IAAS,EAAG,OAAON,EAAK,CAACM,EAAOA,CACtC,CACA,MAAMC,EAAKR,EAAG1rB,CAAC,EACTmsB,EAAKT,EAAGzrB,CAAC,EACTmsB,EAASF,IAAO,KAChBG,EAASF,IAAO,KACtB,GAAIC,GAAUC,EAAQ,MAAO,GAC7B,GAAID,EAAQ,MAAO,GACnB,GAAIC,EAAQ,MAAO,GACnB,MAAMC,EAAOJ,EAAKC,EAClB,OAAOP,EAAK,CAACU,EAAOA,CACtB,CAAC,EACD,MAAMhB,EAAgB,IAAI,WAAWlB,CAAQ,EAC7C,OAAO,KAAK,oBAAoBkB,CAAa,CAC/C,CACA,MAAMiB,EAAaxe,EAAK,IAAK7M,GAAS,CACpC,MAAMtC,EAAO,KAAK,SAAS,IAAIsC,CAAI,EAC7ByW,EAAO,IAAI,MAAM,KAAK,MAAM,EAClC,QAAS7b,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/B6b,EAAK7b,CAAC,EAAI8C,EAAK,IAAI9C,CAAC,EAEtB,OAAO6b,CACT,CAAC,EACKjb,EAAU,MAAM,KAAK,CAAE,OAAQ,KAAK,QAAU,CAACgM,EAAG5M,IAAMA,CAAC,EAC/DY,EAAQ,KAAK,CAACsD,EAAGC,IAAM,CACrB,QAASoI,EAAI,EAAGA,EAAI0F,EAAK,OAAQ1F,IAAK,CACpC,MAAM6iB,EAAKqB,EAAWlkB,CAAC,EAAErI,CAAC,EACpBmrB,EAAKoB,EAAWlkB,CAAC,EAAEpI,CAAC,EACpBmrB,EAAUF,GAAO,KACjBG,EAAUF,GAAO,KACvB,GAAIC,GAAWC,EAAS,SACxB,GAAID,EAAS,MAAO,GACpB,GAAIC,EAAS,MAAO,GACpB,IAAIT,EAAM,EAUV,GATIM,aAAc,MAAQC,aAAc,KACtCP,EAAMM,EAAG,UAAYC,EAAG,QAAO,EACtB,OAAOD,GAAO,UAAY,OAAOC,GAAO,SACjDP,EAAMM,EAAKC,EAAK,GAAKD,EAAKC,EAAK,EAAI,EAC1B,OAAOD,GAAO,UAAY,OAAOC,GAAO,SACjDP,EAAMM,EAAKC,EACF,OAAOD,GAAO,WAAa,OAAOC,GAAO,YAClDP,GAAOM,EAAK,EAAI,IAAMC,EAAK,EAAI,IAE7BP,IAAQ,EACV,OAAO5C,EAAO3f,CAAC,IAAM,OAAS,CAACuiB,EAAMA,CAEzC,CACA,MAAO,EACT,CAAC,EACD,MAAMlS,EAAe,IAAI,WAAWhc,CAAO,EACrCwc,EAA6B,IAAI,IACvC,UAAWhY,KAAQ,KAAK,aACtBgY,EAAW,IAAIhY,EAAM,KAAK,SAAS,IAAIA,CAAI,EAAE,KAAKwX,CAAY,CAAC,EAEjE,OAAO,IAAIwP,EAAWhP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,OAAO7W,EAAS0nB,EAAO,QAAS,CAC9B,MAAMhc,EAAO1L,IAAY,OAAS,KAAK,aAAe,MAAM,QAAQA,CAAO,EAAIA,EAAU,CAACA,CAAO,EACjG,UAAWnB,KAAQ6M,EACjB,GAAI,CAAC,KAAK,SAAS,IAAI7M,CAAI,EACzB,MAAM,IAAIpG,EAAoBoG,EAAM,KAAK,YAAY,EAGzD,MAAMW,EAAuB,IAAI,IAC3BnF,EAAU,CAAA,EAChB,GAAIqtB,IAAS,QACX,QAAS,EAAI,EAAG,EAAI,KAAK,OAAQ,IAAK,CACpC,MAAMjoB,EAAM,KAAK,QAAQ,EAAGiM,CAAI,EAC3BlM,EAAK,IAAIC,CAAG,IACfD,EAAK,IAAIC,CAAG,EACZpF,EAAQ,KAAK,CAAC,EAElB,KACK,CACL,MAAM8vB,EAA4B,IAAI,IAChCxqB,EAAQ,CAAA,EACd,QAASlG,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMgG,EAAM,KAAK,QAAQhG,EAAGiS,CAAI,EAC3Bye,EAAU,IAAI1qB,CAAG,GACpBE,EAAM,KAAKF,CAAG,EAEhB0qB,EAAU,IAAI1qB,EAAKhG,CAAC,CACtB,CACA,UAAWgG,KAAOE,EAChBtF,EAAQ,KAAK8vB,EAAU,IAAI1qB,CAAG,CAAC,CAEnC,CACA,OAAO,KAAK,eAAepF,CAAO,CACpC,CACA,OAAO4D,EAAGiH,EAAS,CACjB,GAAI,KAAK,SAAW,EAClB,OAAO,KAAK,MAAK,EAEnB,IAAItN,EACJ,GAAIqG,GAAK,EACPrG,EAAQ,KAAK,IAAI,KAAK,MAAMqG,CAAC,EAAG,KAAK,MAAM,UAClCA,EAAI,GAAKA,EAAI,EACtBrG,EAAQ,KAAK,IAAI,EAAG,KAAK,MAAMqG,EAAI,KAAK,MAAM,CAAC,MAE/C,OAAM,IAAI3F,EACR,oBACA,qCAAqC2F,CAAC,EAC9C,EAEI,MAAMmsB,EAAMllB,GAAS,OAAS,OAASmlB,GAAanlB,EAAQ,IAAI,EAAI,KAAK,OACnE7K,EAAU,MAAM,KAAK,CAAE,OAAQ,KAAK,QAAU,CAACgM,EAAG5M,IAAMA,CAAC,EAC/D,QAAS,EAAIY,EAAQ,OAAS,EAAG,EAAI,EAAG,IAAK,CAC3C,MAAMqU,EAAI,KAAK,MAAM0b,EAAG,GAAM,EAAI,EAAE,EAC9BE,EAAMjwB,EAAQ,CAAC,EACrBA,EAAQ,CAAC,EAAIA,EAAQqU,CAAC,EACtBrU,EAAQqU,CAAC,EAAI4b,CACf,CACA,OAAO,KAAK,eAAejwB,EAAQ,MAAM,EAAGzC,CAAK,CAAC,CACpD,CACA,WAAWyc,EAAM,CACf,OAAO,IAAID,GAAQ,KAAMC,CAAI,CAC/B,CACA,KAAK3a,EAAOwd,EAAIqB,EAAM,QAASrT,EAAS,CACtC,OAAOoT,GAAS,KAAM5e,EAAOwd,EAAIqB,EAAKrT,CAAO,CAC/C,CACA,MAAMA,EAAS,CACb,OAAOqX,GAAM,KAAMrX,CAAO,CAC5B,CACA,KAAKA,EAAS,CACZ,OAAO0Y,GAAK,KAAM1Y,CAAO,CAC3B,CACA,QAAQxM,EAAQ,CACd,GAAI,CAAC,KAAK,SAAS,IAAIA,CAAM,EAC3B,MAAM,IAAID,EAAoBC,EAAQ,KAAK,YAAY,EAEzD,MAAM6xB,EAAa,KAAK,SAAS,IAAI7xB,CAAM,EACrC8xB,EAAgB,KAAK,aAAa,OAAQvsB,GAAMA,IAAMvF,CAAM,EAC5D+xB,EAAe,CAAA,EACrB,UAAW5rB,KAAQ,KAAK,aACtB4rB,EAAa5rB,CAAI,EAAI,CAAA,EAEvB,QAASpF,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMgB,EAAM8vB,EAAW,IAAI9wB,CAAC,EAC5B,GAAIgB,IAAQ,KAAM,CAChBgwB,EAAa/xB,CAAM,EAAE,KAAK,IAAI,EAC9B,UAAWmG,KAAQ2rB,EACjBC,EAAa5rB,CAAI,EAAE,KAAK,KAAK,SAAS,IAAIA,CAAI,EAAE,IAAIpF,CAAC,CAAC,CAE1D,SAAW,MAAM,QAAQgB,CAAG,EAAG,CAC7B,GAAIA,EAAI,SAAW,EACjB,SAEF,UAAWwgB,KAAQxgB,EAAK,CACtBgwB,EAAa/xB,CAAM,EAAE,KAAKuiB,IAAS,OAAS,KAAOA,CAAI,EACvD,UAAWpc,KAAQ2rB,EACjBC,EAAa5rB,CAAI,EAAE,KAAK,KAAK,SAAS,IAAIA,CAAI,EAAE,IAAIpF,CAAC,CAAC,CAE1D,CACF,KAAO,CACLgxB,EAAa/xB,CAAM,EAAE,KAAK+B,CAAG,EAC7B,UAAWoE,KAAQ2rB,EACjBC,EAAa5rB,CAAI,EAAE,KAAK,KAAK,SAAS,IAAIA,CAAI,EAAE,IAAIpF,CAAC,CAAC,CAE1D,CACF,CACA,OAAOosB,EAAW,YAAY4E,CAAY,CAC5C,CACA,UAAU7L,EAAc,CACtB,OAAOD,GAAU,KAAMC,CAAY,CACrC,CACA,OAAO,UAAUK,EAAQ,CACvB,OAAOD,GAAO,GAAGC,CAAM,CACzB,CACA,QAAQ5lB,EAAOqS,EAAM,CACnB,MAAM6B,EAAQ,CAAA,EACd,UAAW1O,KAAQ6M,EAAM,CACvB,MAAM9Q,EAAI,KAAK,SAAS,IAAIiE,CAAI,EAAE,IAAIxF,CAAK,EACvCuB,IAAM,KACR2S,EAAM,KAAK,QAAQ,EACV3S,aAAa,KACtB2S,EAAM,KAAK,MAAM3S,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxE2S,EAAM,KAAK,KAAK,OAAO3S,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtC2S,EAAM,KAAK,QAAQ,KAAK,UAAU3S,CAAC,CAAC,EAAE,CAE1C,CACA,OAAO2S,EAAM,KAAK,GAAG,CACvB,CACA,eAAelT,EAAS,CACtB,MAAMgc,EAAe,IAAI,WAAWhc,CAAO,EAC3C,OAAO,KAAK,oBAAoBgc,CAAY,CAC9C,CACA,oBAAoBA,EAAc,CAChC,MAAMQ,EAA6B,IAAI,IACvC,UAAWhY,KAAQ,KAAK,aACtBgY,EAAW,IAAIhY,EAAM,KAAK,SAAS,IAAIA,CAAI,EAAE,KAAKwX,CAAY,CAAC,EAEjE,OAAO,IAAIwP,EAAWhP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,SAAS7W,EAAS,CAChB,MAAM0L,EAAO1L,IAAY,OAAS,KAAK,aAAe,MAAM,QAAQA,CAAO,EAAIA,EAAU,CAACA,CAAO,EACjG,UAAWnB,KAAQ6M,EACjB,GAAI,CAAC,KAAK,SAAS,IAAI7M,CAAI,EACzB,MAAM,IAAIpG,EAAoBoG,EAAM,KAAK,YAAY,EAGzD,MAAMxE,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,IAAIkB,EAAU,GACd,UAAWkE,KAAQ6M,EACjB,GAAI,KAAK,SAAS,IAAI7M,CAAI,EAAE,IAAIpF,CAAC,IAAM,KAAM,CAC3CkB,EAAU,GACV,KACF,CAEGA,GACHN,EAAQ,KAAKZ,CAAC,CAElB,CACA,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,SAASqwB,EAAU,CACjB,GAAI,OAAOA,GAAa,SACtB,OAAO,KAAK,qBAAqBA,CAAQ,EAE3C,UAAW/b,KAAW,OAAO,KAAK+b,CAAQ,EACxC,GAAI,CAAC,KAAK,SAAS,IAAI/b,CAAO,EAC5B,MAAM,IAAIlW,EAAoBkW,EAAS,KAAK,YAAY,EAG5D,MAAMkI,EAA6B,IAAI,IACvC,UAAWhY,KAAQ,KAAK,aAAc,CACpC,MAAMtC,EAAO,KAAK,SAAS,IAAIsC,CAAI,EAC7Bod,EAAYyO,EAAS7rB,CAAI,EAC/B,GAAIod,IAAc,OAAQ,CACxB,MAAMvhB,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAI8C,EAAK,OAAQ9C,IAAK,CACpC,MAAMmB,EAAI2B,EAAK,IAAI9C,CAAC,EACpBiB,EAAO,KAAKE,IAAM,KAAOqhB,EAAYrhB,CAAC,CACxC,CACAic,EAAW,IAAIhY,EAAM4nB,GAAYlqB,EAAK,MAAO7B,CAAM,CAAC,CACtD,MACEmc,EAAW,IAAIhY,EAAMtC,CAAI,CAE7B,CACA,OAAO,IAAIspB,EAAWhP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,qBAAqB0N,EAAW,CAC9B,MAAM1N,EAA6B,IAAI,IACvC,UAAWhY,KAAQ,KAAK,aAAc,CACpC,MAAMtC,EAAO,KAAK,SAAS,IAAIsC,CAAI,EACnC,GAAItC,EAAK,YAAc,EAAG,CACxBsa,EAAW,IAAIhY,EAAMtC,CAAI,EACzB,QACF,CACA,MAAM7B,EAAS,CAAA,EACf,QAAS,EAAI,EAAG,EAAI6B,EAAK,OAAQ,IAC/B7B,EAAO,KAAK6B,EAAK,IAAI,CAAC,CAAC,EAEzB,GAAIgoB,IAAc,UAChB,QAAS,EAAI,EAAG,EAAI7pB,EAAO,OAAQ,IAC7BA,EAAO,CAAC,IAAM,MAAQA,EAAO,EAAI,CAAC,IAAM,OAC1CA,EAAO,CAAC,EAAIA,EAAO,EAAI,CAAC,OAI5B,SAAS,EAAIA,EAAO,OAAS,EAAG,GAAK,EAAG,IAClCA,EAAO,CAAC,IAAM,MAAQA,EAAO,EAAI,CAAC,IAAM,OAC1CA,EAAO,CAAC,EAAIA,EAAO,EAAI,CAAC,GAI9Bmc,EAAW,IAAIhY,EAAM4nB,GAAYlqB,EAAK,MAAO7B,CAAM,CAAC,CACtD,CACA,OAAO,IAAImrB,EAAWhP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,KAAKyI,EAAQ,CACX,UAAW3Q,KAAW,OAAO,KAAK2Q,CAAM,EACtC,GAAI,CAAC,KAAK,SAAS,IAAI3Q,CAAO,EAC5B,MAAM,IAAIlW,EAAoBkW,EAAS,KAAK,YAAY,EAG5D,MAAMkI,EAA6B,IAAI,IACvC,UAAWhY,KAAQ,KAAK,aAAc,CACpC,MAAM0B,EAAc+e,EAAOzgB,CAAI,EAC/B,GAAI0B,EAAa,CAEf,MAAMoqB,EADS,IAAIluB,EAAOoC,EAAM,KAAK,SAAS,IAAIA,CAAI,CAAC,EACjC,KAAK0B,CAAW,EACtCsW,EAAW,IAAIhY,EAAM8rB,EAAO,MAAM,CACpC,MACE9T,EAAW,IAAIhY,EAAM,KAAK,SAAS,IAAIA,CAAI,CAAC,CAEhD,CACA,OAAO,IAAIgnB,EAAWhP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,SAAS3R,EAAS,CAChB,MAAMwB,EAAUxB,GAAS,SAAW,GAC9B0lB,EAAU1lB,GAAS,SAAW,GAC9B,CAACyF,EAAOkgB,CAAK,EAAI,KAAK,MAC5B,GAAIA,IAAU,GAAKlgB,IAAU,EAC3B,MAAO;AAAA,WACFkgB,CAAK,WAEZ,MAAMC,EAAU,KAAK,aACrB,IAAIC,EACJ,GAAID,EAAQ,OAASF,EAAS,CAC5B,MAAMI,EAAO,KAAK,MAAMJ,EAAU,CAAC,EACnCG,EAAc,CAAC,GAAGD,EAAQ,MAAM,EAAGE,CAAI,EAAG,MAAO,GAAGF,EAAQ,MAAMA,EAAQ,OAASE,CAAI,CAAC,CAC1F,MACED,EAAc,CAAC,GAAGD,CAAO,EAE3B,IAAIG,EACJ,GAAItgB,EAAQjE,EAAS,CACnB,MAAMskB,EAAO,KAAK,MAAMtkB,EAAU,CAAC,EACnCukB,EAAa,CACX,GAAG,MAAM,KAAK,CAAE,OAAQD,CAAI,EAAI,CAAC3kB,EAAG5M,IAAMA,CAAC,EAC3C,GAEA,GAAG,MAAM,KAAK,CAAE,OAAQuxB,CAAI,EAAI,CAAC3kB,EAAG5M,IAAMkR,EAAQqgB,EAAOvxB,CAAC,CAClE,CACI,MACEwxB,EAAa,MAAM,KAAK,CAAE,OAAQtgB,CAAK,EAAI,CAACtE,EAAG5M,IAAMA,CAAC,EAExD,MAAMyxB,EAAetwB,GACfA,IAAM,KAAa,OACnBA,aAAa,KAAaA,EAAE,YAAW,EACvC,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAC1D,OAAOA,CAAC,EAEV,KAAK,UAAUA,CAAC,EAEnBuwB,EAAY,CAAC,GAAI,GAAGJ,CAAW,EAC/BK,EAAW,CAAA,EACjB,UAAW9wB,KAAO2wB,EAAY,CAC5B,GAAI3wB,IAAQ,GAAI,CACd8wB,EAAS,KAAKD,EAAU,IAAI,IAAM,KAAK,CAAC,EACxC,QACF,CACA,MAAME,EAAQ,CAAC,OAAO/wB,CAAG,CAAC,EAC1B,UAAWqU,KAAWoc,EAChBpc,IAAY,MACd0c,EAAM,KAAK,KAAK,EAEhBA,EAAM,KAAKH,EAAY,KAAK,SAAS,IAAIvc,CAAO,EAAE,IAAIrU,CAAG,CAAC,CAAC,EAG/D8wB,EAAS,KAAKC,CAAK,CACrB,CACA,MAAMC,EAAYH,EAAU,IAAI,CAAC/kB,EAAGiC,IAAO,CACzC,IAAIkjB,EAAOnlB,EAAE,OACb,UAAWuD,KAAOyhB,EAChBG,EAAO,KAAK,IAAIA,EAAM5hB,EAAItB,CAAE,EAAE,MAAM,EAEtC,OAAOkjB,CACT,CAAC,EACKrK,EAAM,CAAC5lB,EAAGkwB,EAAGnjB,IACbA,IAAO,EAAU/M,EAAE,SAASkwB,CAAC,EAC1BlwB,EAAE,OAAOkwB,CAAC,EAEbC,EAAM,IACNhiB,EAAQ,CAAA,EACRiiB,EAAa,KAAYP,EAAU,IAAI,CAAC/kB,EAAGiC,IAAO6Y,EAAI9a,EAAGklB,EAAUjjB,CAAE,EAAGA,CAAE,CAAC,EAAE,KAAK,KAAU,EAAI,KAChGsjB,EAAY,KAAiBL,EAAU,IAAKE,GAAMC,EAAI,OAAOD,CAAC,CAAC,EAAE,KAAK,KAAoB,EAAI,KAC9FI,EAAY,KAAiBN,EAAU,IAAKE,GAAMC,EAAI,OAAOD,CAAC,CAAC,EAAE,KAAK,KAAoB,EAAI,KAC9FK,EAAe,KAAiBP,EAAU,IAAKE,GAAMC,EAAI,OAAOD,CAAC,CAAC,EAAE,KAAK,KAAoB,EAAI,KACvG/hB,EAAM,KAAKkiB,CAAS,EACpBliB,EAAM,KAAKiiB,CAAU,EACrBjiB,EAAM,KAAKmiB,CAAS,EACpB,UAAWjiB,KAAOyhB,EAChB3hB,EAAM,KAAK,KAAYE,EAAI,IAAI,CAAC4E,EAAMlG,IAAO6Y,EAAI3S,EAAM+c,EAAUjjB,CAAE,EAAGA,CAAE,CAAC,EAAE,KAAK,KAAU,EAAI,IAAS,EAEzG,OAAAoB,EAAM,KAAKoiB,CAAY,EACvBpiB,EAAM,KAAK,GAAGkB,CAAK,WAAWkgB,CAAK,UAAU,EACtCphB,EAAM,KAAK;AAAA,CAAI,CACxB,CACA,MAAMvE,EAAS,CACb,QAAQ,IAAI,KAAK,SAASA,CAAO,CAAC,CACpC,CACA,UAAW,CAET,MAAMkQ,EAAgB,CAAE,KADN,CAAC,QAAS,OAAQ,MAAO,MAAO,KAAK,CAChB,EACvC,UAAWvW,KAAQ,KAAK,aAAc,CACpC,MAAMitB,EAAS,KAAK,SAAS,IAAIjtB,CAAI,EAC/BoB,EAAQ6rB,EAAO,MACrB,GAAI7rB,IAAU,OAAuBA,IAAU,MAAmB,CAChE,MAAMhE,EAAS,IAAIQ,EAAOoC,EAAMitB,CAAM,EAChCl0B,EAAQqE,EAAO,OAASA,EAAO,UAC/B8H,EAAO9H,EAAO,KAAI,EAClB8vB,EAAM9vB,EAAO,IAAG,EAChB+vB,EAAM/vB,EAAO,IAAG,EAChBgwB,EAAMhwB,EAAO,IAAG,EACtBmZ,EAAcvW,CAAI,EAAI,CAACjH,EAAOmM,EAAMgoB,EAAKC,EAAKC,CAAG,CACnD,CACF,CACA,OAAOpG,EAAW,YAAYzQ,CAAa,CAC7C,CACA,aAAc,CACZ,IAAI7a,EAAQ,EACZ,UAAWsE,KAAQ,KAAK,aACtBtE,GAAS,KAAK,SAAS,IAAIsE,CAAI,EAAE,qBAAoB,EAEvD,OAAOtE,CACT,CACA,MAAO,CACL,KAAM,CAACoQ,EAAOkgB,CAAK,EAAI,KAAK,MACtBphB,EAAQ,CAAA,EACdA,EAAM,KAAK,cAAckB,CAAK,WAAWkgB,CAAK,UAAU,EACxDphB,EAAM,KAAK,EAAE,EACb,MAAMyiB,EAAe,KAAK,IAAI,EAAG,GAAG,KAAK,aAAa,IAAKjuB,GAAMA,EAAE,MAAM,CAAC,EACpEgI,EAAS,GAAG,SAAS,OAAOimB,CAAY,CAAC,KAAK,QAAQ,OAAO,EAAE,CAAC,KAAK,aAAa,OAAO,EAAE,CAAC,WAClGziB,EAAM,KAAKxD,CAAM,EACjBwD,EAAM,KAAK,IAAS,OAAOxD,EAAO,MAAM,CAAC,EACzC,IAAIkmB,EAAc,EAClB,UAAWttB,KAAQ,KAAK,aAAc,CACpC,MAAMitB,EAAS,KAAK,SAAS,IAAIjtB,CAAI,EAC/BoB,EAAQ6rB,EAAO,MACfM,EAAYN,EAAO,UACnBO,EAAMP,EAAO,qBAAoB,EACvCK,GAAeE,EACf5iB,EAAM,KACJ,GAAG5K,EAAK,OAAOqtB,CAAY,CAAC,KAAKjsB,EAAM,OAAO,EAAE,CAAC,KAAK,OAAOmsB,CAAS,EAAE,OAAO,EAAE,CAAC,KAAKE,GAAYD,CAAG,CAAC,EAC/G,CACI,CACA5iB,EAAM,KAAK,IAAS,OAAOxD,EAAO,MAAM,CAAC,EACzCwD,EAAM,KAAK,iBAAiB6iB,GAAYH,CAAW,CAAC,EAAE,EACtD,QAAQ,IAAI1iB,EAAM,KAAK;AAAA,CAAI,CAAC,CAC9B,CACA,OAAO,YAAYzP,EAAM,CACvB,MAAMqa,EAAO,OAAO,KAAKra,CAAI,EAC7B,GAAIqa,EAAK,SAAW,EAClB,OAAOwR,EAAW,MAAK,EAEzB,MAAM0G,EAAWlY,EAAK,CAAC,EACjB1N,EAAW3M,EAAKuyB,CAAQ,EAAE,OAChC,UAAW9sB,KAAO4U,EAChB,GAAIra,EAAKyF,CAAG,EAAE,SAAWkH,EACvB,MAAM,IAAI9N,GACR,WAAW4G,CAAG,gBAAgBzF,EAAKyF,CAAG,EAAE,MAAM,cAAckH,CAAQ,EAC9E,EAGI,MAAM3G,EAA0B,IAAI,IACpC,UAAWP,KAAO4U,EAAM,CACtB,MAAM3Z,EAASV,EAAKyF,CAAG,EACjBQ,EAAQsmB,GAAa7rB,CAAM,EAC3B6B,EAAOkqB,GAAYxmB,EAAOvF,CAAM,EACtCsF,EAAQ,IAAIP,EAAKlD,CAAI,CACvB,CACA,OAAO,IAAIspB,EAAW7lB,EAASqU,CAAI,CACrC,CACA,OAAO,SAASjL,EAAM,CACpB,GAAIA,EAAK,SAAW,EAClB,OAAOyc,EAAW,MAAK,EAEzB,MAAM1G,EAA4B,IAAI,IACtC,UAAWxV,KAAOP,EAChB,UAAW3J,KAAO,OAAO,KAAKkK,CAAG,EAC/BwV,EAAU,IAAI1f,CAAG,EAGrB,MAAMgmB,EAAc,CAAC,GAAGtG,CAAS,EAC3BnlB,EAAO,CAAA,EACb,UAAW6E,KAAQ4mB,EACjBzrB,EAAK6E,CAAI,EAAI,CAAA,EAEf,UAAW8K,KAAOP,EAAM,CACtB,MAAM/I,EAAIsJ,EACV,UAAW9K,KAAQ4mB,EAAa,CAC9B,MAAMjsB,EAAQqF,KAAQwB,EAAIA,EAAExB,CAAI,EAAI,KACpC7E,EAAK6E,CAAI,EAAE,KAAKrF,IAAU,OAAS,KAAOA,CAAK,CACjD,CACF,CACA,OAAOqsB,EAAW,YAAY7rB,CAAI,CACpC,CACA,OAAO,OAAQ,CACb,OAAO,IAAI6rB,EAA2B,IAAI,IAAO,CAAA,CAAE,CACrD,CACA,OAAO,MAAMhnB,EAAM5E,EAAOC,EAAKsyB,EAAO,EAAG,CACvC,GAAIA,IAAS,EACX,MAAM,IAAIl0B,EAAc,oBAA6C,uBAAuB,EAE9F,GAAI2B,GAASC,EACX,MAAM,IAAI5B,EACR,oBACA,UAAU2B,CAAK,4BAA4BC,CAAG,GACtD,EAEI,MAAMhB,EAAS,KAAK,MAAMgB,EAAMD,GAASuyB,CAAI,EACvCxyB,EAAO,IAAI,aAAad,CAAM,EACpC,QAASO,EAAI,EAAGA,EAAIP,EAAQO,IAC1BO,EAAKP,CAAC,EAAIQ,EAAQR,EAAI+yB,EAExB,MAAMpyB,EAAO,IAAIpB,EAASE,EAAQ,EAAI,EAChCqD,EAAO,IAAIzC,EAAcE,EAAMI,CAAI,EACnC4F,EAA0B,IAAI,IACpC,OAAAA,EAAQ,IAAInB,EAAMtC,CAAI,EACf,IAAIspB,EAAW7lB,EAAS,CAACnB,CAAI,CAAC,CACvC,CACA,OAAO,SAASA,EAAM5E,EAAOC,EAAKtC,EAAO,CACvC,GAAIA,EAAQ,EACV,MAAM,IAAIU,EAAc,oBAA6C,0BAA0B,EAEjG,MAAM0B,EAAO,IAAI,aAAapC,CAAK,EAC7B40B,GAAQtyB,EAAMD,IAAUrC,EAAQ,GACtC,QAAS6B,EAAI,EAAGA,EAAI7B,EAAO6B,IACzBO,EAAKP,CAAC,EAAIQ,EAAQR,EAAI+yB,EAExB,MAAMpyB,EAAO,IAAIpB,EAASpB,EAAO,EAAI,EAC/B2E,EAAO,IAAIzC,EAAcE,EAAMI,CAAI,EACnC4F,EAA0B,IAAI,IACpC,OAAAA,EAAQ,IAAInB,EAAMtC,CAAI,EACf,IAAIspB,EAAW7lB,EAAS,CAACnB,CAAI,CAAC,CACvC,CACA,aAAa,QAAQ+S,EAAO1M,EAAU,GAAI,CACxC,IAAID,EACJ,GAAI,OAAO2M,GAAU,SACnB,GAAI,CACF,MAAM6a,EAAS,CAAA,EACf,gBAAiBhgB,KAASmF,EACxB6a,EAAO,KAAK,OAAO,SAAShgB,CAAK,EAAIA,EAAQ,OAAO,KAAKA,CAAK,CAAC,EAEjExH,EAAU,OAAO,OAAOwnB,CAAM,EAAE,SAASvnB,EAAQ,UAAY,OAAO,CACtE,OAASiF,EAAK,CACZ,GAAIA,aAAepR,EAAS,MAAMoR,EAClC,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,mCAAmCP,CAAO,EAAE,CAChE,SACS0M,EAAQ,QAAU,SAC3BD,EAAU2M,UACDA,EAAM,WAAW,SAAS,GAAKA,EAAM,WAAW,UAAU,EACnE,GAAI,CACF,MAAM8a,EAAW,MAAM,MAAM9a,CAAK,EAClC,GAAI,CAAC8a,EAAS,GACZ,MAAM,IAAI3zB,EACR,6BAA6B6Y,CAAK,WAAW,OAAO8a,EAAS,MAAM,CAAC,IAAIA,EAAS,UAAU,EACvG,EAEQznB,EAAU,MAAMynB,EAAS,KAAI,CAC/B,OAASviB,EAAK,CACZ,GAAIA,aAAepR,EAAS,MAAMoR,EAClC,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,6BAA6B6Y,CAAK,MAAMpZ,CAAO,EAAE,CACrE,KAEA,IAAI,CAEFyM,EAAU,MADC,KAAM,QAAO,uCAAa,GAClB,SAAS2M,EAAO1M,EAAQ,UAAY,OAAO,CAChE,OAASiF,EAAK,CACZ,GAAIA,aAAepR,EAAS,MAAMoR,EAClC,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,4BAA4B6Y,CAAK,MAAMpZ,CAAO,EAAE,CACpE,CAEF,MAAMm0B,EAAS3nB,GAASC,EAASC,CAAO,EACxC,OAAO0nB,GAAyBD,EAAO,OAAQA,EAAO,QAASA,EAAO,aAAa,CACrF,CACA,aAAc,UAAUE,EAAM3nB,EAAU,GAAI,CAC1C,gBAAiBuH,KAAS5C,GAAcgjB,EAAM3nB,CAAO,EACnD,MAAM0nB,GAAyBngB,EAAM,OAAQA,EAAM,WAAYA,EAAM,aAAa,CAEtF,CACA,OAAO,QAAQogB,EAAM3nB,EAAU,GAAI,CACjC,MAAM4nB,EAAcjH,EAAW,MAAK,EAC9BkH,EAAO5J,GAAgB2J,CAAW,EAChB,OAAAC,EAAK,QAAQ,KAAKA,CAAI,EAE9CA,EAAK,QAAU,SAAY,CACzB,MAAMN,EAAS,CAAA,EACf,gBAAiBhgB,KAASoZ,EAAW,UAAUgH,EAAM3nB,CAAO,EAC1DunB,EAAO,KAAKhgB,CAAK,EAEnB,OAAIggB,EAAO,SAAW,EAAU5G,EAAW,MAAK,EAC5C4G,EAAO,SAAW,EAAUA,EAAO,CAAC,EACjCzN,GAAO,GAAGyN,CAAM,CACzB,EACOM,CACT,CACA,aAAc,aAAaF,EAAM3nB,EAAU,GAAI,CAC7C,gBAAiBuH,KAASD,GAAiBqgB,EAAM3nB,CAAO,EACtD,MAAM2gB,EAAW,SAASpZ,CAAK,CAEnC,CACA,OAAO,WAAWogB,EAAM3nB,EAAU,GAAI,CACpC,MAAM4nB,EAAcjH,EAAW,MAAK,EAC9BkH,EAAO5J,GAAgB2J,CAAW,EAChB,OAAAC,EAAK,QAAQ,KAAKA,CAAI,EAE9CA,EAAK,QAAU,SAAY,CACzB,MAAMN,EAAS,CAAA,EACf,gBAAiBhgB,KAASoZ,EAAW,aAAagH,EAAM3nB,CAAO,EAC7DunB,EAAO,KAAKhgB,CAAK,EAEnB,OAAIggB,EAAO,SAAW,EAAU5G,EAAW,MAAK,EAC5C4G,EAAO,SAAW,EAAUA,EAAO,CAAC,EACjCzN,GAAO,GAAGyN,CAAM,CACzB,EACOM,CACT,CACA,MAAMC,EAAmBC,EAAc,CACrC,IAAInjB,EACAojB,EACAhoB,EACA,OAAO8nB,GAAsB,UAC/BljB,EAAWkjB,EACX9nB,EAAU+nB,GAAgB,CAAA,GACjBD,GAAqB,MAAQ,OAAOA,GAAsB,UAAY,UAAWA,GAAqB,OAAOA,EAAkB,OAAU,YAClJE,EAAWF,EACX9nB,EAAU+nB,GAAgB,CAAA,GAE1B/nB,EAAU8nB,GAAqB,CAAA,EAEjC,KAAM,CAAE,OAAA/mB,EAAQ,KAAAmD,GAAS,KAAK,aAAY,EACpC+jB,EAAYhkB,GAASlD,EAAQmD,EAAMlE,CAAO,EAChD,GAAIgoB,EAAU,CACZ,MAAMhjB,EAASgjB,EACf,OAAO,IAAI,QAAQ,CAACnZ,EAASC,IAAW,CACtC,IAAIoZ,EAAU,GACd,MAAMC,EAAQljB,GAAQ,CAChBijB,IACJA,EAAU,GACVpZ,EAAO,IAAIjb,EAAQ,kCAAkCoR,EAAI,OAAO,EAAE,CAAC,EACrE,EACAD,EAAO,KAAK,QAASmjB,CAAI,EACzBnjB,EAAO,MAAMijB,EAAW,QAAUhjB,GAAQ,CACxC,GAAIA,EACFkjB,EAAKljB,CAAG,MACH,CACL,GAAIijB,EAAS,OACbA,EAAU,GACVljB,EAAO,eAAe,QAASmjB,CAAI,EACnCtZ,EAAO,CACT,CACF,CAAC,CACH,CAAC,CACH,CACA,OAAIjK,EACK,OAAO,uCAAa,EAAE,KAC1BE,GAAOA,EAAG,UAAUF,EAAUqjB,EAAW,OAAO,EAAE,MAAOhjB,GAAQ,CAChE,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,6BAA6B+Q,CAAQ,MAAMtR,CAAO,EAAE,CACxE,CAAC,CACT,EAEW20B,CACT,CACA,aAAa,SAASvb,EAAO1M,EAAU,GAAI,CACzC,IAAID,EACJ,GAAIC,EAAQ,QAAU,SACpBD,EAAU2M,MAEV,IAAI,CAEF3M,EAAU,MADC,KAAM,QAAO,uCAAa,GAClB,SAAS2M,EAAO,OAAO,CAC5C,OAASzH,EAAK,CACZ,GAAIA,aAAepR,EAAS,MAAMoR,EAClC,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,6BAA6B6Y,CAAK,MAAMpZ,CAAO,EAAE,CACrE,CAEF,IAAIm0B,EAAS,KAAK,MAAM1nB,CAAO,EAC/B,GAAIC,EAAQ,KAAM,CAChB,MAAMqI,EAAQrI,EAAQ,KAAK,MAAM,GAAG,EACpC,UAAWooB,KAAQ/f,EACjB,GAAIof,IAAW,MAAQ,OAAOA,GAAW,UAAY,CAAC,MAAM,QAAQA,CAAM,EACxEA,EAASA,EAAOW,CAAI,MAEpB,OAAM,IAAIv0B,EAAQ,cAAcmM,EAAQ,IAAI,iBAAiBooB,CAAI,oBAAoB,CAG3F,CACA,GAAI,CAAC,MAAM,QAAQX,CAAM,EACvB,MAAM,IAAI5zB,EAAQ,0CAA0C,EAE9D,OAAO8sB,EAAW,SAAS8G,CAAM,CACnC,CACA,OAAOK,EAAmBC,EAAc,CACtC,IAAInjB,EACA5E,EACA,OAAO8nB,GAAsB,UAC/BljB,EAAWkjB,EACX9nB,EAAU+nB,GAAgB,CAAA,GAE1B/nB,EAAU8nB,GAAqB,CAAA,EAEjC,KAAM,CAAE,OAAA/mB,EAAQ,KAAAmD,GAAS,KAAK,aAAY,EACpCmkB,EAAa5gB,GAAU1G,EAAQmD,EAAMlE,CAAO,EAClD,OAAI4E,EACK,OAAO,uCAAa,EAAE,KAC1BE,GAAOA,EAAG,UAAUF,EAAUyjB,EAAY,OAAO,EAAE,MAAOpjB,GAAQ,CACjE,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,8BAA8B+Q,CAAQ,MAAMtR,CAAO,EAAE,CACzE,CAAC,CACT,EAEW+0B,CACT,CACA,aAAa,WAAW3b,EAAO1M,EAAU,GAAI,CAC3C,IAAID,EACJ,GAAIC,EAAQ,QAAU,SACpBD,EAAU2M,MAEV,IAAI,CAEF3M,EAAU,MADC,KAAM,QAAO,uCAAa,GAClB,SAAS2M,EAAO,OAAO,CAC5C,OAASzH,EAAK,CACZ,GAAIA,aAAepR,EAAS,MAAMoR,EAClC,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,+BAA+B6Y,CAAK,MAAMpZ,CAAO,EAAE,CACvE,CAGF,MAAM4Q,EADQnE,EAAQ,MAAM;AAAA,CAAI,EAAE,OAAQ4F,GAASA,EAAK,KAAI,IAAO,EAAE,EAClD,IAAKA,GAAS,KAAK,MAAMA,CAAI,CAAC,EACjD,OAAOgb,EAAW,SAASzc,CAAI,CACjC,CACA,aAAa,UAAUU,EAAU5E,EAAU,GAAI,CAC7C,MAAMynB,EAAS,MAAM7d,GAAchF,EAAU5E,CAAO,EACpD,GAAIynB,EAAO,OAAO,SAAW,EAC3B,OAAO9G,EAAW,MAAK,EAEzB,MAAM7lB,EAA0B,IAAI,IACpC,UAAWnB,KAAQ8tB,EAAO,OAAQ,CAChC,MAAM1sB,EAAQ0sB,EAAO,cAAc9tB,CAAI,GAAK,MACtCnE,EAASiyB,EAAO,QAAQ9tB,CAAI,EAClCmB,EAAQ,IAAInB,EAAM4nB,GAAYxmB,EAAOvF,CAAM,CAAC,CAC9C,CACA,OAAO,IAAImrB,EAAW7lB,EAAS,CAAC,GAAG2sB,EAAO,MAAM,CAAC,CACnD,CACA,aAAa,YAAY7iB,EAAU5E,EAAU,GAAI,CAC/C,MAAMynB,EAAS,MAAMxd,GAAgBrF,EAAU5E,CAAO,EACtD,GAAIynB,EAAO,OAAO,SAAW,EAC3B,OAAO9G,EAAW,MAAK,EAEzB,MAAM7lB,EAA0B,IAAI,IACpC,UAAWnB,KAAQ8tB,EAAO,OAAQ,CAChC,MAAM1sB,EAAQ0sB,EAAO,cAAc9tB,CAAI,GAAK,MACtCnE,EAASiyB,EAAO,QAAQ9tB,CAAI,EAClCmB,EAAQ,IAAInB,EAAM4nB,GAAYxmB,EAAOvF,CAAM,CAAC,CAC9C,CACA,OAAO,IAAImrB,EAAW7lB,EAAS,CAAC,GAAG2sB,EAAO,MAAM,CAAC,CACnD,CACA,MAAM,QAAQ7iB,EAAU5E,EAAU,GAAI,CACpC,KAAM,CAAE,OAAAe,EAAQ,KAAAmD,GAAS,KAAK,aAAY,EAC1C,MAAM4G,GAAelG,EAAU7D,EAAQmD,EAAMlE,CAAO,CACtD,CACA,MAAM,UAAU4E,EAAU5E,EAAU,GAAI,CACtC,MAAMe,EAAS,KAAK,aACdjG,EAAU,CAAA,EAChB,UAAWnB,KAAQoH,EAAQ,CACzB,MAAM1J,EAAO,KAAK,SAAS,IAAIsC,CAAI,EAC7BnE,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAI8C,EAAK,OAAQ9C,IAC/BiB,EAAO,KAAK6B,EAAK,IAAI9C,CAAC,CAAC,EAEzBuG,EAAQnB,CAAI,EAAI,CAAE,OAAAnE,EAAQ,MAAO6B,EAAK,KAAK,CAC7C,CACA,MAAMwU,GAAiBjH,EAAU7D,EAAQjG,EAASkF,CAAO,CAC3D,CAEA,MAAM,SAAU,CACd,OAAOyM,GAAa,CAClB,YAAa,KAAK,aAClB,gBAAkB9S,GAAS,CACzB,MAAMtC,EAAO,KAAK,SAAS,IAAIsC,CAAI,EAC7BnE,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAI8C,EAAK,OAAQ9C,IAC/BiB,EAAO,KAAK6B,EAAK,IAAI9C,CAAC,CAAC,EAEzB,MAAO,CAAE,OAAAiB,EAAQ,MAAO6B,EAAK,KAAK,CACpC,CACN,CAAK,CACH,CAEA,OAAO,UAAU6V,EAAO,CACtB,MAAMua,EAASxa,GAAeC,CAAK,EACnC,GAAIua,EAAO,OAAO,SAAW,EAC3B,OAAO9G,EAAW,MAAK,EAEzB,MAAM7lB,EAA0B,IAAI,IACpC,UAAWnB,KAAQ8tB,EAAO,OAAQ,CAChC,MAAM1sB,EAAQ0sB,EAAO,cAAc9tB,CAAI,GAAK,MACtCnE,EAASiyB,EAAO,QAAQ9tB,CAAI,EAClCmB,EAAQ,IAAInB,EAAM4nB,GAAYxmB,EAAOvF,CAAM,CAAC,CAC9C,CACA,OAAO,IAAImrB,EAAW7lB,EAAS,CAAC,GAAG2sB,EAAO,MAAM,CAAC,CACnD,CACA,MAAM,YAAa,CACjB,IAAIjc,EACJ,GAAI,CAEFA,EAAQ,MAAM,OADK,eAErB,MAAQ,CACN,MAAM,IAAI3X,EACR,0GACR,CACI,CACA,MAAMqZ,EAAQ,MAAM,KAAK,QAAO,EAChC,OAAO1B,EAAM,WAAW0B,EAAO,QAAQ,CACzC,CACA,aAAa,aAAa/H,EAAQ,CAChC,IAAIqG,EACJ,GAAI,CAEFA,EAAQ,MAAM,OADK,eAErB,MAAQ,CACN,MAAM,IAAI3X,EACR,4GACR,CACI,CACA,MAAMqZ,EAAQ1B,EAAM,aAAarG,CAAM,EACvC,OAAOwb,EAAW,UAAUzT,CAAK,CACnC,CACA,SAAStI,EAAU,CACjB,KAAM,CAAE,OAAA7D,EAAQ,KAAAmD,GAAS,KAAK,aAAY,EACpCokB,EAAe1gB,GAAY7G,EAAQmD,CAAI,EAC7C,OAAIU,EACK,OAAO,uCAAa,EAAE,KAC1BE,GAAOA,EAAG,UAAUF,EAAU0jB,EAAc,OAAO,EAAE,MAAOrjB,GAAQ,CACnE,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,gCAAgC+Q,CAAQ,MAAMtR,CAAO,EAAE,CAC3E,CAAC,CACT,EAEWg1B,CACT,CACA,MAAMhN,EAAWtb,EAAS,CACxB,KAAM,CAAE,OAAAe,EAAQ,KAAAmD,GAAS,KAAK,aAAY,EAC1C,OAAOmX,GAASC,EAAWva,EAAQmD,EAAMlE,CAAO,CAClD,CACA,cAAe,CACb,MAAMe,EAAS,KAAK,aACdmD,EAAO,CAAA,EACb,QAAS3P,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMkQ,EAAM,CAAA,EACZ,UAAW9K,KAAQ,KAAK,aACtB8K,EAAI,KAAK,KAAK,SAAS,IAAI9K,CAAI,EAAE,IAAIpF,CAAC,CAAC,EAEzC2P,EAAK,KAAKO,CAAG,CACf,CACA,MAAO,CAAE,OAAA1D,EAAQ,KAAAmD,CAAI,CACvB,CACA,MAAM1P,EAAO,CACX,OAAOumB,GAAM,KAAMvmB,CAAK,CAC1B,CACA,aAAaA,EAAO,CAClB,OAAOymB,GAAa,KAAMzmB,CAAK,CACjC,CACA,WAAWA,EAAO,CAChB,OAAO0mB,GAAW,KAAM1mB,CAAK,CAC/B,CACA,MAAM2rB,EAAU,CACd,OAAOD,GAAa,KAAMC,CAAQ,CACpC,CACA,OAAO,eAAeoI,EAAWC,EAAU,CACzC,MAAMxK,EAAMuK,EAAU,WAAW,GAAG,EAAIA,EAAU,MAAM,CAAC,EAAIA,EAC7D5H,EAAW,SAAS,IAAI3C,EAAI,YAAW,EAAIwK,CAAQ,CACrD,CACA,OAAO,eAAeD,EAAWE,EAAU,CACzC,MAAMzK,EAAMuK,EAAU,WAAW,GAAG,EAAIA,EAAU,MAAM,CAAC,EAAIA,EAC7D5H,EAAW,SAAS,IAAI3C,EAAI,YAAW,EAAIyK,CAAQ,CACrD,CACA,aAAa,SAAS7jB,EAAU5E,EAAS,CACvC,MAAMge,EAAMpZ,EAAS,MAAM,GAAG,EAAE,IAAG,GAAI,YAAW,EAClD,GAAI,CAACoZ,EACH,MAAM,IAAInqB,EAAQ,+CAA+C+Q,CAAQ,GAAG,EAE9E,MAAM8jB,EAAS/H,EAAW,SAAS,IAAI3C,CAAG,EAC1C,GAAI,CAAC0K,EACH,MAAM,IAAI70B,EACR,wCAAwCmqB,CAAG,oCAAoCA,CAAG,+BAC1F,EAEI,MAAMlZ,EAAK,KAAM,QAAO,uCAAa,EACrC,IAAIpN,EACJ,GAAI,CACFA,EAAS,MAAMoN,EAAG,SAASF,CAAQ,CACrC,OAASK,EAAK,CACZ,MAAM3R,EAAU2R,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAIpR,EAAQ,wBAAwB+Q,CAAQ,MAAMtR,CAAO,EAAE,CACnE,CACA,OAAOo1B,EAAOhxB,EAAQsI,CAAO,CAC/B,CAEA,MAAM,OAAO4E,EAAU5E,EAAS,CAC9B,MAAMge,EAAMpZ,EAAS,MAAM,GAAG,EAAE,IAAG,GAAI,YAAW,EAClD,GAAI,CAACoZ,EACH,MAAM,IAAInqB,EAAQ,+CAA+C+Q,CAAQ,GAAG,EAE9E,MAAM+jB,EAAShI,EAAW,SAAS,IAAI3C,CAAG,EAC1C,GAAI,CAAC2K,EACH,MAAM,IAAI90B,EACR,wCAAwCmqB,CAAG,oCAAoCA,CAAG,+BAC1F,EAEI,MAAM2K,EAAO,KAAM/jB,EAAU5E,CAAO,CACtC,CACF,EACA,SAASmlB,GAAayD,EAAM,CAC1B,IAAIxyB,EAAIwyB,EAAO,EACf,MAAO,IAAM,CACXxyB,EAAIA,EAAI,WAAa,EACrB,IAAIyyB,EAAI,KAAK,KAAKzyB,EAAIA,IAAM,GAAI,EAAIA,CAAC,EACrC,OAAAyyB,EAAIA,EAAI,KAAK,KAAKA,EAAIA,IAAM,EAAG,GAAKA,CAAC,EAAIA,IAChCA,EAAIA,IAAM,MAAQ,GAAK,UAClC,CACF,CACA,SAASnB,GAAyB3mB,EAAQ+nB,EAAYhnB,EAAe,CACnE,GAAIf,EAAO,SAAW,EACpB,OAAO2f,GAAU,MAAK,EAExB,MAAM5lB,EAA0B,IAAI,IACpC,UAAWnB,KAAQoH,EAAQ,CACzB,MAAMhG,EAAQ+G,EAAcnI,CAAI,GAAK,OAC/BovB,EAAYD,EAAWnvB,CAAI,EAC3BqvB,EAAcC,GAAoBF,EAAWhuB,CAAK,EACxDD,EAAQ,IAAInB,EAAM4nB,GAAYxmB,EAAOiuB,CAAW,CAAC,CACnD,CACA,OAAO,IAAItI,GAAU5lB,EAAS,CAAC,GAAGiG,CAAM,CAAC,CAC3C,CACA,SAASkoB,GAAoBzzB,EAAQuF,EAAO,CAC1C,OAAQA,EAAK,CACX,IAAK,MACL,IAAK,MACH,OAAOvF,EAAO,IAAKE,GAAMA,IAAM,KAAO,KAAO,OAAOA,CAAC,CAAC,EACxD,IAAK,OACH,OAAOF,EAAO,IAAKE,GACbA,IAAM,KAAa,KAChBA,EAAE,YAAW,IAAO,MAC5B,EACH,IAAK,OACH,OAAOF,EAAO,IAAKE,GAAMA,IAAM,KAAO,KAAO,IAAI,KAAKA,CAAC,CAAC,EAE1D,QACE,OAAOF,CACb,CACA,CACA,SAAS6rB,GAAa7rB,EAAQ,CAC5B,UAAWE,KAAKF,EACd,GAAIE,GAAM,KACV,IAAI,OAAOA,GAAM,SAAU,MAAO,MAClC,GAAI,OAAOA,GAAM,SAAU,MAAO,OAClC,GAAI,OAAOA,GAAM,UAAW,MAAO,OACnC,GAAIA,aAAa,KAAM,MAAO,OAC9B,GAAI,MAAM,QAAQA,CAAC,GAAK,OAAOA,GAAM,SAAU,MAAO,SAExD,MAAO,KACT,CACA,SAAS6rB,GAAYxmB,EAAOvF,EAAQ,CAClC,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,IAAK,SACH,OAAOoB,GAAa,KAAKpB,CAAM,EACjC,QACE,MAAM,IAAIpC,EACR,oBACA,8CAA8C2H,CAAK,EAC3D,CACA,CACA,CACA,SAASqsB,GAAYjxB,EAAO,CAC1B,OAAIA,EAAQ,KAAa,GAAGA,CAAK,KAC7BA,EAAQ,KAAO,KAAa,IAAIA,EAAQ,MAAM,QAAQ,CAAC,CAAC,MACxDA,EAAQ,KAAO,KAAO,KAAa,IAAIA,GAAS,KAAO,OAAO,QAAQ,CAAC,CAAC,MACrE,IAAIA,GAAS,KAAO,KAAO,OAAO,QAAQ,CAAC,CAAC,KACrD,CACAqD,GAA0B,CAACsB,EAAS6R,IAAgB,IAAI+T,GAAU5lB,EAAS6R,CAAW,CAAC,EAGvF,SAASuc,GAAiB50B,EAAO,CAC/B,OAAI,OAAOA,GAAU,SAAiB,MAClC,OAAOA,GAAU,SAAiB,OAClC,OAAOA,GAAU,UAAkB,OACnCA,aAAiB,KAAa,OAC3B,KACT,CACA,SAAS60B,GAAsBpuB,EAAOvF,EAAQ,CAC5C,OAAQuF,EAAK,CACX,IAAK,MACH,OAAOnG,EAAc,KAAKY,CAAM,EAClC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOgB,EAAc,KAAKhB,CAAM,EAClC,IAAK,OACH,OAAOkB,EAAW,KAAKlB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,IAAI4zB,GAAW,cAAc9tB,CAAK,CAChC,SACA,WACA,YAAY+tB,EAASC,EAAW,CAC9B,MAAK,EACL,KAAK,SAAWD,EAChB,KAAK,WAAaC,CACpB,CACA,IAAI,cAAe,CACjB,MAAMttB,EAAuB,IAAI,IACjC,UAAWutB,KAAU,KAAK,SAAU,CAClC,UAAWtxB,KAAKsxB,EAAO,UAAU,aAAcvtB,EAAK,IAAI/D,CAAC,EACzD,UAAWA,KAAKsxB,EAAO,MAAM,aAAcvtB,EAAK,IAAI/D,CAAC,CACvD,CACA,GAAI,KAAK,WACP,UAAWA,KAAK,KAAK,WAAW,aAAc+D,EAAK,IAAI/D,CAAC,EAE1D,MAAO,CAAC,GAAG+D,CAAI,CACjB,CACA,UAAW,CACT,MAAMqM,EAAQ,KAAK,SAAS,IAAKvH,GAAM,QAAQA,EAAE,UAAU,SAAQ,CAAE,SAASA,EAAE,MAAM,SAAQ,CAAE,EAAE,EAClG,OAAI,KAAK,YACPuH,EAAM,KAAK,QAAQ,KAAK,WAAW,SAAQ,CAAE,EAAE,EAE1C,QAAQA,EAAM,KAAK,GAAG,CAAC,MAChC,CACA,SAAS7K,EAAK,CACZ,MAAMxH,EAAMwH,EAAI,OACVgsB,EAAmB,KAAK,SAAS,IAAK1oB,GAAMA,EAAE,UAAU,SAAStD,CAAG,CAAC,EACrEisB,EAAe,KAAK,SAAS,IAAK3oB,GAAMA,EAAE,MAAM,SAAStD,CAAG,CAAC,EAC7DksB,EAAkB,KAAK,WAAa,KAAK,WAAW,SAASlsB,CAAG,EAAI,KACpEhG,EAAU,CAAA,EAChB,IAAImyB,EAAgB,KACpB,QAASp1B,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,IAAIq1B,EAAU,GACd,QAASpgB,EAAI,EAAGA,EAAI,KAAK,SAAS,OAAQA,IAExC,GADaggB,EAAiBhgB,CAAC,EAAE,IAAIjV,CAAC,IACzB,GAAM,CACjB,MAAMgB,EAAMk0B,EAAajgB,CAAC,EAAE,IAAIjV,CAAC,EACjCiD,EAAQ,KAAKjC,CAAG,EACZo0B,IAAkB,MAAQp0B,IAAQ,OACpCo0B,EAAgBT,GAAiB3zB,CAAG,GAEtCq0B,EAAU,GACV,KACF,CAEF,GAAI,CAACA,EACH,GAAIF,EAAiB,CACnB,MAAMn0B,EAAMm0B,EAAgB,IAAIn1B,CAAC,EACjCiD,EAAQ,KAAKjC,CAAG,EACZo0B,IAAkB,MAAQp0B,IAAQ,OACpCo0B,EAAgBT,GAAiB3zB,CAAG,EAExC,MACEiC,EAAQ,KAAK,IAAI,CAGvB,CAEA,MAAMH,EAAO8xB,GADCQ,GAAiB,MACWnyB,CAAO,EACjD,OAAO,IAAID,EAAO,GAAIF,CAAI,CAC5B,CACF,EACIwyB,GAAc,KAAM,CACtB,WACA,YAAYC,EAAW,CACrB,KAAK,WAAaA,CACpB,CACA,KAAKx1B,EAAO,CACV,MAAM+I,EAAO/I,aAAiBgH,EAAOhH,EAAQ,IAAIyI,GAAYzI,CAAK,EAClE,OAAO,IAAIy1B,GAAY,CAAC,CAAE,UAAW,KAAK,WAAY,MAAO1sB,CAAI,CAAE,CAAC,CACtE,CACF,EACI0sB,GAAc,KAAM,CACtB,SACA,YAAYV,EAAS,CACnB,KAAK,SAAWA,CAClB,CACA,KAAKS,EAAW,CACd,OAAO,IAAIE,GAAmB,KAAK,SAAUF,CAAS,CACxD,CACA,UAAUx1B,EAAO,CACf,MAAM+I,EAAO/I,aAAiBgH,EAAOhH,EAAQ,IAAIyI,GAAYzI,CAAK,EAClE,OAAO,IAAI80B,GAAS,KAAK,SAAU/rB,CAAI,CACzC,CACF,EACI2sB,GAAqB,KAAM,CAC7B,SACA,WACA,YAAYX,EAASS,EAAW,CAC9B,KAAK,SAAWT,EAChB,KAAK,WAAaS,CACpB,CACA,KAAKx1B,EAAO,CACV,MAAM+I,EAAO/I,aAAiBgH,EAAOhH,EAAQ,IAAIyI,GAAYzI,CAAK,EAClE,OAAO,IAAIy1B,GAAY,CAAC,GAAG,KAAK,SAAU,CAAE,UAAW,KAAK,WAAY,MAAO1sB,CAAI,CAAE,CAAC,CACxF,CACF,EACA,SAAS4sB,GAAKH,EAAW,CACvB,OAAO,IAAID,GAAYC,CAAS,CAClC,CAGA,IAAII,GAAkB,cAAc5uB,CAAK,CACvC,OACA,IACA,YAAYiD,EAAOV,EAAI,CACrB,MAAK,EACL,KAAK,OAASU,EACd,KAAK,IAAMV,CACb,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,QAAQ,KAAK,GAAG,IAClD,CACA,SAASL,EAAK,CACZ,MAAMzG,EAAS,KAAK,OAAO,SAASyG,CAAG,EACjChG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,IAAIxC,CAAC,EACxB,GAAIgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,MAEjB,QAAQ,KAAK,IAAG,CACd,IAAK,cACHA,EAAQ,KAAKjC,EAAI,aAAa,EAC9B,MACF,IAAK,cACHiC,EAAQ,KAAKjC,EAAI,aAAa,EAC9B,MACF,IAAK,OACHiC,EAAQ,KAAKjC,EAAI,MAAM,EACvB,KACZ,CAEI,CACA,OAAO,IAAIgC,EAAO,GAAI1B,EAAW,KAAK2B,CAAO,CAAC,CAChD,CACF,EACI2yB,GAAqB,cAAc7uB,CAAK,CAC1C,OACA,SACA,YAAYiD,EAAOrH,EAAS,CAC1B,MAAK,EACL,KAAK,OAASqH,EACd,KAAK,SAAWrH,CAClB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,kBAAkB,KAAK,QAAQ,IACjE,CACA,SAASsG,EAAK,CACZ,MAAMzG,EAAS,KAAK,OAAO,SAASyG,CAAG,EACjChG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,IAAIxC,CAAC,EACxBiD,EAAQ,KAAKjC,IAAQ,KAAO,KAAOA,EAAI,SAAS,KAAK,QAAQ,CAAC,CAChE,CACA,OAAO,IAAIgC,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACI4yB,GAAuB,cAAc9uB,CAAK,CAC5C,OACA,QACA,YAAYiD,EAAOvH,EAAQ,CACzB,MAAK,EACL,KAAK,OAASuH,EACd,KAAK,QAAUvH,CACjB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,oBAAoB,KAAK,OAAO,IAClE,CACA,SAASwG,EAAK,CACZ,MAAMzG,EAAS,KAAK,OAAO,SAASyG,CAAG,EACjChG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,IAAIxC,CAAC,EACxBiD,EAAQ,KAAKjC,IAAQ,KAAO,KAAOA,EAAI,WAAW,KAAK,OAAO,CAAC,CACjE,CACA,OAAO,IAAIgC,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACI6yB,GAAqB,cAAc/uB,CAAK,CAC1C,OACA,QACA,YAAYiD,EAAOtH,EAAQ,CACzB,MAAK,EACL,KAAK,OAASsH,EACd,KAAK,QAAUtH,CACjB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,kBAAkB,KAAK,OAAO,IAChE,CACA,SAASuG,EAAK,CACZ,MAAMzG,EAAS,KAAK,OAAO,SAASyG,CAAG,EACjChG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,IAAIxC,CAAC,EACxBiD,EAAQ,KAAKjC,IAAQ,KAAO,KAAOA,EAAI,SAAS,KAAK,OAAO,CAAC,CAC/D,CACA,OAAO,IAAIgC,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACI8yB,GAAoB,cAAchvB,CAAK,CACzC,OACA,SACA,aACA,YAAYiD,EAAOrH,EAASC,EAAa,CACvC,MAAK,EACL,KAAK,OAASoH,EACd,KAAK,SAAWrH,EAChB,KAAK,aAAeC,CACtB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,iBAAiB,KAAK,QAAQ,OAAO,KAAK,YAAY,IACxF,CACA,SAASqG,EAAK,CACZ,MAAMzG,EAAS,KAAK,OAAO,SAASyG,CAAG,EACjChG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,IAAIxC,CAAC,EACxBiD,EAAQ,KAAKjC,IAAQ,KAAO,KAAOA,EAAI,WAAW,KAAK,SAAU,KAAK,YAAY,CAAC,CACrF,CACA,OAAO,IAAIgC,EAAO,GAAI1B,EAAW,KAAK2B,CAAO,CAAC,CAChD,CACF,EACI+yB,GAAkB,cAAcjvB,CAAK,CACvC,OACA,OACA,KACA,YAAYiD,EAAOxJ,EAAOC,EAAK,CAC7B,MAAK,EACL,KAAK,OAASuJ,EACd,KAAK,OAASxJ,EACd,KAAK,KAAOC,CACd,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,cAAc,KAAK,MAAM,GAAG,KAAK,OAAS,OAAS,KAAK,KAAK,IAAI,GAAK,EAAE,GAC1G,CACA,SAASwI,EAAK,CACZ,MAAMzG,EAAS,KAAK,OAAO,SAASyG,CAAG,EACjChG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,IAAIxC,CAAC,EACxBiD,EAAQ,KAAKjC,IAAQ,KAAO,KAAOA,EAAI,MAAM,KAAK,OAAQ,KAAK,IAAI,CAAC,CACtE,CACA,OAAO,IAAIgC,EAAO,GAAI1B,EAAW,KAAK2B,CAAO,CAAC,CAChD,CACF,EACIgzB,GAAmB,cAAclvB,CAAK,CACxC,OACA,YAAYiD,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,eAClC,CACA,SAASf,EAAK,CACZ,MAAMzG,EAAS,KAAK,OAAO,SAASyG,CAAG,EACjChG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,IAAIxC,CAAC,EACxBiD,EAAQ,KAAKjC,IAAQ,KAAO,KAAOA,EAAI,MAAM,CAC/C,CACA,OAAO,IAAIgC,EAAO,GAAI3C,EAAc,KAAK4C,CAAO,CAAC,CACnD,CACF,EACIizB,GAAmB,cAAcnvB,CAAK,CACxC,OACA,YAAY+M,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,MAAMrM,EAAuB,IAAI,IACjC,UAAWosB,KAAQ,KAAK,OACtB,GAAIA,aAAgB9sB,EAClB,UAAWrD,KAAKmwB,EAAK,aAAcpsB,EAAK,IAAI/D,CAAC,EAGjD,MAAO,CAAC,GAAG+D,CAAI,CACjB,CACA,UAAW,CAET,MAAO,UADO,KAAK,OAAO,IAAK0uB,GAAMA,aAAapvB,EAAOovB,EAAE,SAAQ,EAAK,IAAIA,CAAC,GAAG,EACzD,KAAK,IAAI,CAAC,GACnC,CACA,SAASltB,EAAK,CACZ,MAAMxH,EAAMwH,EAAI,OACVmtB,EAAiB,KAAK,OAAO,IAAKvC,GAClCA,aAAgB9sB,EAAa8sB,EAAK,SAAS5qB,CAAG,EAC3C4qB,CACR,EACK5wB,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,IAAIkB,EAAU,GACVhB,EAAS,GACb,UAAW2zB,KAAQuC,EACjB,GAAI,OAAOvC,GAAS,SAClB3zB,GAAU2zB,MACL,CACL,MAAM7yB,EAAM6yB,EAAK,IAAI7zB,CAAC,EACtB,GAAIgB,IAAQ,KAAM,CAChBE,EAAU,GACV,KACF,CACAhB,GAAUc,CACZ,CAEFiC,EAAQ,KAAK/B,EAAU,KAAOhB,CAAM,CACtC,CACA,OAAO,IAAI8C,EAAO,GAAI1B,EAAW,KAAK2B,CAAO,CAAC,CAChD,CACF,EACIozB,GAAqB,KAAM,CAC7B,MACA,YAAYvtB,EAAM,CAChB,KAAK,MAAQA,CACf,CACA,aAAc,CACZ,OAAO,IAAI6sB,GAAgB,KAAK,MAAO,aAAa,CACtD,CACA,aAAc,CACZ,OAAO,IAAIA,GAAgB,KAAK,MAAO,aAAa,CACtD,CACA,MAAO,CACL,OAAO,IAAIA,GAAgB,KAAK,MAAO,MAAM,CAC/C,CACA,SAAShzB,EAAS,CAChB,OAAO,IAAIizB,GAAmB,KAAK,MAAOjzB,CAAO,CACnD,CACA,WAAWF,EAAQ,CACjB,OAAO,IAAIozB,GAAqB,KAAK,MAAOpzB,CAAM,CACpD,CACA,SAASC,EAAQ,CACf,OAAO,IAAIozB,GAAmB,KAAK,MAAOpzB,CAAM,CAClD,CACA,QAAQC,EAASC,EAAa,CAC5B,OAAO,IAAImzB,GAAkB,KAAK,MAAOpzB,EAASC,CAAW,CAC/D,CACA,MAAMpC,EAAOC,EAAK,CAChB,OAAO,IAAIu1B,GAAgB,KAAK,MAAOx1B,EAAOC,CAAG,CACnD,CACA,QAAS,CACP,OAAO,IAAIw1B,GAAiB,KAAK,KAAK,CACxC,CACA,UAAUniB,EAAO,CACf,OAAO,IAAIoiB,GAAiB,CAAC,KAAK,MAAO,GAAGpiB,CAAK,CAAC,CACpD,CACF,EAGA,SAASwiB,GAAqBhyB,EAAMgF,EAAI,CACtC,OAAQA,EAAE,CACR,IAAK,OACH,OAAOhF,EAAK,YAAW,EACzB,IAAK,QACH,OAAOA,EAAK,SAAQ,EAAK,EAC3B,IAAK,MACH,OAAOA,EAAK,QAAO,EACrB,IAAK,OACH,OAAOA,EAAK,SAAQ,EACtB,IAAK,SACH,OAAOA,EAAK,WAAU,EACxB,IAAK,SACH,OAAOA,EAAK,WAAU,EACxB,IAAK,YACH,OAAOA,EAAK,OAAM,EACpB,IAAK,YAAa,CAChB,MAAM9D,EAAQ,IAAI,KAAK8D,EAAK,YAAW,EAAI,EAAG,CAAC,EACzCX,EAAOW,EAAK,QAAO,EAAK9D,EAAM,QAAO,EACrCoD,EAAS,IAAM,GAAK,GAAK,GAC/B,OAAO,KAAK,MAAMD,EAAOC,CAAM,CACjC,CACA,IAAK,aAAc,CACjB,MAAMC,EAAS,IAAI,KAAKS,EAAK,QAAO,CAAE,EACtCT,EAAO,SAAS,EAAG,EAAG,EAAG,CAAC,EAC1BA,EAAO,QAAQA,EAAO,UAAY,GAAKA,EAAO,OAAM,EAAK,GAAK,CAAC,EAC/D,MAAMC,EAAO,IAAI,KAAKD,EAAO,YAAW,EAAI,EAAG,CAAC,EAC1CE,GAAWF,EAAO,UAAYC,EAAK,QAAO,IAAO,IAAM,GAAK,GAAK,IACvE,MAAO,GAAI,KAAK,OAAOC,EAAU,GAAKD,EAAK,OAAM,EAAK,GAAK,GAAK,CAAC,CACnE,CACA,IAAK,UACH,OAAO,KAAK,MAAMQ,EAAK,SAAQ,EAAK,CAAC,EAAI,EAC3C,IAAK,YACH,OAAOA,EAAK,QAAO,CACzB,CACA,CACA,IAAIiyB,GAAoB,cAAcxvB,CAAK,CACzC,OACA,IACA,YAAYiD,EAAOV,EAAI,CACrB,MAAK,EACL,KAAK,OAASU,EACd,KAAK,IAAMV,CACb,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,OAAO,KAAK,GAAG,IACjD,CACA,SAASL,EAAK,CACZ,MAAMzG,EAAS,KAAK,OAAO,SAASyG,CAAG,EACjChG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,IAAIxC,CAAC,EACxBiD,EAAQ,KAAKjC,IAAQ,KAAO,KAAOs1B,GAAqBt1B,EAAK,KAAK,GAAG,CAAC,CACxE,CACA,OAAO,IAAIgC,EAAO,GAAI3C,EAAc,KAAK4C,CAAO,CAAC,CACnD,CACF,EACIuzB,GAAmB,cAAczvB,CAAK,CACxC,OACA,MACA,YAAYiD,EAAO/F,EAAM,CACvB,MAAK,EACL,KAAK,OAAS+F,EACd,KAAK,MAAQ/F,CACf,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,iBAAiB,KAAK,KAAK,IAC7D,CACA,SAASgF,EAAK,CACZ,MAAMzG,EAAS,KAAK,OAAO,SAASyG,CAAG,EACjChG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIwC,EAAO,OAAQxC,IAAK,CACtC,MAAMgB,EAAMwB,EAAO,IAAIxC,CAAC,EACpBgB,IAAQ,KACViC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKwzB,GAAcz1B,EAAK,KAAK,KAAK,CAAC,CAE/C,CACA,OAAO,IAAIgC,EAAO,GAAIb,EAAW,KAAKc,CAAO,CAAC,CAChD,CACF,EACIyzB,GAAe,cAAc3vB,CAAK,CACpC,MACA,OACA,MACA,YAAYqC,EAAMC,EAAOpF,EAAM,CAC7B,MAAK,EACL,KAAK,MAAQmF,EACb,KAAK,OAASC,EACd,KAAK,MAAQpF,CACf,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,MAAM,aAAc,GAAG,KAAK,OAAO,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,YAAY,KAAK,MAAM,SAAQ,CAAE,KAAK,KAAK,OAAO,SAAQ,CAAE,MAAM,KAAK,KAAK,IACrF,CACA,SAASgF,EAAK,CACZ,MAAMM,EAAa,KAAK,MAAM,SAASN,CAAG,EACpCO,EAAc,KAAK,OAAO,SAASP,CAAG,EACtCxH,EAAM8H,EAAW,OACjBtG,EAAU,CAAA,EAChB,QAASjD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMkE,EAAIqF,EAAW,IAAIvJ,CAAC,EACpBmE,EAAIqF,EAAY,IAAIxJ,CAAC,EAC3B,GAAIkE,IAAM,MAAQC,IAAM,KACtBlB,EAAQ,KAAK,IAAI,MACZ,CACL,MAAM0B,EAAST,EAAE,QAAO,EAAKC,EAAE,QAAO,EACtClB,EAAQ,KAAK0zB,GAAoBhyB,EAAQ,KAAK,KAAK,CAAC,CACtD,CACF,CACA,OAAO,IAAI3B,EAAO,GAAI3C,EAAc,KAAK4C,CAAO,CAAC,CACnD,CACF,EACA,SAAS0zB,GAAoBC,EAAI3yB,EAAM,CACrC,OAAQA,EAAI,CACV,IAAK,eACH,OAAO2yB,EACT,IAAK,UACH,OAAOA,EAAK,IACd,IAAK,UACH,OAAOA,GAAM,IAAM,IACrB,IAAK,QACH,OAAOA,GAAM,IAAM,GAAK,IAC1B,IAAK,OACH,OAAOA,GAAM,IAAM,GAAK,GAAK,GACnC,CACA,CACA,SAASH,GAAcnyB,EAAML,EAAM,CACjC,OAAQA,EAAI,CACV,IAAK,OACH,OAAO,IAAI,KAAKK,EAAK,YAAW,EAAI,EAAG,CAAC,EAC1C,IAAK,QACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAI,CAAC,EACxD,IAAK,MACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,SAAS,EACrE,IAAK,OACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,QAAO,EAAIA,EAAK,SAAQ,CAAE,EACtF,IAAK,SACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,QAAO,EAAIA,EAAK,SAAQ,EAAIA,EAAK,WAAU,CAAE,EACzG,IAAK,SACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,QAAO,EAAIA,EAAK,WAAYA,EAAK,aAAcA,EAAK,YAAY,CAChI,CACA,CACG,IAACuyB,GAAmB,KAAM,CAC3B,MACA,YAAY/tB,EAAM,CAChB,KAAK,MAAQA,CACf,CACA,MAAO,CACL,OAAO,IAAIytB,GAAkB,KAAK,MAAO,MAAM,CACjD,CACA,OAAQ,CACN,OAAO,IAAIA,GAAkB,KAAK,MAAO,OAAO,CAClD,CACA,KAAM,CACJ,OAAO,IAAIA,GAAkB,KAAK,MAAO,KAAK,CAChD,CACA,MAAO,CACL,OAAO,IAAIA,GAAkB,KAAK,MAAO,MAAM,CACjD,CACA,QAAS,CACP,OAAO,IAAIA,GAAkB,KAAK,MAAO,QAAQ,CACnD,CACA,QAAS,CACP,OAAO,IAAIA,GAAkB,KAAK,MAAO,QAAQ,CACnD,CACA,WAAY,CACV,OAAO,IAAIA,GAAkB,KAAK,MAAO,WAAW,CACtD,CACA,WAAY,CACV,OAAO,IAAIA,GAAkB,KAAK,MAAO,WAAW,CACtD,CACA,YAAa,CACX,OAAO,IAAIA,GAAkB,KAAK,MAAO,YAAY,CACvD,CACA,SAAU,CACR,OAAO,IAAIA,GAAkB,KAAK,MAAO,SAAS,CACpD,CACA,WAAY,CACV,OAAO,IAAIA,GAAkB,KAAK,MAAO,WAAW,CACtD,CACA,SAAStyB,EAAM,CACb,OAAO,IAAIuyB,GAAiB,KAAK,MAAOvyB,CAAI,CAC9C,CACA,KAAKhE,EAAOgE,EAAO,OAAQ,CACzB,OAAO,IAAIyyB,GAAa,KAAK,MAAOz2B,EAAOgE,CAAI,CACjD,CACF,EAGI6yB,GAAoB,cAAc/vB,CAAK,CACzC,QACA,YACA,YAAY5D,EAAQkmB,EAAa,GAAO,CACtC,MAAK,EACL,KAAK,QAAUlmB,EACf,KAAK,YAAckmB,CACrB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACA,aAAanlB,EAAGC,EAAG,CACjB,OAAO,KAAK,YAAc,CAAC4yB,GAAc7yB,EAAGC,CAAC,EAAI4yB,GAAc7yB,EAAGC,CAAC,CACrE,CACF,EACI6yB,GAAiB,MAAMC,WAAwBH,EAAkB,CACnE,UAAW,CACT,MAAO,QAAQ,KAAK,QAAQ,SAAQ,CAAE,GACxC,CACA,eAAepI,EAAM,CACnB,OAAO,IAAIuI,GAAgB,KAAK,QAASvI,CAAI,CAC/C,CACA,SAASzlB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACb00B,EAAU,CAAA,EAChB,QAASl3B,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBk3B,EAAQ,KAAK,CAAE,MAAO10B,EAAO,IAAIxC,CAAC,EAAG,IAAKA,EAAG,EAE/Ck3B,EAAQ,KAAK,CAAChzB,EAAGC,IAAM,KAAK,aAAaD,EAAE,MAAOC,EAAE,KAAK,CAAC,EAC1D,MAAMgzB,EAAQ,IAAI,MAAM11B,CAAG,EAC3B,IAAIstB,EAAO,EACX,QAAS/uB,EAAI,EAAGA,EAAIk3B,EAAQ,OAAQl3B,IAC9BA,EAAI,GAAK+2B,GAAcG,EAAQl3B,CAAC,EAAE,MAAOk3B,EAAQl3B,EAAI,CAAC,EAAE,KAAK,IAAM,IACrE+uB,EAAO/uB,EAAI,GAEbm3B,EAAMD,EAAQl3B,CAAC,EAAE,GAAG,EAAI+uB,EAE1B,OAAO,IAAI/rB,EAAO,OAAQ3C,EAAc,KAAK82B,CAAK,CAAC,CACrD,CACF,EACIC,GAAsB,MAAMC,WAA6BP,EAAkB,CAC7E,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,GAC9C,CACA,eAAepI,EAAM,CACnB,OAAO,IAAI2I,GAAqB,KAAK,QAAS3I,CAAI,CACpD,CACA,SAASzlB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACb00B,EAAU,CAAA,EAChB,QAASl3B,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBk3B,EAAQ,KAAK,CAAE,MAAO10B,EAAO,IAAIxC,CAAC,EAAG,IAAKA,EAAG,EAE/Ck3B,EAAQ,KAAK,CAAChzB,EAAGC,IAAM,KAAK,aAAaD,EAAE,MAAOC,EAAE,KAAK,CAAC,EAC1D,MAAMgzB,EAAQ,IAAI,MAAM11B,CAAG,EAC3B,IAAIstB,EAAO,EACX,QAAS/uB,EAAI,EAAGA,EAAIk3B,EAAQ,OAAQl3B,IAC9BA,EAAI,GAAK+2B,GAAcG,EAAQl3B,CAAC,EAAE,MAAOk3B,EAAQl3B,EAAI,CAAC,EAAE,KAAK,IAAM,GACrE+uB,IAEFoI,EAAMD,EAAQl3B,CAAC,EAAE,GAAG,EAAI+uB,EAE1B,OAAO,IAAI/rB,EAAO,aAAc3C,EAAc,KAAK82B,CAAK,CAAC,CAC3D,CACF,EACIG,GAAsB,MAAMC,WAA6BT,EAAkB,CAC7E,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,GAC9C,CACA,eAAepI,EAAM,CACnB,OAAO,IAAI6I,GAAqB,KAAK,QAAS7I,CAAI,CACpD,CACA,SAASzlB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbvB,EAAS,IAAI,MAAMQ,CAAG,EAC5B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAKiB,EAAOjB,CAAC,EAAIwC,EAAO,IAAIxC,CAAC,EACtD,MAAMk3B,EAAU,MAAM,KAAK,CAAE,OAAQz1B,CAAG,EAAI,CAACmL,EAAG5M,IAAMA,CAAC,EACvDk3B,EAAQ,KAAK,CAAChzB,EAAGC,IAAM,KAAK,aAAalD,EAAOiD,CAAC,EAAGjD,EAAOkD,CAAC,CAAC,CAAC,EAC9D,MAAMgzB,EAAQ,IAAI,MAAM11B,CAAG,EAC3B,QAASzB,EAAI,EAAGA,EAAIk3B,EAAQ,OAAQl3B,IAClCm3B,EAAMD,EAAQl3B,CAAC,CAAC,EAAIA,EAAI,EAE1B,OAAO,IAAIgD,EAAO,aAAc3C,EAAc,KAAK82B,CAAK,CAAC,CAC3D,CACF,EACIK,GAAwB,MAAMC,WAA+BX,EAAkB,CACjF,UAAW,CACT,MAAO,gBAAgB,KAAK,QAAQ,SAAQ,CAAE,GAChD,CACA,eAAepI,EAAM,CACnB,OAAO,IAAI+I,GAAuB,KAAK,QAAS/I,CAAI,CACtD,CACA,SAASzlB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACnB,GAAIf,GAAO,EAAG,CACZ,MAAMwB,EAAU,IAAI,MAAMxB,CAAG,EAAE,KAAK,CAAC,EACrC,OAAO,IAAIuB,EAAO,eAAgB3C,EAAc,KAAK4C,CAAO,CAAC,CAC/D,CACA,MAAMi0B,EAAU,CAAA,EAChB,QAASl3B,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBk3B,EAAQ,KAAK,CAAE,MAAO10B,EAAO,IAAIxC,CAAC,EAAG,IAAKA,EAAG,EAE/Ck3B,EAAQ,KAAK,CAAChzB,EAAGC,IAAM,KAAK,aAAaD,EAAE,MAAOC,EAAE,KAAK,CAAC,EAC1D,MAAMgzB,EAAQ,IAAI,MAAM11B,CAAG,EAC3B,IAAIstB,EAAO,EACX,QAAS/uB,EAAI,EAAGA,EAAIk3B,EAAQ,OAAQl3B,IAC9BA,EAAI,GAAK+2B,GAAcG,EAAQl3B,CAAC,EAAE,MAAOk3B,EAAQl3B,EAAI,CAAC,EAAE,KAAK,IAAM,IACrE+uB,EAAO/uB,EAAI,GAEbm3B,EAAMD,EAAQl3B,CAAC,EAAE,GAAG,GAAK+uB,EAAO,IAAMttB,EAAM,GAE9C,OAAO,IAAIuB,EAAO,eAAgB3C,EAAc,KAAK82B,CAAK,CAAC,CAC7D,CACF,EACIO,GAAkB,MAAMC,WAAyBb,EAAkB,CACrE,GACA,YAAY3zB,EAAQ,EAAGkmB,EAAa,GAAO,CACzC,MAAMlmB,EAAQkmB,CAAU,EACxB,KAAK,GAAK,CACZ,CACA,UAAW,CACT,MAAO,SAAS,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,EAAE,GACrD,CACA,eAAeqF,EAAM,CACnB,OAAO,IAAIiJ,GAAiB,KAAK,QAAS,KAAK,GAAIjJ,CAAI,CACzD,CACA,SAASzlB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACb00B,EAAU,CAAA,EAChB,QAAS,EAAI,EAAG,EAAIz1B,EAAK,IACvBy1B,EAAQ,KAAK,CAAE,MAAO10B,EAAO,IAAI,CAAC,EAAG,IAAK,EAAG,EAE/C00B,EAAQ,KAAK,CAAChzB,EAAGC,IAAM,KAAK,aAAaD,EAAE,MAAOC,EAAE,KAAK,CAAC,EAC1D,MAAMlB,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAAS,EAAI,EAAG,EAAIy1B,EAAQ,OAAQ,IAClCj0B,EAAQi0B,EAAQ,CAAC,EAAE,GAAG,EAAI,KAAK,MAAM,EAAI,KAAK,GAAKz1B,CAAG,EAAI,EAE5D,OAAO,IAAIuB,EAAO,QAAS3C,EAAc,KAAK4C,CAAO,CAAC,CACxD,CACF,EACA,SAAS8zB,GAAc7yB,EAAGC,EAAG,CAC3B,GAAID,IAAM,MAAQC,IAAM,KAAM,MAAO,GACrC,GAAID,IAAM,KAAM,MAAO,GACvB,GAAIC,IAAM,KAAM,MAAO,GACvB,GAAI,OAAOD,GAAM,UAAY,OAAOC,GAAM,SACxC,OAAOD,EAAIC,EAEb,GAAI,OAAOD,GAAM,UAAY,OAAOC,GAAM,SACxC,OAAOD,EAAIC,EAAI,GAAKD,EAAIC,EAAI,EAAI,EAElC,GAAID,aAAa,MAAQC,aAAa,KACpC,OAAOD,EAAE,UAAYC,EAAE,QAAO,EAEhC,MAAMyqB,EAAK,OAAO1qB,GAAM,SAAWA,EAAI,OAAOA,GAAM,SAAW,GAAGA,CAAC,GAAK,OAAOA,GAAM,UAAY,GAAGA,CAAC,GAAK,SACpG2qB,EAAK,OAAO1qB,GAAM,SAAWA,EAAI,OAAOA,GAAM,SAAW,GAAGA,CAAC,GAAK,OAAOA,GAAM,UAAY,GAAGA,CAAC,GAAK,SAC1G,OAAOyqB,EAAKC,EAAK,GAAKD,EAAKC,EAAK,EAAI,CACtC,CACA,IAAI+I,GAAiB,cAAc7wB,CAAK,CACtC,QACA,YAAY5D,EAAQ,CAClB,MAAK,EACL,KAAK,QAAUA,CACjB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACF,EACI00B,GAAa,cAAcD,EAAe,CAC5C,UAAW,CACT,MAAO,UAAU,KAAK,QAAQ,SAAQ,CAAE,GAC1C,CACA,SAAS3uB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbS,EAAU,IAAI,MAAMxB,CAAG,EAC7B,IAAI6a,EAAM,EACV,QAAStc,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIqB,EAAO,IAAIxC,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7Bmb,GAAOnb,GAET8B,EAAQjD,CAAC,EAAIsc,CACf,CACA,OAAO,IAAItZ,EAAO,SAAU3C,EAAc,KAAK4C,CAAO,CAAC,CACzD,CACF,EACI60B,GAAa,cAAcF,EAAe,CAC5C,UAAW,CACT,MAAO,UAAU,KAAK,QAAQ,SAAQ,CAAE,GAC1C,CACA,SAAS3uB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbS,EAAU,IAAI,MAAMxB,CAAG,EAC7B,IAAI+wB,EAAM,KACV,QAASxyB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIqB,EAAO,IAAIxC,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7BqxB,EAAMA,IAAQ,KAAOrxB,EAAI,KAAK,IAAIqxB,EAAKrxB,CAAC,GAE1C8B,EAAQjD,CAAC,EAAIwyB,CACf,CACA,OAAO,IAAIxvB,EAAO,SAAU3C,EAAc,KAAK4C,CAAO,CAAC,CACzD,CACF,EACI80B,GAAa,cAAcH,EAAe,CAC5C,UAAW,CACT,MAAO,UAAU,KAAK,QAAQ,SAAQ,CAAE,GAC1C,CACA,SAAS3uB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbS,EAAU,IAAI,MAAMxB,CAAG,EAC7B,IAAI8wB,EAAM,KACV,QAASvyB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIqB,EAAO,IAAIxC,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7BoxB,EAAMA,IAAQ,KAAOpxB,EAAI,KAAK,IAAIoxB,EAAKpxB,CAAC,GAE1C8B,EAAQjD,CAAC,EAAIuyB,CACf,CACA,OAAO,IAAIvvB,EAAO,SAAU3C,EAAc,KAAK4C,CAAO,CAAC,CACzD,CACF,EACI+0B,GAAc,cAAcJ,EAAe,CAC7C,UAAW,CACT,MAAO,WAAW,KAAK,QAAQ,SAAQ,CAAE,GAC3C,CACA,SAAS3uB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbS,EAAU,IAAI,MAAMxB,CAAG,EAC7B,IAAIw2B,EAAO,EACX,QAASj4B,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIqB,EAAO,IAAIxC,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7B82B,GAAQ92B,GAEV8B,EAAQjD,CAAC,EAAIi4B,CACf,CACA,OAAO,IAAIj1B,EAAO,UAAW3C,EAAc,KAAK4C,CAAO,CAAC,CAC1D,CACF,EACIi1B,GAAe,cAAcN,EAAe,CAC9C,UAAW,CACT,MAAO,YAAY,KAAK,QAAQ,SAAQ,CAAE,GAC5C,CACA,SAAS3uB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbS,EAAU,IAAI,MAAMxB,CAAG,EAC7B,IAAItD,EAAQ,EACZ,QAAS6B,EAAI,EAAGA,EAAIyB,EAAKzB,IACbwC,EAAO,IAAIxC,CAAC,IACZ,MACR7B,IAEF8E,EAAQjD,CAAC,EAAI7B,EAEf,OAAO,IAAI6E,EAAO,WAAY3C,EAAc,KAAK4C,CAAO,CAAC,CAC3D,CACF,EACIk1B,GAAa,cAAcpxB,CAAK,CAClC,QACA,QACA,YAAY5D,EAAQ2iB,EAAQ,CAC1B,MAAK,EACL,KAAK,QAAU3iB,EACf,KAAK,QAAU2iB,CACjB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACF,EACIsS,GAAY,cAAcD,EAAW,CACvC,UAAW,CACT,MAAO,SAAS,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,OAAO,GAC1D,CACA,SAASlvB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbS,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMq4B,EAASr4B,EAAI,KAAK,QACxB,GAAIq4B,EAAS,GAAKA,GAAU52B,EAC1BwB,EAAQjD,CAAC,EAAI,SACR,CACL,MAAMmB,EAAIqB,EAAO,IAAI61B,CAAM,EAC3Bp1B,EAAQjD,CAAC,EAAImB,IAAM,MAAQ,OAAOA,GAAM,SAAWA,EAAI,IACzD,CACF,CACA,OAAO,IAAI6B,EAAO,QAAS3C,EAAc,KAAK4C,CAAO,CAAC,CACxD,CACF,EACIq1B,GAAW,cAAcH,EAAW,CACtC,UAAW,CACT,MAAO,QAAQ,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,OAAO,GACzD,CACA,SAASlvB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbS,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMu4B,EAAUv4B,EAAI,KAAK,QACzB,GAAIu4B,EAAU,GAAKA,GAAW92B,EAC5BwB,EAAQjD,CAAC,EAAI,SACR,CACL,MAAMw4B,EAAOh2B,EAAO,IAAIxC,CAAC,EACnBy4B,EAAOj2B,EAAO,IAAI+1B,CAAO,EAC3BC,IAAS,MAAQ,OAAOA,GAAS,UAAYC,IAAS,MAAQ,OAAOA,GAAS,SAChFx1B,EAAQjD,CAAC,EAAIw4B,EAAOC,EAEpBx1B,EAAQjD,CAAC,EAAI,IAEjB,CACF,CACA,OAAO,IAAIgD,EAAO,OAAQ3C,EAAc,KAAK4C,CAAO,CAAC,CACvD,CACF,EACIy1B,GAAgB,cAAcP,EAAW,CAC3C,UAAW,CACT,MAAO,aAAa,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,OAAO,GAC9D,CACA,SAASlvB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbS,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMu4B,EAAUv4B,EAAI,KAAK,QACzB,GAAIu4B,EAAU,GAAKA,GAAW92B,EAC5BwB,EAAQjD,CAAC,EAAI,SACR,CACL,MAAMw4B,EAAOh2B,EAAO,IAAIxC,CAAC,EACnBy4B,EAAOj2B,EAAO,IAAI+1B,CAAO,EAC3BC,IAAS,MAAQ,OAAOA,GAAS,UAAYC,IAAS,MAAQ,OAAOA,GAAS,UAAYA,IAAS,EACrGx1B,EAAQjD,CAAC,GAAKw4B,EAAOC,GAAQA,EAE7Bx1B,EAAQjD,CAAC,EAAI,IAEjB,CACF,CACA,OAAO,IAAIgD,EAAO,YAAa3C,EAAc,KAAK4C,CAAO,CAAC,CAC5D,CACF,EACI01B,GAAc,cAAc5xB,CAAK,CACnC,QACA,YACA,YAAY5D,EAAQy1B,EAAY,CAC9B,MAAK,EACL,KAAK,QAAUz1B,EACf,KAAK,YAAcy1B,CACrB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACA,kBAAkB3vB,EAAK,CACrB,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbvB,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIqB,EAAO,IAAIxC,CAAC,EACtBiB,EAAO,KAAKE,IAAM,MAAQ,OAAOA,GAAM,SAAWA,EAAI,IAAI,CAC5D,CACA,OAAOF,CACT,CACF,EACI43B,GAAkB,cAAcF,EAAY,CAC9C,UAAW,CACT,MAAO,eAAe,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACpE,CACA,SAAS1vB,EAAK,CACZ,MAAMhI,EAAS,KAAK,kBAAkBgI,CAAG,EACnCxH,EAAMR,EAAO,OACbgC,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBiD,EAAQjD,CAAC,EAAI,SACR,CACL,IAAIsc,EAAM,EACNne,EAAQ,EACZ,QAAS8W,EAAIjV,EAAI,KAAK,YAAc,EAAGiV,GAAKjV,EAAGiV,IAAK,CAClD,MAAM9T,EAAIF,EAAOgU,CAAC,EACd9T,IAAM,OACRmb,GAAOnb,EACPhD,IAEJ,CACA8E,EAAQjD,CAAC,EAAI7B,EAAQ,EAAIme,EAAMne,EAAQ,IACzC,CAEF,OAAO,IAAI6E,EAAO,cAAe3C,EAAc,KAAK4C,CAAO,CAAC,CAC9D,CACF,EACI61B,GAAiB,cAAcH,EAAY,CAC7C,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACnE,CACA,SAAS1vB,EAAK,CACZ,MAAMhI,EAAS,KAAK,kBAAkBgI,CAAG,EACnCxH,EAAMR,EAAO,OACbgC,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBiD,EAAQjD,CAAC,EAAI,SACR,CACL,IAAIsc,EAAM,EACV,QAASrH,EAAIjV,EAAI,KAAK,YAAc,EAAGiV,GAAKjV,EAAGiV,IAAK,CAClD,MAAM9T,EAAIF,EAAOgU,CAAC,EACd9T,IAAM,OACRmb,GAAOnb,EAEX,CACA8B,EAAQjD,CAAC,EAAIsc,CACf,CAEF,OAAO,IAAItZ,EAAO,aAAc3C,EAAc,KAAK4C,CAAO,CAAC,CAC7D,CACF,EACI81B,GAAiB,cAAcJ,EAAY,CAC7C,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACnE,CACA,SAAS1vB,EAAK,CACZ,MAAMhI,EAAS,KAAK,kBAAkBgI,CAAG,EACnCxH,EAAMR,EAAO,OACbgC,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBiD,EAAQjD,CAAC,EAAI,SACR,CACL,MAAMg5B,EAAa,CAAA,EACnB,QAAS/jB,EAAIjV,EAAI,KAAK,YAAc,EAAGiV,GAAKjV,EAAGiV,IAAK,CAClD,MAAM9T,EAAIF,EAAOgU,CAAC,EACd9T,IAAM,MACR63B,EAAW,KAAK73B,CAAC,CAErB,CACA,GAAI63B,EAAW,OAAS,EACtB/1B,EAAQjD,CAAC,EAAI,SACR,CACL,IAAIsc,EAAM,EACV,UAAWnb,KAAK63B,EAAY1c,GAAOnb,EACnC,MAAMmJ,EAAOgS,EAAM0c,EAAW,OAC9B,IAAIC,EAAY,EAChB,UAAW93B,KAAK63B,EAAYC,IAAc93B,EAAImJ,IAASnJ,EAAImJ,GAC3DrH,EAAQjD,CAAC,EAAI,KAAK,KAAKi5B,GAAaD,EAAW,OAAS,EAAE,CAC5D,CACF,CAEF,OAAO,IAAIh2B,EAAO,aAAc3C,EAAc,KAAK4C,CAAO,CAAC,CAC7D,CACF,EACIi2B,GAAiB,cAAcP,EAAY,CAC7C,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACnE,CACA,SAAS1vB,EAAK,CACZ,MAAMhI,EAAS,KAAK,kBAAkBgI,CAAG,EACnCxH,EAAMR,EAAO,OACbgC,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBiD,EAAQjD,CAAC,EAAI,SACR,CACL,IAAIuyB,EAAM,KACV,QAAStd,EAAIjV,EAAI,KAAK,YAAc,EAAGiV,GAAKjV,EAAGiV,IAAK,CAClD,MAAM9T,EAAIF,EAAOgU,CAAC,EACd9T,IAAM,OACRoxB,EAAMA,IAAQ,KAAOpxB,EAAI,KAAK,IAAIoxB,EAAKpxB,CAAC,EAE5C,CACA8B,EAAQjD,CAAC,EAAIuyB,CACf,CAEF,OAAO,IAAIvvB,EAAO,aAAc3C,EAAc,KAAK4C,CAAO,CAAC,CAC7D,CACF,EACIk2B,GAAiB,cAAcR,EAAY,CAC7C,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACnE,CACA,SAAS1vB,EAAK,CACZ,MAAMhI,EAAS,KAAK,kBAAkBgI,CAAG,EACnCxH,EAAMR,EAAO,OACbgC,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBiD,EAAQjD,CAAC,EAAI,SACR,CACL,IAAIwyB,EAAM,KACV,QAASvd,EAAIjV,EAAI,KAAK,YAAc,EAAGiV,GAAKjV,EAAGiV,IAAK,CAClD,MAAM9T,EAAIF,EAAOgU,CAAC,EACd9T,IAAM,OACRqxB,EAAMA,IAAQ,KAAOrxB,EAAI,KAAK,IAAIqxB,EAAKrxB,CAAC,EAE5C,CACA8B,EAAQjD,CAAC,EAAIwyB,CACf,CAEF,OAAO,IAAIxvB,EAAO,aAAc3C,EAAc,KAAK4C,CAAO,CAAC,CAC7D,CACF,EACIm2B,GAAU,cAAcryB,CAAK,CAC/B,QACA,OACA,YAAY5D,EAAQk2B,EAAO,CACzB,MAAK,EACL,KAAK,QAAUl2B,EACf,KAAK,OAASk2B,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACA,UAAW,CACT,MAAO,OAAO,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,MAAM,GACvD,CACA,SAASpwB,EAAK,CACZ,MAAMzG,EAAS,KAAK,QAAQ,SAASyG,CAAG,EAClCxH,EAAMe,EAAO,OACbS,EAAU,IAAI,MAAMxB,CAAG,EAC7B,IAAI63B,EAAO,KACX,QAASt5B,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIqB,EAAO,IAAIxC,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WACzBm4B,IAAS,KACXA,EAAOn4B,EAEPm4B,EAAO,KAAK,OAASn4B,GAAK,EAAI,KAAK,QAAUm4B,GAE/Cr2B,EAAQjD,CAAC,EAAIs5B,CAIjB,CACA,OAAO,IAAIt2B,EAAO,MAAO3C,EAAc,KAAK4C,CAAO,CAAC,CACtD,CACF,EACIs2B,GAAwB,cAAcxyB,CAAK,CAC7C,OACA,eACA,YAAYiD,EAAOwvB,EAAe,CAChC,MAAK,EACL,KAAK,OAASxvB,EACd,KAAK,eAAiBwvB,CACxB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,aAAc,GAAG,KAAK,cAAc,CAAC,CAAC,CAC3F,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,SAAS,KAAK,eAAe,KAAK,IAAI,CAAC,GACzE,CACA,SAASvwB,EAAK,CACZ,MAAMxH,EAAMwH,EAAI,OACVhG,EAAU,IAAI,MAAMxB,CAAG,EACvBg4B,EAA+B,IAAI,IACnCC,EAAW,KAAK,eAAe,IAAKt0B,GAAS6D,EAAI,IAAI7D,CAAI,EAAE,MAAM,EACvE,QAAS,EAAI,EAAG,EAAI3D,EAAK,IAAK,CAC5B,MAAMuE,EAAM2zB,GAAcD,EAAU,CAAC,EAC/Bte,EAAQqe,EAAa,IAAIzzB,CAAG,EAC9BoV,EACFA,EAAM,KAAK,CAAC,EAEZqe,EAAa,IAAIzzB,EAAK,CAAC,CAAC,CAAC,CAE7B,CACA,MAAMoS,EAAcnP,EAAI,QACxB,UAAWrI,KAAW64B,EAAa,SAAU,CAC3C,MAAM7c,EAAe,IAAI,WAAWhc,CAAO,EACrCwc,EAA6B,IAAI,IACvC,UAAWhY,KAAQgT,EACjBgF,EAAW,IAAIhY,EAAM6D,EAAI,IAAI7D,CAAI,EAAE,OAAO,KAAKwX,CAAY,CAAC,EAE9D,MAAMgd,EAAQ,IAAIzN,GAAU/O,EAAYhF,CAAW,EAC7CyhB,EAAY,KAAK,OAAO,SAASD,CAAK,EAC5C,QAAS55B,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAClCiD,EAAQrC,EAAQZ,CAAC,CAAC,EAAI65B,EAAU,IAAI75B,CAAC,CAEzC,CACA,OAAO,IAAIgD,EAAO,OAAQ3C,EAAc,KAAK4C,CAAO,CAAC,CACvD,CACF,EACA,SAAS02B,GAAcpzB,EAAS3G,EAAO,CACrC,MAAMkU,EAAQ,CAAA,EACd,UAAW7U,KAAUsH,EAAS,CAC5B,MAAMpF,EAAIlC,EAAO,IAAIW,CAAK,EACtBuB,IAAM,KACR2S,EAAM,KAAK,QAAQ,EACV3S,aAAa,KACtB2S,EAAM,KAAK,MAAM3S,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxE2S,EAAM,KAAK,KAAK,OAAO3S,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtC2S,EAAM,KAAK,QAAQ,KAAK,UAAU3S,CAAC,CAAC,EAAE,CAE1C,CACA,OAAO2S,EAAM,KAAK,GAAG,CACvB,CACG,IAACgmB,GAAoB,cAAc/yB,CAAK,CACzC,OACA,UACA,WACA,YAAYiD,EAAO+vB,EAAUjP,EAAY,MAAO,CAC9C,MAAK,EACL,KAAK,OAAS9gB,EACd,KAAK,UAAY+vB,EACjB,KAAK,WAAajP,CACpB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,aAAc,KAAK,SAAS,CAAC,CAAC,CACnF,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,YAAY,KAAK,SAAS,KAAK,KAAK,UAAU,GAChF,CACA,SAAS7hB,EAAK,CACZ,MAAMxH,EAAMwH,EAAI,OACVogB,EAAa,KAAK,aAAe,OACjC2Q,EAAgBC,GAAsB,KAAK,OAAQ5Q,CAAU,EAC7D0Q,EAAW9wB,EAAI,IAAI,KAAK,SAAS,EAAE,OACnCrI,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIyB,EAAKzB,IAAKY,EAAQ,KAAKZ,CAAC,EAC5C,MAAMk6B,EAAM7Q,EAAa,GAAK,EAC9BzoB,EAAQ,KAAK,CAACsD,EAAGC,IAAM+1B,EAAMnD,GAAcgD,EAAS,IAAI71B,CAAC,EAAG61B,EAAS,IAAI51B,CAAC,CAAC,CAAC,EAC5E,MAAMyY,EAAe,IAAI,WAAWhc,CAAO,EACrCwX,EAAcnP,EAAI,QAClBmU,EAA6B,IAAI,IACvC,UAAWhY,KAAQgT,EACjBgF,EAAW,IAAIhY,EAAM6D,EAAI,IAAI7D,CAAI,EAAE,OAAO,KAAKwX,CAAY,CAAC,EAE9D,MAAMud,EAAW,IAAIhO,GAAU/O,EAAYhF,CAAW,EAChDgiB,EAAeJ,EAAc,SAASG,CAAQ,EAC9Cl3B,EAAU,IAAI,MAAMxB,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBiD,EAAQrC,EAAQZ,CAAC,CAAC,EAAIo6B,EAAa,IAAIp6B,CAAC,EAE1C,OAAO,IAAIgD,EAAO,UAAW3C,EAAc,KAAK4C,CAAO,CAAC,CAC1D,CACF,EACA,SAASg3B,GAAsBnxB,EAAMugB,EAAY,CAC/C,GAAIvgB,aAAgBguB,GAClB,OAAOhuB,EAAK,eAAeugB,CAAU,EAEvC,GAAIvgB,aAAgBywB,GAAuB,CACzC,MAAMS,EAAgBC,GAAsBnxB,EAAK,OAAQugB,CAAU,EACnE,OAAO,IAAIkQ,GAAsBS,EAAelxB,EAAK,cAAiB,CACxE,CACA,OAAOA,CACT,CACA/B,EAAK,UAAU,KAAO,UAAW,CAC/B,OAAO,IAAIiwB,GAAe,IAAI,CAChC,EACAjwB,EAAK,UAAU,UAAY,UAAW,CACpC,OAAO,IAAIqwB,GAAoB,IAAI,CACrC,EACArwB,EAAK,UAAU,UAAY,UAAW,CACpC,OAAO,IAAIuwB,GAAoB,IAAI,CACrC,EACAvwB,EAAK,UAAU,YAAc,UAAW,CACtC,OAAO,IAAIywB,GAAsB,IAAI,CACvC,EACAzwB,EAAK,UAAU,MAAQ,SAASvC,EAAG,CACjC,OAAO,IAAIkzB,GAAgB,KAAMlzB,CAAC,CACpC,EACAuC,EAAK,UAAU,OAAS,UAAW,CACjC,OAAO,IAAI8wB,GAAW,IAAI,CAC5B,EACA9wB,EAAK,UAAU,OAAS,UAAW,CACjC,OAAO,IAAI+wB,GAAW,IAAI,CAC5B,EACA/wB,EAAK,UAAU,OAAS,UAAW,CACjC,OAAO,IAAIgxB,GAAW,IAAI,CAC5B,EACAhxB,EAAK,UAAU,QAAU,UAAW,CAClC,OAAO,IAAIixB,GAAY,IAAI,CAC7B,EACAjxB,EAAK,UAAU,SAAW,UAAW,CACnC,OAAO,IAAImxB,GAAa,IAAI,CAC9B,EACAnxB,EAAK,UAAU,MAAQ,SAAS+e,EAAQ,CACtC,OAAO,IAAIsS,GAAU,KAAMtS,CAAM,CACnC,EACA/e,EAAK,UAAU,KAAO,SAAS+e,EAAS,EAAG,CACzC,OAAO,IAAIwS,GAAS,KAAMxS,CAAM,CAClC,EACA/e,EAAK,UAAU,UAAY,SAAS+e,EAAS,EAAG,CAC9C,OAAO,IAAI4S,GAAc,KAAM5S,CAAM,CACvC,EACA/e,EAAK,UAAU,YAAc,SAAS6xB,EAAY,CAChD,OAAO,IAAIC,GAAgB,KAAMD,CAAU,CAC7C,EACA7xB,EAAK,UAAU,WAAa,SAAS6xB,EAAY,CAC/C,OAAO,IAAIE,GAAe,KAAMF,CAAU,CAC5C,EACA7xB,EAAK,UAAU,WAAa,SAAS6xB,EAAY,CAC/C,OAAO,IAAIG,GAAe,KAAMH,CAAU,CAC5C,EACA7xB,EAAK,UAAU,WAAa,SAAS6xB,EAAY,CAC/C,OAAO,IAAIM,GAAe,KAAMN,CAAU,CAC5C,EACA7xB,EAAK,UAAU,WAAa,SAAS6xB,EAAY,CAC/C,OAAO,IAAIO,GAAe,KAAMP,CAAU,CAC5C,EACA7xB,EAAK,UAAU,IAAM,SAASsyB,EAAO,CACnC,OAAO,IAAID,GAAQ,KAAMC,CAAK,CAChC,EACAtyB,EAAK,UAAU,KAAO,YAAYyyB,EAAe,CAC/C,OAAO,IAAID,GAAsB,KAAMC,CAAa,CACtD,EACAzyB,EAAK,UAAU,QAAU,SAAS9H,EAAQ6rB,EAAY,MAAO,CAC3D,OAAO,IAAIgP,GAAkB,KAAM76B,EAAQ6rB,CAAS,CACtD,EAGA,SAASuP,GAAG1qB,EAAM,CAChB,OAAOwc,GAAU,SAASxc,CAAI,CAChC"}